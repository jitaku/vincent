// Generated by CoffeeScript 1.10.0
(function() {
  var COMConverter, HTMLEntity, HTMLTag, HTMLTag2Flatten, HTMLTagParser, Property, TableRuneParser, UlFlatter,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  HTMLEntity = require("/component/htmlEntity");

  Property = require("/component/property");

  HTMLTag = require("./htmlTag");

  COMConverter = (function() {
    function COMConverter() {}

    COMConverter.prototype.html2com = function(context, html) {
      var com, flatten, i, item, j, len, len1, parser, ref, results, richText;
      parser = new HTMLTagParser(html);
      flatten = new HTMLTag2Flatten(parser.contents);
      results = [];
      ref = flatten.result;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (typeof item === "string") {
          results.push(context.createElement("Text", {
            contentString: item
          }));
        } else {
          com = context.createElement(item);
          if (com) {
            results.push(com);
          }
        }
      }
      richText = context.createElement("RichText", {});
      for (j = 0, len1 = results.length; j < len1; j++) {
        item = results[j];
        richText.append(item);
      }
      return richText;
    };

    return COMConverter;

  })();

  HTMLTagParser = (function() {
    function HTMLTagParser(html) {
      var doc, parser;
      this.contents = new HTMLTag("!contents", [], {});
      this.tagStack = [this.contents];
      new Property(this, "currentTag").atGet((function(_this) {
        return function() {
          return _this.tagStack[_this.tagStack.length - 1] || null;
        };
      })(this));
      parser = new DOMParser();
      doc = parser.parseFromString(html, "text/html");
      this.contents.addChild(this.parse(doc));
    }

    HTMLTagParser.prototype.parse = function(el) {
      var child, i, item, j, len, len1, node, props, ref, ref1, tag;
      if (el.nodeType === el.TEXT_NODE) {
        return new HTMLTag("TEXT", el.textContent);
      }
      props = {};
      if (el.attributes) {
        ref = el.attributes;
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          props[item.name] = item.value;
        }
      }
      tag = new HTMLTag((el.tagName || "Unknown").toLowerCase(), [], props);
      if (el.childNodes) {
        ref1 = el.childNodes;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          node = ref1[j];
          child = this.parse(node);
          if (child) {
            tag.addChild(child);
          }
        }
      }
      return tag;
    };

    return HTMLTagParser;

  })();

  HTMLTag2Flatten = (function() {
    function HTMLTag2Flatten(htmlTag) {
      var fn, heading, i, level;
      this.htmlTag = htmlTag;
      this.acceptTags = ["h1", "h2", "h3", "h4", "h5", "h6", "code", "a", "img", "ul", "ol", "li", "table", "tbody", "tr", "td", "th", "strong", "pre", "b"];
      this.inlineTags = ["a", "img", "table", "strong", "bold", "b"];
      this.blockTag = ["p", "br"];
      this.elementType = ["headline", "list"];
      this.inlines = {};
      this.inlineId = 1000;
      this.inlineReg = new RegExp("\{\{\{\{[0-9]{4,8}\}\}\}\}");
      this.inlineRegG = new RegExp("\{\{\{\{[0-9]{4,8}\}\}\}\}", "g");
      heading = "";
      fn = (function(_this) {
        return function(level, heading) {
          return _this["h" + level + "Flatten"] = function(tag) {
            return "\n" + heading + " " + _this.getChildrenTextStream(tag) + "\n";
          };
        };
      })(this);
      for (level = i = 1; i <= 6; level = ++i) {
        heading += "#";
        fn(level, heading);
      }
      this.flatText = this.toFlatten(this.normalize(this.htmlTag));
      this.result = this.resolveInlineResource(this.flatText);
    }

    HTMLTag2Flatten.prototype.createTagInlineText = function(tag) {
      var id;
      id = this.inlineId++;
      this.inlines[id] = {
        id: id,
        detail: tag
      };
      return "{{{{" + id + "}}}}";
    };

    HTMLTag2Flatten.prototype.mergeTextArray = function(children) {
      var child, currentText, i, len, result;
      result = [];
      currentText = null;
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        if (child.isText()) {
          if (currentText) {
            currentText.text += child.text;
          } else {
            currentText = child;
          }
        } else {
          if (currentText) {
            currentText = this.normalizeText(currentText);
            if (currentText.text.length !== 0) {
              result.push(currentText);
            }
            result.push(child);
            currentText = null;
          } else {
            result.push(child);
          }
        }
      }
      if (currentText) {
        result.push(currentText);
      }
      return result;
    };

    HTMLTag2Flatten.prototype.normalizeText = function(tag) {
      tag.text = tag.text.replace(/\s*\n\s*\n\s*/g, "\n\n").replace(/\n\n+/g, "\n\n");
      return tag;
    };

    HTMLTag2Flatten.prototype.getChildrenTextStream = function(tag, plain) {
      var child, i, j, len, len1, plainText, ref, ref1, ref2, ref3, text;
      if (plain == null) {
        plain = false;
      }
      if (!tag.isText) {
        return "";
      }
      if (tag.isText()) {
        return tag.text;
      }
      if (ref = tag.name, indexOf.call(this.inlineTags, ref) >= 0) {
        if (plain) {
          plainText = "";
          ref1 = tag.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            plainText += this.getChildrenTextStream(child, true);
          }
          return plainText;
        }
        return this.createTagInlineText(tag);
      }
      text = "";
      ref2 = tag.children;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        child = ref2[j];
        if (child.isText()) {
          text += child.text;
        } else if (ref3 = child.name, indexOf.call(this.inlineTags, ref3) >= 0) {
          if (plain) {
            return this.getChildrenTextStream(child, plain);
          }
          text += this.createTagInlineText(tag);
        } else {
          text += this.getChildrenTextStream(child, plain);
        }
      }
      return text;
    };

    HTMLTag2Flatten.prototype.normalize = function(tag) {
      var child, i, item, j, k, len, len1, len2, ref, ref1, ref2, ref3, ref4, result;
      result = [];
      if (!(tag.children instanceof Array)) {
        return tag;
      }
      if (ref = tag.name, indexOf.call(this.acceptTags, ref) < 0) {
        ref1 = tag.children;
        for (i = 0, len = ref1.length; i < len; i++) {
          item = ref1[i];
          child = this.normalize(item);
          if (child instanceof Array) {
            result.push.apply(result, child);
          } else {
            result.push(child);
          }
        }
        if (ref2 = tag.name, indexOf.call(this.blockTag, ref2) >= 0) {
          result.push(new HTMLTag("TEXT", "\n\n"));
        }
        return this.mergeTextArray(result);
      } else if (ref3 = tag.name, indexOf.call(this.acceptTags, ref3) >= 0) {
        ref4 = tag.children;
        for (j = 0, len1 = ref4.length; j < len1; j++) {
          item = ref4[j];
          child = this.normalize(item);
          if (child instanceof Array) {
            result.push.apply(result, child);
          } else {
            result.push(child);
          }
        }
        result = this.mergeTextArray(result);
        tag.children.length = 0;
        for (k = 0, len2 = result.length; k < len2; k++) {
          child = result[k];
          tag.addChild(child);
        }
        return tag;
      }
    };

    HTMLTag2Flatten.prototype.toFlatten = function(arr) {
      var child, flatter, i, len, text;
      if (arr instanceof HTMLTag) {
        arr = [arr];
      }
      text = "";
      for (i = 0, len = arr.length; i < len; i++) {
        child = arr[i];
        if (flatter = this[child.name + "Flatten"]) {
          text += flatter.call(this, child);
        } else {
          text += this.getChildrenTextStream(child);
        }
      }
      return text;
    };

    HTMLTag2Flatten.prototype.ulFlatten = function(tag) {
      return new UlFlatter(this, tag).text;
    };

    HTMLTag2Flatten.prototype.olFlatten = function(tag) {
      return new UlFlatter(this, tag).text;
    };

    HTMLTag2Flatten.prototype.codeFlatten = function(tag) {
      return "\n```\n" + (this.escapeChar(this.getChildrenTextStream(tag), "`")) + "\n```\n";
    };

    HTMLTag2Flatten.prototype.preFlatten = function(tag) {
      return "\n```\n" + (this.escapeChar(this.getChildrenTextStream(tag), "`")) + "\n```\n";
    };

    HTMLTag2Flatten.prototype.escapeChar = function(text, char, replacement) {
      return text.replace(new RegExp(char, "g"), replacement || ("\\" + char));
    };

    HTMLTag2Flatten.prototype.resolveInlineResource = function(text) {
      var code, l, left, match, result, rune, solver, tag;
      this.inlineReg.lastIndex = 0;
      left = text;
      result = [];
      while (match = left.match(this.inlineReg)) {
        result.push(left.slice(0, match.index));
        left = left.slice(match.index + match[0].length);
        code = match[0].slice(4).slice(0, -4);
        l = this.inlines[code];
        tag = l.detail;
        if (solver = this[tag.name + "InlineSolve"]) {
          rune = solver.call(this, tag);
          if (rune) {
            result.push(rune);
            continue;
          }
        }
        result.push(this.getChildrenTextStream(tag, true));
      }
      result.push(left);
      return this.mergeSolvedResult(result);
    };

    HTMLTag2Flatten.prototype.escapeMarkdownUrl = function(string) {
      var _map, result;
      if (string == null) {
        string = "";
      }
      _map = {
        "(": "\\(",
        ")": "\\)",
        "\\": "\\\\"
      };
      result = string.replace(/\(|\)|\\/g, function(match) {
        return _map[match] || match;
      });
      return result;
    };

    HTMLTag2Flatten.prototype.mergeSolvedResult = function(arr) {
      var i, item, len, results, text;
      results = [];
      text = null;
      for (i = 0, len = arr.length; i < len; i++) {
        item = arr[i];
        if (typeof item === "string") {
          if (text) {
            text += item;
          } else {
            text = item;
          }
        } else {
          if (text) {
            results.push(text);
            text = null;
          }
          results.push(item);
        }
      }
      if (text) {
        results.push(text);
      }
      return results;
    };

    HTMLTag2Flatten.prototype.tableInlineSolve = function(tag) {
      return new TableRuneParser(this, tag).rune;
    };

    HTMLTag2Flatten.prototype.imgInlineSolve = function(tag) {
      var ref;
      return "![](" + (this.escapeMarkdownUrl((ref = tag.props) != null ? ref.src : void 0)) + ")";
    };

    HTMLTag2Flatten.prototype.bInlineSolve = function(tag) {
      return "**" + (this.getChildrenTextStream(tag, true)) + "**";
    };

    HTMLTag2Flatten.prototype.boldInlineSolve = function(tag) {
      return "**" + (this.getChildrenTextStream(tag, true)) + "**";
    };

    HTMLTag2Flatten.prototype.strongInlineSolve = function(tag) {
      return "**" + (this.getChildrenTextStream(tag, true)) + "**";
    };

    HTMLTag2Flatten.prototype.aInlineSolve = function(tag) {
      var link, title;
      link = tag.props.href;
      title = this.getChildrenTextStream(tag, true);
      return {
        type: "LinkRune",
        link: link,
        title: title
      };
    };

    return HTMLTag2Flatten;

  })();

  UlFlatter = (function() {
    function UlFlatter(flatter1, tag1) {
      var normalizedTag;
      this.flatter = flatter1;
      this.tag = tag1;
      this.items = [];
      this.acceptTags = ["ul", "li", "ol"];
      this.inlineTags = ["a", "img", "table", "strong", "bold"];
      this.blockTag = [];
      this.indentStep = 4;
      normalizedTag = this.normalize(this.tag);
      this.text = this.flatten(normalizedTag) + "\n";
    }

    UlFlatter.prototype.normalize = function(tag) {
      var child, i, item, j, k, len, len1, len2, ref, ref1, ref2, ref3, ref4, ref5, ref6, result, t;
      result = [];
      if (!(tag.children instanceof Array)) {
        return tag;
      }
      if ((ref = tag.name, indexOf.call(this.acceptTags, ref) < 0) && (ref1 = tag.name, indexOf.call(this.inlineTags, ref1) < 0)) {
        ref2 = tag.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          item = ref2[i];
          child = this.normalize(item);
          if (child instanceof Array) {
            result.push.apply(result, child);
          } else {
            result.push(child);
          }
        }
        if (ref3 = tag.name, indexOf.call(this.blockTag, ref3) >= 0) {
          result.push(new HTMLTag("TEXT", "\n"));
        }
        return this.flatter.mergeTextArray(result);
      } else if (ref4 = tag.name, indexOf.call(this.acceptTags, ref4) >= 0) {
        ref5 = tag.children;
        for (j = 0, len1 = ref5.length; j < len1; j++) {
          item = ref5[j];
          child = this.normalize(item);
          if (child instanceof Array) {
            result.push.apply(result, child);
          } else {
            result.push(child);
          }
        }
        result = this.flatter.mergeTextArray(result);
        tag.children.length = 0;
        for (k = 0, len2 = result.length; k < len2; k++) {
          child = result[k];
          tag.addChild(child);
        }
        return tag;
      } else if (ref6 = tag.name, indexOf.call(this.inlineTags, ref6) >= 0) {
        t = new HTMLTag("TEXT", this.flatter.createTagInlineText(tag));
        return t;
      }
    };

    UlFlatter.prototype.flatten = function(tag, indent) {
      var child, i, index, j, k, len, len1, previousText, ref, ref1, ref2, ref3, ref4, space, t, tailing, text;
      if (indent == null) {
        indent = 0;
      }
      space = "";
      for (index = i = 0, ref = indent; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
        space += " ";
      }
      if (tag.name === "li") {
        text = space + " * ";
        tailing = true;
        ref1 = tag.children;
        for (j = 0, len = ref1.length; j < len; j++) {
          child = ref1[j];
          if (child.isText()) {
            text += this.singleline(child.text);
          } else if ((ref2 = child.name) === "ul" || ref2 === "ol") {
            tailing = false;
            text += "\n" + this.flatten(child, indent + this.indentStep);
          } else if (child.name === "li") {
            text += this.flatter.getChildrenTextStream(child);
          } else {
            Logger.error("Unexpected tag(" + tag.name + ")", tag);
            continue;
          }
        }
        return text + (tailing && "\n" || "");
      } else if ((ref3 = tag.name) === "ul" || ref3 === "ol") {
        text = "";
        previousText = false;
        tailing = true;
        ref4 = tag.children;
        for (k = 0, len1 = ref4.length; k < len1; k++) {
          child = ref4[k];
          if (child.isText()) {
            if (t = child.text.trim()) {
              previousText = true;
              text += t;
            } else {
              continue;
            }
          } else if (child.name === ["ul", "ol"]) {
            text += this.flatter.getChildrenTextStream(child);
          } else if (child.name === "li") {
            tailing = false;
            if (previousText) {
              previousText = false;
              text += "\n";
            }
            text += this.flatten(child, indent);
          }
        }
        return text + (tailing && "\n" || "");
      } else if (tag.isText()) {
        return tag.text;
      }
    };

    UlFlatter.prototype.singleline = function(text) {
      return text.replace(/\s*\n\s*/g, " ");
    };

    return UlFlatter;

  })();

  TableRuneParser = (function() {
    function TableRuneParser(flatter1, tag1) {
      var ref, ref1;
      this.flatter = flatter1;
      this.tag = tag1;
      this.rune = null;
      if (((ref = this.tag.children[0]) != null ? ref.name : void 0) === "tbody") {
        this.parseTableContent(this.tag.children[0]);
      } else if (((ref1 = this.tag.children[0]) != null ? ref1.name : void 0) === "tr") {
        this.parseTableContent(this.tag);
      } else {
        return this;
      }
    }

    TableRuneParser.prototype.normalize = function(tag) {
      var c, child, children, i, j, k, len, len1, len2, len3, m, ref, ref1, ref2, results;
      if ((ref = tag.name) === "th" || ref === "td") {
        return tag;
      }
      if (tag.name === "tbody" || tag.name === "table") {
        children = tag.children.slice();
        results = [];
        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          if ((ref1 = child.name) !== "tr") {
            continue;
          }
          if (c = this.normalize(child)) {
            results.push(c);
          }
        }
        tag.children.length = 0;
        for (j = 0, len1 = results.length; j < len1; j++) {
          child = results[j];
          tag.addChild(child);
        }
        return tag;
      }
      if (tag.name === "tr") {
        children = tag.children.slice();
        results = [];
        for (k = 0, len2 = children.length; k < len2; k++) {
          child = children[k];
          if ((ref2 = child.name) !== "td" && ref2 !== "th") {
            continue;
          }
          if (c = this.normalize(child)) {
            results.push(c);
          }
        }
        tag.children.length = 0;
        for (m = 0, len3 = results.length; m < len3; m++) {
          child = results[m];
          tag.addChild(child);
        }
        return tag;
      }
      return null;
    };

    TableRuneParser.prototype.parseTableContent = function(tag) {
      var cells, child, colCount, i, j, k, len, len1, len2, ref, ref1, ref2, ref3, ref4, row, rowCount;
      tag = this.normalize(tag);
      ref = tag.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        if (child.name !== "tr") {
          return null;
        }
      }
      colCount = tag.children.length;
      rowCount = (ref1 = tag.children[0]) != null ? (ref2 = ref1.children) != null ? ref2.length : void 0 : void 0;
      if (!colCount || !rowCount) {
        return null;
      }
      cells = [];
      ref3 = tag.children;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        row = ref3[j];
        ref4 = row.children;
        for (k = 0, len2 = ref4.length; k < len2; k++) {
          child = ref4[k];
          cells.push({
            type: "TableCell",
            contentString: this.flatter.getChildrenTextStream(child, "plain")
          });
        }
      }
      return this.rune = {
        type: "Table",
        col: colCount,
        row: rowCount,
        children: cells
      };
    };

    return TableRuneParser;

  })();

  COMConverter.HTMLTagParser = HTMLTagParser;

  COMConverter.HTMLTag2Flatten = HTMLTag2Flatten;

  module.exports = COMConverter;

}).call(this);
