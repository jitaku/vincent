// Generated by CoffeeScript 1.10.0
(function() {
  var ActivableTrait, BackupInputMethod, BrowserDefaultKeyBehaviorPreventor, CompositeSession, ContentEditableHacker, Errors, EventEmitter, FocusableTrait, GeneralInputMethod, InputMethodChrome, InputMethodMaster, KeyEvent, KeyEventHandler, States, Trait,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  KeyEvent = require("../common/keyEvent");

  States = require("../common/states");

  Errors = require("../common/errors");

  EventEmitter = (require("../common/events")).EventEmitter;

  Trait = require("../com/helper/trait");

  InputMethodMaster = (function(superClass) {
    extend(InputMethodMaster, superClass);

    function InputMethodMaster(editor) {
      this.editor = editor;
      InputMethodMaster.__super__.constructor.call(this);
    }

    InputMethodMaster.prototype.init = function() {
      this.coreInputMethod = new GeneralInputMethod(this.editor, this);
      this.backupInputMethod = new BackupInputMethod(this.editor, this);
      this.inputMethods = [this.coreInputMethod, this.backupInputMethod];
      new BrowserDefaultKeyBehaviorPreventor();
      this.coreInputMethod.on("workingStateChange", (function(_this) {
        return function() {
          return _this.emit("workingStateChange");
        };
      })(this));
      this.backupInputMethod.on("interactive", (function(_this) {
        return function() {
          return _this.ensureInputStateWithoutVirtualKeyboard();
        };
      })(this));
      this.currentInputMethod = this.coreInputMethod;
      this.hasFocus = true;
      this.editor.bufferManager.listenBy(this, "focus", (function(_this) {
        return function(buffer) {
          return _this.attachTo(buffer);
        };
      })(this));
      return this.editor.caret.listenBy(this, "move", (function(_this) {
        return function() {
          return _this.updatePosition();
        };
      })(this));
    };

    InputMethodMaster.prototype.isMobileKeyboardShow = function() {
      var _, h, keyboardMinSize, sh, sw, w;
      if (!this.editor.platform.isMobile()) {
        return false;
      }
      h = document.body.clientHeight;
      w = document.body.clientWidth;
      sw = window.screen.width;
      sh = window.screen.height;
      keyboardMinSize = sh / 4;
      if ((h - w) * (sh - sw) < 0) {
        _ = sw;
        sw = sh;
        sh = _;
      }
      return sh - h > keyboardMinSize;
    };

    InputMethodMaster.prototype.attachTo = function(buffer) {
      var i, len, method, ref, ref1, ref2, ref3, ref4;
      if (!buffer.interactive) {
        return false;
      }
      if (buffer === this.buffer) {
        return;
      }
      if ((ref = this.buffer) != null) {
        ref.stopListenBy(this);
      }
      if ((ref1 = this.buffer) != null) {
        if ((ref2 = ref1.viewPort) != null) {
          ref2.stopListenBy(this);
        }
      }
      if ((ref3 = this.cursor) != null) {
        ref3.stopListenBy(this);
      }
      this.buffer = buffer;
      this.cursor = this.buffer.cursor;
      ref4 = this.inputMethods;
      for (i = 0, len = ref4.length; i < len; i++) {
        method = ref4[i];
        method.attachTo(buffer);
      }
      this.cursor.listenBy(this, "move", (function(_this) {
        return function() {
          return _this.editor.inputMethod.flush();
        };
      })(this));
      if (this.viewPort) {
        this.viewPort.stopListenBy(this);
      }
      this.viewPort = buffer.viewPort;
      this.viewPort.listenBy(this, "hasInteraction", (function(_this) {
        return function() {
          return _this.ensureInputStateWithoutVirtualKeyboard();
        };
      })(this));
      this.ensureInputStateWithoutVirtualKeyboard();
      this.attachRootElement(this.buffer.viewPort.rootElement);
      return this.buffer.viewPort.listenBy(this, "rootElement", (function(_this) {
        return function() {
          return _this.attachRootElement(_this.buffer.viewPort.rootElement);
        };
      })(this));
    };

    InputMethodMaster.prototype.attachRootElement = function(rootEl) {};

    InputMethodMaster.prototype.updatePosition = function() {
      var bl, fix, ref;
      bl = this.editor.caret.node.getBoundingClientRect();
      fix = document.body.getBoundingClientRect();
      return (ref = this.currentInputMethod) != null ? ref.updatePosition((bl.right + bl.left - fix.left * 2) / 2, bl.bottom - fix.top + 2, fix.bottom, fix.right) : void 0;
    };

    InputMethodMaster.prototype.releaseDocumentFocus = function() {
      if (!this.hasDocumentFocus) {
        return;
      }
      this.hasDocumentFocus = false;
      this.ensureInputStateWithoutVirtualKeyboard();
      return this.emit("workingStateChange");
    };

    InputMethodMaster.prototype.obtainDocumentFocus = function() {
      if (this.hasDocumentFocus) {
        return;
      }
      this.hasDocumentFocus = true;
      this.ensureInputStateWithoutVirtualKeyboard();
      return this.emit("workingStateChange");
    };

    InputMethodMaster.prototype.activate = function() {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      this.ensureInputStateWithoutVirtualKeyboard();
      return this.emit("workingStateChange");
    };

    InputMethodMaster.prototype.deactivate = function() {
      if (!this.isActive) {
        return;
      }
      this.isActive = false;
      this.ensureInputStateWithoutVirtualKeyboard();
      return this.emit("workingStateChange");
    };

    InputMethodMaster.prototype.flush = function() {
      var ref;
      return (ref = this.currentInputMethod) != null ? typeof ref.flush === "function" ? ref.flush() : void 0 : void 0;
    };

    InputMethodMaster.prototype.blur = function() {
      var ref;
      return (ref = this.currentInputMethod) != null ? typeof ref.blur === "function" ? ref.blur() : void 0 : void 0;
    };

    InputMethodMaster.prototype.focus = function() {
      var ref;
      return (ref = this.currentInputMethod) != null ? typeof ref.focus === "function" ? ref.focus() : void 0 : void 0;
    };

    InputMethodMaster.prototype.showVirtualKeyboard = function() {
      if (!this.editor.platform.isVirtualKeyboard()) {
        return;
      }
      this.activate();
      return this.applyState();
    };

    InputMethodMaster.prototype.hideVirtualKeyboard = function() {
      if (!this.editor.platform.isVirtualKeyboard()) {
        return;
      }
      this.deactivate();
      return this.applyState();
    };

    InputMethodMaster.prototype.ensureInputStateWithoutVirtualKeyboard = function() {
      if (this.editor.platform.isVirtualKeyboard()) {
        return;
      }
      this.updatePosition();
      return this.applyState();
    };

    InputMethodMaster.prototype.applyState = function() {
      var i, im, j, len, len1, ref, ref1, results;
      if (this.isActive) {
        if (this.hasDocumentFocus) {
          this.currentInputMethod = this.coreInputMethod;
        } else {
          this.currentInputMethod = this.backupInputMethod;
        }
        ref = this.inputMethods;
        for (i = 0, len = ref.length; i < len; i++) {
          im = ref[i];
          if (im !== this.currentInputMethod) {
            if (im.isActive) {
              im.deactivate();
            }
            im.ensureFocusState();
          }
        }
        if (!this.currentInputMethod.isActive) {
          this.currentInputMethod.activate();
        }
        this.currentInputMethod.ensureFocusState();
        return this.listenTo(this.currentInputMethod);
      } else {
        ref1 = this.inputMethods;
        results = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          im = ref1[j];
          im.deactivate();
          results.push(im.ensureFocusState());
        }
        return results;
      }
    };

    InputMethodMaster.prototype.listenTo = function(item) {
      if (this.lastListenTarget) {
        this.lastListenTarget.stopListenBy(this);
      }
      item.listenBy(this, "input", (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.emit.apply(_this, ["input"].concat(slice.call(args)));
        };
      })(this));
      item.listenBy(this, "key", (function(_this) {
        return function(key) {
          return _this.emit("key", key);
        };
      })(this));
      item.listenBy(this, "image", (function(_this) {
        return function(image) {
          return _this.emit("image", image);
        };
      })(this));
      return this.lastListenTarget = item;
    };

    return InputMethodMaster;

  })(EventEmitter);

  BackupInputMethod = (function(superClass) {
    extend(BackupInputMethod, superClass);

    function BackupInputMethod(context, master) {
      this.context = context;
      this.master = master;
      BackupInputMethod.__super__.constructor.call(this);
      this.canWrite = true;
      window.addEventListener("keydown", (function(_this) {
        return function(e) {
          var ke;
          _this.emit("interactive");
          if (!_this.isActive) {
            return;
          }
          if (!_this.hasFocus) {
            return;
          }
          ke = new KeyEvent(e);
          return _this.emit("key", ke);
        };
      })(this), true);
      window.addEventListener("keyup", (function(_this) {
        return function(e) {
          var ke;
          if (!_this.isActive) {
            return;
          }
          if (!_this.hasFocus) {
            return;
          }
          ke = new KeyEvent(e);
          return _this.emit("key", ke);
        };
      })(this), true);
      this.hasFocus = true;
    }

    BackupInputMethod.prototype.ensureFocusState = function() {
      return this.hasFocus = this.isActive;
    };

    BackupInputMethod.prototype.updatePosition = function(x, y) {
      return true;
    };

    BackupInputMethod.prototype.activate = function() {
      this.isActive = true;
      return this.hasFocus = true;
    };

    BackupInputMethod.prototype.deactivate = function() {
      this.isActive = false;
      return this.hasFocus = false;
    };

    BackupInputMethod.prototype.attachTo = function() {};

    return BackupInputMethod;

  })(Leaf.EventEmitter);

  InputMethodChrome = (function(superClass) {
    extend(InputMethodChrome, superClass);

    InputMethodChrome.prototype.attachTo = function(buffer) {
      var ref;
      this.buffer = buffer;
      if ((ref = this.cursor) != null) {
        ref.stopListenBy(this);
      }
      this.cursor = this.buffer.cursor;
      return this.cursor.listenBy(this, "move", (function(_this) {
        return function() {
          return _this.flush();
        };
      })(this));
    };

    function InputMethodChrome(editor, master) {
      this.editor = editor;
      this.master = master;
      InputMethodChrome.__super__.constructor.call(this);
      this.input = document.createElement("textarea");
      this.input$ = $(this.input);
      this.input.classList.add("input-method");
      this.input.addEventListener("keydown", this.onkeydown.bind(this), true);
      this.input.addEventListener("keyup", this.onkeyup.bind(this), true);
      this.input.addEventListener("compositionstart", this.oncompositionstart.bind(this));
      this.input.addEventListener("compositionupdate", this.oncompositionupdate.bind(this));
      this.input.addEventListener("compositionend", this.oncompositionend.bind(this));
      this.checkResize = this.checkResize.bind(this);
      this.input.addEventListener("focus", (function(_this) {
        return function() {
          _this._canWrite = true;
          return _this.emit("workingStateChange");
        };
      })(this));
      this.input.addEventListener("blur", (function(_this) {
        return function() {
          _this._canWrite = false;
          return _this.emit("workingStateChange");
        };
      })(this));
      this.__defineGetter__("canWrite", (function(_this) {
        return function() {
          return _this._canWrite && document.activeElement === _this.input;
        };
      })(this));
      this.input.raws = 1;
      this.__defineGetter__("shouldUseRealHolder", (function(_this) {
        return function() {
          if (_this.editor.platform.isMobile()) {
            return true;
          }
          return false;
        };
      })(this));
      document.body.appendChild(this.input);
      this.data.keys = {};
    }

    InputMethodChrome.prototype.delayCheck = function() {
      clearTimeout(this.checkTimer);
      return this.checkTimer = setTimeout((function(_this) {
        return function() {
          return _this.check();
        };
      })(this), 0);
    };

    InputMethodChrome.prototype.updatePosition = function(x, y, maxBottom, maxRight) {
      var args, change, css, i, index, item, len;
      args = [x, y, maxBottom, maxRight];
      change = false;
      if (this.positionCache) {
        for (index = i = 0, len = args.length; i < len; index = ++i) {
          item = args[index];
          if (item === this.positionCache[index]) {
            continue;
          } else {
            change = true;
            break;
          }
        }
        if (!change) {
          return false;
        }
      }
      this.positionCache = args;
      if (x < 0) {
        x = 0;
      }
      if (y < 0) {
        y = 0;
      }
      css = {};
      if (maxBottom && maxBottom < y) {
        css.bottom = 0;
      } else {
        css.top = y;
      }
      if (maxRight && maxRight < x) {
        css.right = 0;
      } else {
        css.left = x;
      }
      if (this.editor.platform.isMobile() && !this.data.isComposing) {
        css.left = 0;
        css.right = "auto";
        css.bottom = 10;
      }
      if (this.editor.platform.isMobile() && false) {
        css.left = "auto";
        css.right = "-30px";
        css.bottom = "0";
        css.top = "auto";
        css.width = "100%";
        return this.input$.css(css);
      } else {
        css.position = "absolute";
        return this.input$.css(css);
      }
    };

    InputMethodChrome.prototype.reset = function() {
      InputMethodChrome.__super__.reset.call(this);
      this.lastHolder = " ";
      this.input.value = this.lastHolder;
      return this.data.keys = {};
    };

    InputMethodChrome.prototype.activate = function() {
      if (this.isActive) {
        return;
      }
      this.focus();
      this.reset();
      this.setState("wait");
      return this.isActive = true;
    };

    InputMethodChrome.prototype.deactivate = function() {
      if (!this.isActive) {
        return;
      }
      this.blur();
      if (this.editor.platform.isMobile()) {
        window.removeEventListener("resize", this.checkResize);
      }
      return this.isActive = false;
    };

    InputMethodChrome.prototype.ensureFocusState = function(option) {
      if (option == null) {
        option = {};
      }
      this.data.keys = {};
      if (this.isActive && document.activeElement !== this.input && (option.forceFocus || !this.editor.platform.isMobile())) {
        return this.focus();
      } else if (!this.isActive && document.activeElement === this.input) {
        return this.blur();
      }
    };

    InputMethodChrome.prototype.focus = function() {
      if (this.editor.platform.isMobile()) {
        this.input.blur();
      }
      return this.input.focus();
    };

    InputMethodChrome.prototype.blur = function() {
      return this.input.blur();
    };

    InputMethodChrome.prototype.flush = function() {
      var contents, cursor, period, period2, period3, period4, value;
      value = this.input.value;
      if (this.holder == null) {
        this.holder = " ";
      }
      if (this.shouldUseRealHolder && this.cursor) {
        cursor = this.cursor;
        if (cursor && cursor.version !== this.cursorVersion) {
          contents = cursor != null ? typeof cursor.getSurroundingText === "function" ? cursor.getSurroundingText(15) : void 0 : void 0;
          period = contents.before.lastIndexOf(".");
          period2 = contents.before.lastIndexOf("?");
          period3 = contents.before.lastIndexOf("!");
          period4 = contents.before.lastIndexOf("\n");
          period = Math.max(period, period2, period3, period4);
          if (period >= 0) {
            contents.before = contents.before.slice(period + 1);
          }
          contents.before = contents.before.replace(/\n/g, " ");
          if (contents.before.length === 0) {
            contents.before = " ";
          }
          this.holder = contents.before;
          this.cursorVersion = cursor.version;
        }
      } else {
        this.holder = " ";
      }
      if (value !== this.holder) {
        this.input.value = this.holder;
      }
      if (value !== this.lastHolder && (value === this.lastHolder.slice(0, -1) || (value.length === 0))) {
        this.emit("key", new KeyEvent({
          which: 8
        }));
      } else if (value !== this.lastHolder) {
        value = value.slice(this.lastHolder.length);
        if (value && value.length > 0) {
          this.emit("input", value);
        }
      }
      return this.lastHolder = this.holder;
    };

    InputMethodChrome.prototype.check = function() {
      var Key, event, keys, prop, results;
      if (!this.isActive) {
        return;
      }
      Key = Leaf.Key;
      if (this.state !== "composition" && (this.input.value.length > 0 || this.editor.platform.isMobile())) {
        this.data.canFlush = true;
      }
      if (this.data.canFlush) {
        this.data.canFlush = false;
        this.flush();
      }
      keys = this.data.keys;
      results = [];
      for (prop in keys || {}) {
        event = keys != null ? keys[prop] : void 0;
        if (event && !event.defaultPrevented) {
          if (keys != null) {
            delete keys[prop];
          }
          results.push(this.emit("key", new KeyEvent(event)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    InputMethodChrome.prototype.onkeydown = function(e) {
      this.delayCheck();
      if (this.isWaitingFor("input")) {
        return this.give("input", {
          type: "keyboard",
          event: e
        });
      }
    };

    InputMethodChrome.prototype.onkeyup = function(e) {
      this.delayCheck();
      if (this.isWaitingFor("input")) {
        return this.give("input", {
          type: "keyboard",
          event: e
        });
      }
    };

    InputMethodChrome.prototype.oncompositionstart = function(e) {
      if (this.isWaitingFor("input")) {
        return this.give("input", {
          type: "ime",
          event: e,
          action: "start"
        });
      }
    };

    InputMethodChrome.prototype.oncompositionupdate = function(e) {
      this.delayCheck();
      if (this.isWaitingFor("input")) {
        return this.give("input", {
          type: "ime",
          event: e,
          action: "update"
        });
      }
    };

    InputMethodChrome.prototype.oncompositionend = function(e) {
      this.delayCheck();
      if (this.isWaitingFor("input")) {
        return this.give("input", {
          type: "ime",
          event: e,
          action: "end"
        });
      }
    };

    InputMethodChrome.prototype.onpaste = function(e) {
      var blob, cdata, i, item, len, ref, results, type;
      cdata = e.clipboardData;
      ref = e.clipboardData.items || {};
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        type = item.type || "";
        if (type.indexOf("image/") === 0) {
          blob = item.getAsFile();
          if (blob instanceof Blob) {
            this.emit("image", {
              blob: blob
            });
            e.preventDefault();
            results.push(e.stopImmediatePropagation());
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    InputMethodChrome.prototype.handleKeyboard = function(e) {
      if (e.type === "keyup") {
        this.data.canFlush = true;
      } else if (e.type === "keydown") {
        this.data.canFlush = true;
      }
      this.data.keys[e.which] = e;
      return this.check();
    };

    InputMethodChrome.prototype.atWait = function(sole) {
      return this.waitFor("input", (function(_this) {
        return function(input) {
          if (input.type === "keyboard") {
            _this.handleKeyboard(input.event);
            if (_this.stale(sole)) {
              return;
            }
            _this.setState("wait");
            return;
          }
          if (input.type === "ime" && input.action === "start") {
            _this.setState("composition");
            return;
          }
          _this.error(new Errors.UnexpectedInput("unexpected input at wait", {
            input: info
          }));
        };
      })(this));
    };

    InputMethodChrome.prototype.atPanic = function() {
      return Logger.error(this.panicState, this.panicError);
    };

    InputMethodChrome.prototype.atComposition = function() {
      this.input.classList.add("compose");
      this.data.isComposing = true;
      this.data.canFlush = false;
      return this.waitFor("input", (function(_this) {
        return function(input) {
          if (input.type !== "ime") {
            _this.setState("composition");
            return;
          }
          if (input.action === "update") {
            _this.setState("composition");
            return;
          }
          if (input.action === "end") {
            _this.data.canFlush = true;
            _this.data.isComposing = false;
            _this.input.classList.remove("compose");
            _this.setState("wait");
            return;
          }
          return _this.setState("composition");
        };
      })(this));
    };

    return InputMethodChrome;

  })(States);

  CompositeSession = (function() {
    function CompositeSession(fullText, compositePart) {
      this.fullText = fullText;
      this.compositePart = compositePart;
    }

    CompositeSession.prototype.isValid = function() {
      var ref;
      return ((ref = this.fullText) != null ? typeof ref.slice === "function" ? ref.slice(-this.compositePart.length) : void 0 : void 0) === this.compositePart;
    };

    return CompositeSession;

  })();

  GeneralInputMethod = (function(superClass) {
    extend(GeneralInputMethod, superClass);

    function GeneralInputMethod(editor, master) {
      var Key;
      this.editor = editor;
      this.master = master;
      GeneralInputMethod.__super__.constructor.call(this);
      new FocusableTrait(this);
      new ActivableTrait(this);
      new KeyEventHandler(this);
      this.input = document.createElement("textarea");
      this.input$ = $(this.input);
      this.input.classList.add("general-input-method");
      this.input.addEventListener("keydown", this.onkeydown.bind(this), true);
      this.input.addEventListener("keyup", this.onkeyup.bind(this), true);
      this.input.addEventListener("input", this.oninput.bind(this));
      this.input.addEventListener("compositionstart", this.oncompositionstart.bind(this));
      this.input.addEventListener("compositionupdate", this.oncompositionupdate.bind(this));
      if (this.editor.platform.isMobile()) {
        this.requestIMEComplete = true;
      }
      this.inputHolder = "  ";
      this.input.addEventListener("compositionend", this.oncompositionend.bind(this));
      this.sessionId = 0;
      document.body.appendChild(this.input);
      this.checkResize = this.checkResize.bind(this);
      window.addEventListener("resize", this.checkResize);
      this.input.addEventListener("blur", (function(_this) {
        return function() {
          return _this.reform();
        };
      })(this));
      Key = Leaf.Key;
      this.charKeys = {
        " ": {
          which: Key.space,
          shiftKey: true
        },
        "!": {
          which: Key["1"],
          shiftKey: true
        },
        "@": {
          which: Key["2"],
          shiftKey: true
        },
        "#": {
          which: Key["3"],
          shiftKey: true
        },
        "$": {
          which: Key["4"],
          shiftKey: true
        },
        "%": {
          which: Key["5"],
          shiftKey: true
        },
        "^": {
          which: Key["6"],
          shiftKey: true
        },
        "&": {
          which: Key["7"],
          shiftKey: true
        },
        "*": {
          which: Key["8"],
          shiftKey: true
        },
        "(": {
          which: Key["9"],
          shiftKey: true
        },
        ")": {
          which: Key["0"],
          shiftKey: true
        },
        "_": {
          which: Key.dash,
          shiftKey: true
        },
        "+": {
          which: Key.equal,
          shiftKey: true
        },
        "~": {
          which: Key.graveAccent,
          shiftKey: true
        },
        "`": {
          which: Key.graveAccent
        }
      };
      this.forceDisplay = false;
    }

    GeneralInputMethod.prototype.checkResize = function() {
      clearTimeout(this.resizeTimer);
      this.resizeTimer = setTimeout((function(_this) {
        return function() {
          var height, keyboardHeightMin;
          height = window.innerHeight;
          keyboardHeightMin = height / 4;
          if (Math.abs(height - _this.editor.initHeight) < keyboardHeightMin) {
            return window.document.activeElement.blur();
          }
        };
      })(this), 500);
      return setTimeout((function(_this) {
        return function() {
          var height, keyboardHeightMin;
          height = window.innerHeight;
          keyboardHeightMin = 150;
          if (!Math.abs(height - _this.editorn.initHeight) < keyboardHeightMin) {
            return _this.editor.caret.scrollViewPortToComfortable();
          }
        };
      })(this), 10);
    };

    GeneralInputMethod.prototype.atPanic = function() {
      return Logger.error(this.panicError, this.panicState);
    };

    GeneralInputMethod.prototype.sync = function(input) {
      var charKey, content, e, error, error1, holderLength, ke, prevContent, ref, ref1, ref2, ref3, ref4, ref5, suggestedContent, withEnter;
      if (this.input.value === this.data.base.slice(0, -1)) {
        try {
          this.emit("key", new KeyEvent({
            which: 8
          }));
          this.reform();
        } catch (error) {
          e = error;
          Logger.error(e);
        }
        return false;
      } else if (this.input.value === this.data.base.slice(0, this.input.value.length) && this.data.base.length - this.inputHolder.length >= ((ref = this.input.value) != null ? ref.length : void 0)) {
        try {
          this.editor.conduct("delete-word");
          this.reform();
        } catch (error1) {
          e = error1;
          Logger.error(e);
        }
        return false;
      }
      holderLength = this.inputHolder.length;
      withEnter = false;
      charKey = null;
      prevContent = this.data.previousContent || this.data.base.slice(this.inputHolder.length);
      if (((ref1 = this.input.value) != null ? ref1.slice(-1) : void 0) === "\n") {
        ke = new KeyEvent({
          which: 13
        });
        this.emit("key", ke);
        if (ke.defaultPrevented) {
          content = this.input.value.slice(holderLength, -1);
          this.input.value = this.input.value.slice(0, holderLength);
          withEnter = true;
        } else {
          content = this.input.value.slice(holderLength);
        }
      } else if (charKey = this.charKeys[(ref2 = this.input.value) != null ? ref2.slice(-1) : void 0]) {
        ke = new KeyEvent(charKey);
        this.emit("key", ke);
        if (ke.defaultPrevented) {
          content = this.input.value.slice(holderLength, -1);
          this.input.value = this.input.value.slice(0, holderLength);
        } else {
          content = this.input.value.slice(holderLength);
        }
      } else {
        content = this.input.value.slice(holderLength);
      }
      if (prevContent === content) {
        return true;
      }
      this.isReplacingIME = true;
      if (!this.editor.buffer.selection.isCollapsed() && this.editor.buffer.selection.isActive) {
        this.editor.buffer.context.transact((function(_this) {
          return function() {
            _this.editor.buffer.selection.removeSelectedNodes();
            _this.editor.buffer.selection.collapseToBegin();
            return _this.editor.buffer.selection.deactivate();
          };
        })(this));
      }
      this.editor.userIsWriting = true;
      this.cursor.IMEReplace(prevContent, content);
      this.editor.userIsWriting = false;
      this.data.previousContent = content;
      this.isReplacingIME = false;
      this.data.previousContent = content;
      if (((ref3 = this.input.value) != null ? ref3.indexOf("\n") : void 0) > 0 || withEnter) {
        this.reform();
        return false;
      }
      if (this.data.suggestedContent) {
        suggestedContent = this.data.suggestedContent;
        if ((ref4 = this.buffer) != null) {
          ref4.nextRender((function(_this) {
            return function() {
              var ref5;
              if (suggestedContent === _this.data.suggestedContent) {
                return (ref5 = _this.buffer) != null ? ref5.imeHint.hint(_this.data.suggestedContent) : void 0;
              }
            };
          })(this));
        }
      } else {
        if ((ref5 = this.buffer) != null) {
          ref5.imeHint.clear();
        }
      }
      return true;
    };

    GeneralInputMethod.prototype.attachTo = function(buffer) {
      var ref, ref1, ref2, ref3;
      if (buffer === this.buffer) {
        return;
      }
      if ((ref = this.buffer) != null) {
        ref.stopListenBy(this);
      }
      if ((ref1 = this.buffer) != null) {
        if ((ref2 = ref1.imeHint) != null) {
          ref2.clear();
        }
      }
      this.buffer = buffer;
      if ((ref3 = this.cursor) != null) {
        ref3.stopListenBy(this);
      }
      this.cursor = this.buffer.cursor;
      this.cursor.listenBy(this, "move", (function(_this) {
        return function() {
          clearTimeout(_this._reformTimer);
          if (!_this.isReplacingIME) {
            return _this._reformTimer = setTimeout(function() {
              if (!_this.isReplacingIME && !_this.master.isMobileKeyboardShow()) {
                return _this.reform();
              }
            }, 5);
          }
        };
      })(this));
      return this.reform();
    };

    GeneralInputMethod.prototype.reform = function() {
      var ref, ref1;
      this.reset();
      if ((ref = this.buffer) != null) {
        if ((ref1 = ref.context) != null) {
          ref1.history.enableCheckPoint();
        }
      }
      return this.setState("init");
    };

    GeneralInputMethod.prototype.getComposingText = function() {
      return GeneralInputMethod.__super__.getComposingText.call(this);
    };

    GeneralInputMethod.prototype.updatePosition = function(x, y, maxBottom, maxRight) {
      var args, change, css, i, index, item, len, minLeft, xFix, yFix;
      minLeft = 0;
      if (this.editor.platform.isMobile() && !this.forceDisplay) {
        x = -500;
        minLeft = -999999;
      }
      args = [x, y, maxBottom, maxRight];
      change = false;
      xFix = 0;
      yFix = 0;
      if (this.editor.platform.isMobile()) {
        yFix = -25;
      }
      if (this.positionCache) {
        for (index = i = 0, len = args.length; i < len; index = ++i) {
          item = args[index];
          if (item === this.positionCache[index]) {
            continue;
          } else {
            change = true;
            break;
          }
        }
        if (!change) {
          return false;
        }
      }
      this.positionCache = args;
      css = {
        top: y + yFix,
        left: x + xFix
      };
      if (maxBottom && maxBottom < y) {
        delete css.top;
        css.bottom = 0;
      } else {
        css.top = y;
      }
      css.position = "absolute";
      return this.input$.css(css);
    };

    GeneralInputMethod.prototype.reset = function() {
      return GeneralInputMethod.__super__.reset.call(this);
    };

    GeneralInputMethod.prototype.onkeydown = function(e) {
      return this.feed("input", {
        type: "keyboard",
        event: e
      });
    };

    GeneralInputMethod.prototype.onkeyup = function(e) {
      return this.feed("input", {
        type: "keyboard",
        event: e
      });
    };

    GeneralInputMethod.prototype.oninput = function(e) {
      return this.feed("input", {
        type: "input",
        event: e
      });
    };

    GeneralInputMethod.prototype.oncompositionstart = function(e) {
      return this.feed("input", {
        type: "ime",
        event: e,
        action: "start"
      });
    };

    GeneralInputMethod.prototype.oncompositionupdate = function(e) {
      return this.feed("input", {
        type: "ime",
        event: e,
        action: "update"
      });
    };

    GeneralInputMethod.prototype.oncompositionend = function(e) {
      return this.feed("input", {
        type: "ime",
        event: e,
        action: "end"
      });
    };

    GeneralInputMethod.prototype.onpaste = function(e) {
      var blob, cdata, i, item, len, ref, results, type;
      this.reform();
      cdata = e.clipboardData;
      ref = e.clipboardData.items || {};
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        type = item.type || "";
        if (type.indexOf("image/") === 0) {
          blob = item.getAsFile();
          if (blob instanceof Blob) {
            this.emit("image", {
              blob: blob
            });
            e.preventDefault();
            results.push(e.stopImmediatePropagation());
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    GeneralInputMethod.prototype.atPanic = function() {
      return Logger.error(this.panicState, this.panicError);
    };

    GeneralInputMethod.prototype.atHang = function() {};

    GeneralInputMethod.prototype.atInit = function() {
      var ref, ref1, word;
      if (!this.cursor) {
        this.setState("hang");
        return;
      }
      if (this.requestIMEComplete) {
        word = ((ref = this.cursor) != null ? (ref1 = ref.getSurroundingWord(2)) != null ? ref1.before : void 0 : void 0) || "";
        this.data.base = this.inputHolder + word;
      } else {
        this.data.base = this.inputHolder;
      }
      if (this.input.value !== this.data.base) {
        this.input.value = this.data.base;
      }
      return this.setState("waitCompositeUpdate");
    };

    GeneralInputMethod.prototype.atWaitCompositeUpdate = function() {
      return this.consumeWhenAvailable("input", (function(_this) {
        return function(input) {
          var ref, ref1, ref2, ref3, result;
          if (input.type === "keyboard") {
            if (_this.ignoreKeyEvent || input.event.which === 229) {
              _this.setState("waitCompositeUpdate");
              return;
            }
            result = _this.handleKeyboard(input.event);
            if (result.defaultPrevented) {
              _this.reform();
              return;
            } else {
              _this.setState("waitCompositeUpdate");
              return;
            }
          }
          if (input.type === "input") {
            if (!_this.sync()) {
              return;
            }
            _this.setState("waitCompositeUpdate");
            return;
          }
          if (input.type !== "ime") {
            _this.reform();
            return;
          }
          if (input.action === "update") {
            _this.data.suggestedContent = input.event.data;
            _this.setState("waitCompositeUpdate");
            return;
          }
          if (input.action === "start") {
            if ((ref = _this.buffer.context) != null) {
              ref.history.disableCheckPoint();
            }
            _this.data.suggestedContent = "";
            _this.setState("waitCompositeUpdate");
            return;
          }
          if (input.action === "end") {
            if ((ref1 = _this.buffer.context) != null) {
              ref1.history.enableCheckPoint();
            }
            if ((ref2 = _this.buffer.context) != null) {
              ref2.history.addCheckPoint();
            }
            _this.data.onceEnd = true;
            _this.data.suggestedContent = "";
            if ((ref3 = _this.buffer.imeHint) != null) {
              ref3.clear();
            }
            _this.setState("waitCompositeUpdate");
            return;
          }
          return _this.reform();
        };
      })(this));
    };

    return GeneralInputMethod;

  })(Leaf.States);

  KeyEventHandler = (function(superClass) {
    extend(KeyEventHandler, superClass);

    function KeyEventHandler() {
      return KeyEventHandler.__super__.constructor.apply(this, arguments);
    }

    KeyEventHandler.prototype.handleKeyboard = function(event) {
      var e, error, k, ke, ref;
      try {
        this.emit("key", ke = new KeyEvent(event));
      } catch (error) {
        e = error;
        Logger.error(e);
      }
      k = Leaf.Key;
      if ((ref = event.which) === k.up || ref === k.down || ref === k.home || ref === k.end || ref === k.left || ref === k.right) {
        event.preventDefault();
      }
      return ke;
    };

    return KeyEventHandler;

  })(Trait);

  FocusableTrait = (function(superClass) {
    extend(FocusableTrait, superClass);

    function FocusableTrait() {
      return FocusableTrait.__super__.constructor.apply(this, arguments);
    }

    FocusableTrait.prototype.ensureFocusState = function(option) {
      if (option == null) {
        option = {};
      }
      if (this.isActive) {
        this.isFocusing = true;
      }
      return this._applyFocusToElement();
    };

    FocusableTrait.prototype.focus = function() {
      this.isFocusing = true;
      return this._applyFocusToElement();
    };

    FocusableTrait.prototype.blur = function() {
      this.isFocusing = false;
      return this._applyFocusToElement();
    };

    FocusableTrait.prototype._applyFocusToElement = function() {
      if (this.editor.platform.isMobile() && this.isFocusing) {
        this.input.blur();
        this.input.focus();
        this.reform();
        return;
      }
      if (this.input !== window.document.activeElement && this.isFocusing) {
        this.input.focus();
        return this.reform();
      } else if (this.input === window.document.activeElement && !this.isFocusing) {
        this.input.blur();
        return this.reform();
      }
    };

    return FocusableTrait;

  })(Trait);

  ActivableTrait = (function(superClass) {
    extend(ActivableTrait, superClass);

    function ActivableTrait() {
      return ActivableTrait.__super__.constructor.apply(this, arguments);
    }

    ActivableTrait.prototype.isActive = false;

    ActivableTrait.prototype.activate = function(option) {
      if (option == null) {
        option = {};
      }
      if (this.isActive) {
        return;
      }
      if (option.forceFocus || !this.editor.platform.isMobile()) {
        this.focus();
      }
      if (this.editor.platform.isMobile()) {
        window.addEventListener("resize", this.checkResize);
      }
      this.reset();
      this.setState("init");
      this.isActive = true;
      return this.reform();
    };

    ActivableTrait.prototype.deactivate = function() {
      if (!this.isActive) {
        return;
      }
      this.blur();
      if (this.editor.platform.isMobile()) {
        window.removeEventListener("resize", this.checkResize);
      }
      this.isActive = false;
      return this.reform();
    };

    return ActivableTrait;

  })(Trait);

  ContentEditableHacker = (function() {
    function ContentEditableHacker(inputMethod) {
      this.inputMethod = inputMethod;
    }

    ContentEditableHacker.prototype.setElement = function(el) {
      this.detach(this.el);
      this.attach(el);
      return this.el = el;
    };

    ContentEditableHacker.prototype.detach = function(el) {
      if (!el) {
        return;
      }
      el.removeEventListener("keydown");
      return el.removeEventListener("input");
    };

    ContentEditableHacker.prototype.attach = function(el) {
      el.addEventListener("keydown", function(e) {
        e.preventDefault();
        return e.stopImmediatePropagation();
      });
      el.addEventListener("compositionstart", function(e) {
        e.preventDefault();
        return e.stopImmediatePropagation();
      });
      return el.addEventListener("input", function(e) {
        e.preventDefault();
        return e.stopImmediatePropagation();
      });
    };

    return ContentEditableHacker;

  })();

  BrowserDefaultKeyBehaviorPreventor = (function() {
    BrowserDefaultKeyBehaviorPreventor.preventing = false;

    function BrowserDefaultKeyBehaviorPreventor() {
      if (BrowserDefaultKeyBehaviorPreventor.preventing) {
        return;
      }
      window.addEventListener("keydown", function(e) {
        if (e.altKey && !e.ctrlKey && e.which !== Leaf.Key.d) {
          return e.preventDefault();
        } else if (e.which === Leaf.Key.tab) {
          return e.preventDefault();
        }
      });
      BrowserDefaultKeyBehaviorPreventor.preventing = true;
    }

    return BrowserDefaultKeyBehaviorPreventor;

  })();

  module.exports = InputMethodMaster;

}).call(this);
