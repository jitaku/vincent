// Generated by CoffeeScript 1.10.0
(function() {
  var COMComposePolicy, COMComposer, COMContainer, COMPath, COMRichText, COMRichTextAnchor, COMRune, COMSpell, COMText, COMTravelPolicy, Errors, Operation,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  COMContainer = require("./container");

  COMPath = require("./path");

  COMRune = require("./rune");

  COMSpell = require("./spell");

  COMText = require("./text");

  Operation = require("./operation");

  COMTravelPolicy = require("./travelPolicy");

  COMComposePolicy = require("./composePolicy");

  COMComposer = require("./composer");

  Errors = require("./errors");

  COMRichTextAnchor = null;

  COMRichText = (function(superClass) {
    extend(COMRichText, superClass);

    COMRichText.packs = [];

    COMRichText.prototype.type = "RichText";

    COMRichText.prototype.mime = "text/com-rich-text";

    COMRichText.prototype.isSingleLine = false;

    function COMRichText(context, option1) {
      var i, item, j, len, len1, ref, ref1, ref2;
      this.context = context;
      this.option = option1 != null ? option1 : {};
      if (this.appearance == null) {
        this.appearance = {
          tagName: "span",
          classList: ["com", "com-rich-text"]
        };
      }
      this.decorationMaintainers = [];
      if (this.availableSpells == null) {
        this.availableSpells = [];
      }
      this.disableTextHolder = false;
      ref = this.context.namespace.decorations;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        this.decorationMaintainers.push(item);
      }
      ref1 = this.context.namespace.spells;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        item = ref1[j];
        this.availableSpells.push(item);
      }
      if (this.privateSpells) {
        (ref2 = this.availableSpells).push.apply(ref2, this.privateSpells);
      }
      this.placeholder = this.option.placeholder;
      this.__defineGetter__("contentString", (function(_this) {
        return function() {
          if (_this._contentString !== null) {
            return _this._contentString;
          }
          _this._contentString = (_this.children.map(function(item) {
            return item.contentString || "";
          })).join("");
          return _this._contentString;
        };
      })(this));
      this.__defineSetter__("contentString", (function(_this) {
        return function(cs) {
          _this.empty();
          _this.append(new COMText(_this.context, {
            contentString: cs,
            passive: true
          }));
          return _this.pend();
        };
      })(this));
      this.__defineGetter__("length", (function(_this) {
        return function() {
          if (_this._length >= 0) {
            return _this._length;
          }
          return _this.reflow();
        };
      })(this));
      COMRichText.__super__.constructor.call(this, this.context, this.option);
      if (this.option.contentString || this.children.length === 0) {
        this.contentString = this.option.contentString || "";
      }
      this.__defineGetter__("holder", function() {
        if (!this.cache) {
          return null;
        }
        if (!this.cache.holder) {
          this.cache.holder = document.createElement("span");
          this.cache.holder.textNode = document.createTextNode("");
          this.cache.holder.appendChild(this.cache.holder.textNode);
          this.cache.holder.classList.add("com-holder");
          this.cache.holder.com = this;
        }
        return this.cache.holder;
      });
      this.travelPolicy = new COMTravelPolicy(this).behave({
        write: "enable",
        forwardChar: "enable",
        backwardChar: "enable",
        deleteChar: "enable",
        forwardBypassed: "handover",
        backwardBypassed: "handover",
        deleteBypassed: "handover",
        head: "enable",
        tail: "enable",
        startOfLine: "boundary",
        endOfLine: "handover",
        tailBoundary: "pass"
      });
      this.layout = "block";
      this.composePolicy = new COMComposePolicy(this).behave({
        newlineSplitHead: true,
        newlineSplitTail: true,
        tailingNewline: false,
        headingNewline: false,
        borrow: false,
        lend: true
      });
      if (!COMRichTextAnchor) {
        COMRichTextAnchor = require("./richTextAnchor");
      }
      this.anchor = new COMRichTextAnchor(this);
    }

    COMRichText.prototype.cutOut = function(offset) {
      var children, i, index, item, j, len, len1, ref, result, target;
      this.reflow();
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.endOffset >= offset) {
          target = item;
          break;
        }
      }
      if (!target) {
        return null;
      }
      if (item.sortOf("Rune") || item.endOffset === offset) {
        offset = item.endOffset;
      } else {
        item.splitInPlace(offset - item.startOffset);
      }
      index = this.indexOf(item);
      children = this.children.slice(index + 1);
      this.removeChildren(children);
      result = this.context.createElement("RichText", {});
      for (j = 0, len1 = children.length; j < len1; j++) {
        item = children[j];
        result.append(item);
      }
      return result;
    };

    COMRichText.prototype.pend = function() {
      this._contentString = null;
      this._length = -1;
      return COMRichText.__super__.pend.call(this);
    };

    COMRichText.prototype.getRunes = function() {
      return this.children.filter(function(item) {
        return item.sortOf("Rune");
      });
    };

    COMRichText.prototype.isStartOfChar = function(char) {
      var first;
      first = this.children[0];
      if (!first || !first.sortOf("Text")) {
        return false;
      }
      return first.contentString.slice(0, 1) === char;
    };

    COMRichText.prototype.isEndOfChar = function(char) {
      var last;
      last = this.last();
      if (!last || !last.sortOf("Text")) {
        return false;
      }
      return last.contentString.slice(-1) === char;
    };

    COMRichText.prototype.isEmpty = function() {
      return this.children.length === 0 || (this.children.length === 1 && this.children[0].isEmpty()) && true;
    };

    COMRichText.prototype.append = function(item) {
      if (!(item instanceof COMText) && !(item instanceof COMRune)) {
        throw new Errors.LogicError("COMRichText only support COMSpell or COMText as child");
      }
      return COMRichText.__super__.append.call(this, item);
    };

    COMRichText.prototype.reflow = function() {
      var i, index, item, len, offset, ref;
      offset = 0;
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        item.startOffset = offset;
        offset += item.length;
        item.endOffset = offset;
      }
      this._length = offset;
      return offset;
    };

    COMRichText.prototype.borrowFirstLine = function() {
      var cs, index;
      if (!this.composePolicy.lend) {
        return "";
      }
      cs = this.contentString;
      index = cs.indexOf("\n");
      if (index < 0) {
        return "";
      }
      this.removeText(0, index + 1);
      return cs.slice(0, index + 1);
    };

    COMRichText.prototype.borrowHeadingNewline = function() {
      if (!this.composePolicy.lend) {
        return false;
      }
      if (this.contentString[0] === "\n") {
        this.removeText(0, 1);
        return true;
      }
      return false;
    };

    COMRichText.prototype.borrowTailingNewline = function() {
      if (!this.composePolicy.lend) {
        return false;
      }
      if (this.contentString.slice(-1) === "\n") {
        this.removeText(this.contentString.length - 1);
        return true;
      }
      return false;
    };

    COMRichText.prototype.render = function(rc) {
      var child, ctail, el, hasCorrectParent, i, index, item, j, k, l, len, len1, len2, len3, len4, len5, len6, m, modified, n, neAnchor, nes, nesShould, next, o, p, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, removes, solved;
      solved = false;
      modified = this.beforeMark("hasDetachedChild") || this.beforeMark("hasAttachedChild");
      next = this.next();
      if (this.children.length === 0 || (this.children.length === 1 && this.children[0].length === 0) || this.forceHolder) {
        this.holder.textNode.textContent = this.placeholder || "";
        if (this.trigger && !this.holder.withClick) {
          this.holder.withClick = true;
          this.holder.onclick = (function(_this) {
            return function() {
              return _this.context.transact(function() {
                return typeof _this.trigger === "function" ? _this.trigger({
                  via: "holder"
                }) : void 0;
              });
            };
          })(this);
        }
      } else {
        console.error(this.holder, this, this.children, this.cache, this.rc);
        this.holder.textNode.textContent = "";
      }
      if (this.layout === "block") {
        ref = this.children;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          item = ref[index];
          item.blockTail = false;
          if (index === this.children.length - 1 && item.sortOf("Text") && next) {
            item.blockTail = true;
          }
        }
      }
      if (!this.beforeMark("hasAttachedChild")) {
        ref1 = this.children;
        for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
          item = ref1[index];
          if (item.richTextIndex !== index) {
            modified = true;
            item.richTextIndex = index;
          }
        }
      }
      if (this.beforeMark("hasDetachedChild") && this.domContainer) {
        removes = [];
        ref2 = this.domContainer.children;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          item = ref2[k];
          if ((ref3 = item.com, indexOf.call(this.children, ref3) < 0) && item !== this.holder) {
            removes.push(item);
          }
        }
        for (l = 0, len3 = removes.length; l < len3; l++) {
          item = removes[l];
          this.domContainer.removeChild(item);
        }
      }
      if (modified && this.domContainer) {
        ref4 = this.children;
        for (m = 0, len4 = ref4.length; m < len4; m++) {
          child = ref4[m];
          if (child.dirty) {
            child.render(rc);
            child.afterRender();
          }
        }
        ref5 = this.children;
        for (index = n = ref5.length - 1; n >= 0; index = n += -1) {
          child = ref5[index];
          next = this.children[index + 1];
          if (!next) {
            if (!child.elAfter) {
              nes = child.el.nextElementSibling;
            } else {
              nes = child.elAfter.nextElementSibling;
            }
            hasCorrectParent = true;
            ref6 = [child.el, child.elBefore, child.elAfter];
            for (o = 0, len5 = ref6.length; o < len5; o++) {
              el = ref6[o];
              if (!el) {
                continue;
              }
              if (el && el.parentElement !== this.domContainer) {
                hasCorrectParent = false;
                break;
              }
            }
            if (!hasCorrectParent || (nes && nes !== this.holder)) {
              if (child.elBefore) {
                this.domContainer.appendChild(child.elBefore);
              }
              this.domContainer.appendChild(child.el);
              if (child.elAfter) {
                this.domContainer.appendChild(child.elAfter);
              }
            }
            continue;
          }
          if (next.elBefore) {
            neAnchor = next.elBefore;
            nesShould = next.elBefore.previousElementSibling;
          } else {
            neAnchor = next.el;
            nesShould = next.el.previousElementSibling;
          }
          hasCorrectParent = true;
          ref7 = [child.el, child.elBefore, child.elAfter];
          for (p = 0, len6 = ref7.length; p < len6; p++) {
            el = ref7[p];
            if (!el) {
              continue;
            }
            if (el && el.parentElement !== this.domContainer) {
              hasCorrectParent = false;
              break;
            }
          }
          if (child.elAfter) {
            ctail = child.elAfter;
          } else {
            ctail = child.el;
          }
          if (!hasCorrectParent || nesShould !== ctail) {
            if (child.elBefore) {
              this.domContainer.insertBefore(child.elBefore, neAnchor);
            }
            if (child.el) {
              this.domContainer.insertBefore(child.el, neAnchor);
            }
            if (child.elAfter) {
              this.domContainer.insertBefore(child.elAfter, neAnchor);
            }
          } else if (child.elAfter) {
            Logger.error("cel pass");
          }
        }
        solved = true;
      }
      COMRichText.__super__.render.call(this, rc, {
        recursive: true,
        selfless: !modified || solved
      });
      if (this.holder.parentElement !== this.domContainer || this.holder.nextSibling) {
        return this.domContainer.appendChild(this.holder);
      }
    };

    COMRichText.prototype.compose = function() {
      var casted, changed, hasRunes, i, index, item, len, normalized, ref, retained;
      if (COMRichText.__super__.compose.call(this)) {
        return true;
      }
      retained = this.retainSpells();
      normalized = this.normalizeTexts();
      casted = this.castSpells();
      normalized = this.normalizeTexts();
      hasRunes = this.recoverRunes();
      this.computeDecoration();
      if (!this.disableTextHolder) {
        ref = this.children;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          item = ref[index];
          if (index !== this.children.length - 1) {
            item.withHolder = false;
          } else {
            item.withHolder = true;
          }
        }
      }
      changed = retained || normalized || casted;
      if (changed) {
        return true;
      }
      if (typeof this.acknowledge === "function") {
        this.acknowledge();
      }
      return false;
    };

    COMRichText.prototype.recoverRunes = function() {
      var after, children, i, item, len, once, reg, result, rune;
      children = this.children.slice();
      reg = new RegExp(COMRune.RunePlaceBegin + "([0-9]+)" + COMRune.RunePlaceEnd);
      for (i = 0, len = children.length; i < len; i++) {
        item = children[i];
        if (item.type !== "Text") {
          continue;
        }
        while (true) {
          result = item.contentString.match(reg);
          if (!result) {
            break;
          }
          if (this.mime !== "text/com-rich-text") {
            item.removeText(result.index, result[0].length);
            once = true;
            continue;
          }
          rune = this.context.runeCache.cloneByCid(result[1]);
          if (!rune) {
            break;
          }
          item.removeText(result.index, result[0].length);
          after = item.splitInPlace(result.index);
          if (result.index === 0) {
            item.before(rune);
          } else {
            item.after(rune);
          }
          if (!after) {
            break;
          }
          item = after;
          once = true;
        }
      }
      return once || false;
    };

    COMRichText.prototype.retainSpells = function() {
      var i, item, len, ref, result;
      result = false;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item instanceof COMSpell) {
          result = item.compose() || result;
        }
      }
      return result;
    };

    COMRichText.prototype.castSpells = function() {
      var Spell, after, before, candidate, content, cs, i, index, item, j, k, l, len, len1, len2, match, nexts, offsetStart, parts, ref, ref1, result, results, spell, spells, start, text, texts;
      this.reflow();
      cs = this.contentString;
      texts = [];
      start = 0;
      text = "";
      ref = this.children.slice(0);
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.sortOf("Text")) {
          if (!text) {
            start = item.startOffset;
          }
          text += item.contentString;
        } else {
          texts.push({
            content: text,
            start: start
          });
          text = "";
        }
      }
      if (text) {
        texts.push({
          content: text,
          start: start
        });
      }
      results = [];
      ref1 = this.availableSpells;
      for (j = ref1.length - 1; j >= 0; j += -1) {
        Spell = ref1[j];
        nexts = [];
        offsetStart = 0;
        for (index = k = 0, len1 = texts.length; k < len1; index = ++k) {
          text = texts[index];
          start = text.start;
          candidate = text.content;
          parts = [];
          while (candidate && (match = Spell.prototype.test(candidate, start, cs))) {
            if (match.start === match.end) {
              throw new Error("parse empty spell content");
            }
            before = candidate.slice(0, match.start);
            content = candidate.slice(match.start, match.end);
            after = candidate.slice(match.end);
            if (before) {
              parts.push({
                start: start,
                content: before
              });
            }
            start += before.length;
            results.push({
              Spell: Spell,
              start: start,
              content: content
            });
            start += content.length;
            candidate = after;
          }
          if (candidate) {
            parts.push({
              start: start,
              content: candidate
            });
          }
          nexts.push.apply(nexts, parts);
        }
        texts = nexts;
      }
      results.sort(function(a, b) {
        return a.start - b.start;
      });
      spells = this.children.slice(0).filter(function(item) {
        return item.sortOf("Spell");
      });
      if (results.length !== spells.length) {
        this.castAllSpells(results);
        return true;
      }
      for (index = l = 0, len2 = results.length; l < len2; index = ++l) {
        result = results[index];
        spell = spells[index];
        if (result.start === spell.startOffset && result.content.length === spell.length) {
          continue;
        }
        this.castAllSpells(results);
        return true;
      }
      return false;
    };

    COMRichText.prototype.castAllSpells = function(spells) {
      var end, endOffset, i, index, info, len, next, results1, spell, startOffset, target;
      if (spells.length === 0) {
        return;
      }
      this.reflow();
      results1 = [];
      for (i = 0, len = spells.length; i < len; i++) {
        info = spells[i];
        index = this.getChildTextIndexByOffset(info.start);
        target = this.children[index];
        end = info.start + info.content.length;
        while (end > target.endOffset) {
          next = this.children[index + 1];
          if (!next) {
            break;
          }
          target.mergeInPlace(next);
          target.endOffset += next.length;
        }
        spell = new info.Spell(this.context, {});
        startOffset = info.start - target.startOffset;
        endOffset = startOffset + info.content.length;
        results1.push(spell.castToText(target, startOffset, endOffset));
      }
      return results1;
    };

    COMRichText.prototype.castSpellsOld = function() {
      var Spell, contentString, i, j, len, ref, result, text, texts;
      contentString = this.contentString;
      result = null;
      ref = this.availableSpells;
      for (i = ref.length - 1; i >= 0; i += -1) {
        Spell = ref[i];
        texts = this.children.slice().filter(function(item) {
          return item.type === "Text";
        });
        for (j = 0, len = texts.length; j < len; j++) {
          text = texts[j];
          result = this.castSpellOn(Spell, text, contentString) || result;
          if (result) {
            Logger.error("cast spell on", [text.toString()], Spell, texts.length);
          }
        }
      }
      return result;
    };

    COMRichText.prototype.castSpellOnOld = function(Spell, text, contentString) {
      var last, result, spell, success;
      contentString = contentString || this.contentString;
      while (text && (result = Spell.prototype.test(text.contentString, text.startOffset, contentString))) {
        spell = new Spell(this.context, {
          match: result.match
        });
        last = spell.castToText(text, result.start, result.end);
        text = last;
        success = true;
      }
      return success;
    };

    COMRichText.prototype.normalizeTexts = function() {
      var canMerge, hasMerge, i, index, item, len, prev, retain, texts;
      if (this.noAutoMerge) {
        return false;
      }
      canMerge = function(a, b) {
        return a.type === "Text" && b.type === "Text";
      };
      if (this.children.length === 1) {
        return;
      }
      texts = this.children.slice();
      retain = false;
      prev = null;
      for (index = i = 0, len = texts.length; i < len; index = ++i) {
        item = texts[index];
        if (item.length === 0 && index !== texts.length - 1) {
          hasMerge = true;
          item.remove();
          continue;
        }
        if (!prev) {
          prev = item;
          continue;
        }
        if (canMerge(prev, item)) {
          prev.mergeInPlace(item);
          hasMerge = true;
        } else {
          prev = item;
        }
      }
      return hasMerge || false;
    };

    COMRichText.prototype.getBreakString = function(count, breakChar) {
      var pattern, result;
      if (breakChar == null) {
        breakChar = "\uE1F8";
      }
      pattern = breakChar;
      if (count < 1) {
        return "";
      }
      result = "";
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    };

    COMRichText.prototype.getDecorationString = function() {
      var behavior, i, item, len, ref, str;
      str = "";
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        behavior = item.decorationPolicy.behavior;
        if (behavior === "break") {
          str += this.getBreakString(item.length);
        } else if (behavior === "singular") {
          str += this.getBreakString(item.length, "X");
        } else {
          str += item.contentString || "";
        }
      }
      return str;
    };

    COMRichText.prototype.computeDecoration = function() {
      var backup, content, counter, dc, dec, decIndex, decorations, disIndex, disItem, disableRegions, fpdec, i, index, item, j, k, l, len, len1, len2, len3, maintainer, next, nextRound, ref, results1, targets, text, valid, validDecs;
      content = this.getDecorationString();
      decorations = [];
      ref = this.decorationMaintainers;
      for (i = 0, len = ref.length; i < len; i++) {
        maintainer = ref[i];
        decorations.push.apply(decorations, maintainer.compute(content));
      }
      decorations.sort(function(a, b) {
        var MAX_TEXTCOUNT;
        MAX_TEXTCOUNT = 1000001;
        return a.start - b.start + (a.end - b.end) / MAX_TEXTCOUNT;
      });
      valid = [];
      this.reflow();
      disableRegions = [];
      decIndex = 0;
      validDecs = decorations.slice();
      for (disIndex = j = 0, len1 = disableRegions.length; j < len1; disIndex = ++j) {
        disItem = disableRegions[disIndex];
        while (true) {
          dec = validDecs[decIndex];
          if (!dec) {
            break;
          }
          if (dec.start > disItem.end) {
            decIndex = decIndex;
            break;
          }
          if (dec.end < disItem.start) {
            decIndex += 1;
            continue;
          }
          if (dec.start <= disItem.start && dec.end > disItem.start) {
            if (disItem.allowWrapping) {
              decIndex += 1;
            } else {
              validDecs.splice(decIndex, 1);
            }
            continue;
          }
          if (dec.start >= disItem.start && dec.end <= disItem.end) {
            validDecs.splice(decIndex, 1);
            continue;
          }
          if (dec.start >= disItem.start && dec.start < disItem.end) {
            validDecs.splice(decIndex, 1);
            continue;
          }
          if (dec.start <= disItem.start && dec.end >= disItem.end) {
            validDecs.splice(decIndex, 1);
            continue;
          }
          break;
        }
      }
      decorations = validDecs;
      targets = this.children.slice();
      this.reflow();
      targets.forEach(function(item) {
        return item._decs = [];
      });
      backup = targets.slice();
      counter = 0;
      for (k = 0, len2 = decorations.length; k < len2; k++) {
        dec = decorations[k];
        nextRound = [];
        index = 0;
        while (true) {
          if (index >= targets.length) {
            break;
          }
          text = targets[index];
          if (text.startOffset >= dec.end) {
            break;
          }
          if (text.endOffset <= dec.start) {
            targets.splice(index, 1);
            continue;
          }
          if (dec.end <= text.endOffset) {
            text._decs.push(dec.shift(-text.startOffset));
            if (dec.start < 0) {
              Logger.error("INVALID DEC", dec, text.startOffset, text.contentString);
            }
          } else {
            next = dec.split(text.endOffset);
            text._decs.push(dec.shift(-text.startOffset));
            if (dec.start < 0) {
              Logger.error("INVALID DEC AFTER", dec);
            }
            dec = next;
          }
          index += 1;
        }
      }
      fpdec = function(decs) {
        return (decs.map(function(item) {
          return "" + item.mid + ":" + item.start + "~" + item.end;
        })).join("|");
      };
      dc = 0;
      results1 = [];
      for (l = 0, len3 = backup.length; l < len3; l++) {
        item = backup[l];
        if (item.ignoreDecoration && !item.allowWrapping) {
          item.setDecorations();
          continue;
        }
        if (item._decs.length !== item.decorations.length) {
          if (typeof item.setDecorations === "function") {
            item.setDecorations(item._decs);
          }
          dc += 1;
          continue;
        }
        results1.push((function() {
          var len4, m, ref1, results2;
          ref1 = item._decs;
          results2 = [];
          for (index = m = 0, len4 = ref1.length; m < len4; index = ++m) {
            dec = ref1[index];
            if (dec.equal(item.decorations[index])) {
              continue;
            } else {
              if (typeof item.setDecorations === "function") {
                item.setDecorations(item._decs);
              }
              dc += 1;
              break;
            }
          }
          return results2;
        })());
      }
      return results1;
    };

    COMRichText.prototype.insertText = function(start, value) {
      var anchor, i, inside, len, ref;
      if (!this._insertText(start, value)) {
        return false;
      }
      ref = this.anchors;
      for (i = 0, len = ref.length; i < len; i++) {
        anchor = ref[i];
        if (anchor.index >= start) {
          inside = anchor.inside;
          anchor.index += value.length;
          anchor.inside = inside;
        }
      }
      return true;
    };

    COMRichText.prototype._insertText = function(start, value) {
      var i, index, last, len, next, ref, text;
      this.reflow();
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        text = ref[index];
        last = text;
        next = this.children[index + 1];
        if (start >= text.startOffset && start < text.endOffset) {
          if (text.insertText(start - text.startOffset, value)) {
            this.pend();
            return true;
          } else {
            return false;
          }
        } else if (start === text.endOffset && text.sortOf("Text") && next && next.sortOf("Rune")) {
          if (text.insertText(start - text.startOffset, value)) {
            this.pend();
            return true;
          } else {
            return false;
          }
        } else if (start >= text.startOffset && start === text.endOffset && text instanceof COMSpell) {
          if (text.insertText(start - text.startOffset, value)) {
            this.pend();
            return true;
          } else {
            return false;
          }
        }
      }
      if (last && start === last.endOffset) {
        if (last.insertText(start - last.startOffset, value)) {
          this.pend();
          return true;
        }
      } else if (start === 0) {
        if (this.append(new COMText(this.context, {
          contentString: value
        }))) {
          this.pend();
          return true;
        }
      }
      return false;
    };

    COMRichText.prototype.insertRune = function(start, rune) {
      var anchor, i, inside, len, ref;
      if (!this._insertRune(start, rune)) {
        return false;
      }
      ref = this.anchors;
      for (i = 0, len = ref.length; i < len; i++) {
        anchor = ref[i];
        if (anchor.index === start) {
          anchor.index += rune.length;
        } else if (anchor.index >= start) {
          inside = anchor.inside;
          anchor.index += rune.length;
          anchor.inside = inside;
        }
      }
      return true;
    };

    COMRichText.prototype._insertRune = function(start, rune) {
      var anchor, i, inside, j, len, len1, offset, ref, ref1, text;
      offset = 0;
      this.reflow();
      if (start === this.contentString.length) {
        this.pend();
        return this.append(rune);
      }
      if (start === 0) {
        this.pend();
        return this.insert(0, rune);
      }
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        text = ref[i];
        if (text.endOffset < start) {
          continue;
        }
        if (text.startOffset === start) {
          text.before(rune);
        } else if (text.endOffset === start) {
          text.after(rune);
        } else if (text instanceof COMText) {
          text.splitInPlace(start - text.startOffset);
          text.after(rune);
        } else {
          text.after(rune);
        }
        this.pend();
        return true;
      }
      return false;
      ref1 = this.anchors;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        anchor = ref1[j];
        inside = anchor.inside;
        if (anchor.index < start) {
          return;
        }
        if (anchor.index >= start + length) {
          anchor.index -= length;
          anchor.inside = inside;
          continue;
        }
        if (anchor.index >= start) {
          anchor.index = start;
          anchor.inside = inside;
          continue;
        }
      }
      return true;
    };

    COMRichText.prototype.removeRune = function(rune) {
      if (rune.parent !== this) {
        return false;
      }
      return this.removeText(rune.startOffset, rune.length);
    };

    COMRichText.prototype.removeText = function(start, length) {
      var action, actions, anchor, cs, end, i, index, inside, j, k, len, len1, len2, offset, ref, ref1, text, textEnd, textStart;
      cs = this.contentString;
      if (length == null) {
        length = cs.length - start;
      }
      actions = [];
      offset = start;
      end = start + length;
      if (start > cs.length || start + length > cs.length) {
        return false;
      }
      this.reflow();
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        text = ref[index];
        if (text.startOffset >= end) {
          break;
        } else if (text.endOffset <= start) {
          continue;
        }
        textStart = offset - text.startOffset;
        textEnd = end - text.startOffset;
        if (textEnd >= text.length) {
          textEnd = text.length;
          if (textStart === 0) {
            actions.push({
              remove: true,
              text: text
            });
          } else {
            actions.push({
              start: textStart,
              text: text
            });
          }
          offset = text.endOffset;
        } else {
          actions.push({
            start: textStart,
            length: textEnd - textStart,
            text: text
          });
          break;
        }
      }
      for (index = j = 0, len1 = actions.length; j < len1; index = ++j) {
        action = actions[index];
        if (action.remove) {
          action.text.remove();
        } else {
          action.text.removeText(action.start, action.length || null);
        }
        if (index === 0 && action.text.sortOf("Rune")) {
          start = action.text.startOffset;
        }
        if (index === actions.length - 1 && action.text.sortOf("Rune")) {
          end = action.text.endOffset;
        }
      }
      length = end - start;
      ref1 = this.anchors;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        anchor = ref1[k];
        inside = anchor.inside;
        if (anchor.index < start) {
          continue;
        }
        if (anchor.index >= start + length) {
          anchor.index -= length;
          anchor.inside = inside;
          continue;
        }
        if (anchor.index >= start) {
          anchor.index = start;
          anchor.inside = inside;
          continue;
        }
      }
      if (this.children.length === 0) {
        this.contentString = "";
        this.pend();
        return;
      }
      if (actions.length > 0) {
        this.pend();
        return true;
      }
      return false;
    };

    COMRichText.prototype.getOffsetByDOM = function(node, offset) {
      var i, item, len, ref, result;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.isSpell) {
          result = item != null ? typeof item.getOffsetByDOM === "function" ? item.getOffsetByDOM(node, offset) : void 0 : void 0;
          if (result) {
            result.index += item.startOffset;
            return result;
          }
        }
      }
      return null;
    };

    COMRichText.prototype.getChildTextIndexByOffset = function(offset) {
      var i, index, len, ref, text;
      this.reflow();
      if (this.last() && this.last().endOffset === offset) {
        return this.last();
      }
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        text = ref[index];
        if (text.startOffset <= offset && text.endOffset > offset) {
          return index;
        }
      }
    };

    COMRichText.prototype.getChildTextByOffset = function(offset) {
      var i, index, len, ref, text;
      this.reflow();
      if (this.last() && this.last().endOffset === offset) {
        return this.last();
      }
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        text = ref[index];
        if (text.startOffset <= offset && text.endOffset > offset) {
          return text;
        }
      }
      return null;
    };

    COMRichText.prototype.mergeContentString = function(content) {
      if (!content) {
        return true;
      }
      return this.insertText(this.length, content);
    };

    COMRichText.prototype.toContentString = function(option) {
      if (option == null) {
        option = {};
      }
      if (!option.purify) {
        return this.contentString;
      } else {
        return COMRune.purifyContentString(this.contentString, option);
      }
    };

    COMRichText.prototype.hasRune = function(handler) {
      var i, item, len, ref;
      if (handler == null) {
        handler = function() {};
      }
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.sortOf("Rune")) {
          if (handler(item)) {
            return true;
          }
        }
      }
      return false;
    };

    COMRichText.prototype.filterRunes = function(handler) {
      var i, item, len, ref, result;
      if (handler == null) {
        handler = function() {};
      }
      result = [];
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.sortOf("Rune")) {
          if (handler(item)) {
            result.push(item);
          }
        }
      }
      return result;
    };

    COMRichText.prototype.fromJSON = function(option) {
      var child, find, i, len, ref, results1;
      if (option.children) {
        this.empty();
        ref = option.children;
        results1 = [];
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (!child) {
            continue;
          }
          if (child instanceof COMText) {
            results1.push(this.append(child));
          } else if (child.type === "Text") {
            results1.push(this.append(new COMText(this.context, child)));
          } else if (child.spell === true) {
            find = this.availableSpells.some((function(_this) {
              return function(Spell) {
                if (Spell.prototype.type === child.type) {
                  _this.append(new Spell(_this.context, child));
                  return true;
                }
                return false;
              };
            })(this));
            if (!find) {
              Logger.error("RichText:fail to build spell from json for ", child);
              Logger.error("fallback into normal texts.");
              results1.push(this.append(new COMText(this.context, child)));
            } else {
              results1.push(void 0);
            }
          } else if (child.sortOf && child.sortOf("Rune")) {
            results1.push(this.append(child));
          } else if (child.type && this.context.namespace.sortOf(child.type, "Rune")) {
            results1.push(this.append(this.context.createElement(child)));
          } else {
            this.append(this.context.createElement({
              type: "UnknownRune",
              detail: child
            }));
            results1.push(Logger.error("RichText: unsupported typeof child", child, this.context));
          }
        }
        return results1;
      }
    };

    COMRichText.prototype.runeAtIndex = function(index) {
      var child;
      this.reflow();
      if (typeof index !== "number") {
        return null;
      }
      child = this.getChildTextByOffset(index);
      if (child instanceof COMRune) {
        return child;
      }
      return null;
    };

    COMRichText.prototype.isRuneAt = function(index, option) {
      var child;
      if (option == null) {
        option = {};
      }
      this.reflow();
      child = this.getChildTextByOffset(index);
      if (option.strict) {
        return child instanceof COMRune && child.startOffset === index;
      }
      return child instanceof COMRune;
    };

    COMRichText.prototype.spellAtIndex = function(index) {
      var child;
      this.reflow();
      child = this.getChildTextByOffset(index);
      if (!child) {
        return null;
      }
      if (child instanceof COMSpell) {
        return child;
      }
      return null;
    };

    COMRichText.prototype.clone = function() {
      var children, i, item, len, ref;
      children = [];
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        children.push(item.toJSON());
      }
      return this.context.createElement(this.type, {
        children: children
      });
    };

    COMRichText.prototype.slice = function(option) {
      var child, children, clone, cs, end, i, index, isPartial, item, j, last, lastCs, left, leftAnchor, leftOffset, len, len1, ll, looseComplete, pointAt, ref, ref1, ref2, ref3, right, rightAnchor, rightOffset, rr, start, target, text;
      if (option == null) {
        option = {};
      }
      if (option.left) {
        left = option.left;
      } else {
        left = {
          leftMost: true
        };
      }
      if (option.right) {
        right = option.right;
      } else {
        right = {
          rightMost: true
        };
      }
      leftAnchor = this.anchor.clone();
      leftAnchor.head();
      rightAnchor = this.anchor.clone();
      rightAnchor.tail();
      if (leftAnchor.compare(right) === "after") {
        return null;
      }
      if (rightAnchor.compare(left) === "before") {
        return null;
      }
      if (((ref = leftAnchor.compare(left)) === "after" || ref === "identical") && ((ref1 = rightAnchor.compare(right)) === "before" || ref1 === "identical")) {
        return this.clone();
      }
      children = [];
      this.reflow();
      ll = leftAnchor.compare(left);
      rr = rightAnchor.compare(right);
      if (ll === "before") {
        if (left.node === leftAnchor.node) {
          leftAnchor.fromJSON(left.toJSON());
        } else {
          target = left.node;
          while (target && (target !== leftAnchor.node)) {
            pointAt = target;
            target = target.parent;
          }
          if (!pointAt) {
            throw new Errors.LogicError("since leftAnchor is before leftEdge and rightAnchor is after rightEdge, leftAnchor and leftEdge should have same ancester");
          }
          leftAnchor.pointAt(pointAt);
        }
      }
      pointAt = null;
      if (rr === "after") {
        if (right.node === rightAnchor.node) {
          rightAnchor.fromJSON(right.toJSON());
        } else {
          target = right.node;
          while (target && (target !== rightAnchor.node)) {
            pointAt = target;
            target = target.parent;
          }
          if (!pointAt) {
            throw new Errors.LogicError("since rightAnchor is before rightEdge and rightAnchor is after rightEdge, rightAnchor and rightEdge should have same ancester");
          }
          rightAnchor.pointAt(pointAt);
        }
      }
      if (leftAnchor.index === 0 && rightAnchor.index === this.contentString.length) {
        return this.clone();
      }
      ref2 = this.children;
      for (i = 0, len = ref2.length; i < len; i++) {
        item = ref2[i];
        if (item.endOffset <= leftAnchor.index) {
          continue;
        }
        if (item.startOffset >= rightAnchor.index && !rightAnchor.inside) {
          break;
        }
        if (item.sortOf("Rune")) {
          child = item.slice(option);
          if (child) {
            children.push(child);
          }
          continue;
        }
        leftOffset = Math.max(item.startOffset, leftAnchor.index);
        rightOffset = Math.min(item.endOffset, rightAnchor.index);
        if (rightOffset <= leftOffset) {
          continue;
        }
        start = leftOffset - item.startOffset;
        end = rightOffset - item.startOffset;
        cs = item.contentString.slice(start, end);
        text = new COMText(this.context, {
          contentString: cs
        });
        if (leftOffset !== item.startOffset || rightOffset !== item.endOffset && option.selection) {
          text.isPartial = true;
        }
        children.push(text);
      }
      isPartial = false;
      if (children.length !== this.children.length) {
        isPartial = true;
      }
      clone = this.context.createElement(this.type);
      clone.empty();
      last = this.last();
      lastCs = last.contentString;
      looseComplete = false;
      for (index = j = 0, len1 = children.length; j < len1; index = ++j) {
        item = children[index];
        if (item.isPartial) {
          if (index === this.children.length - 1 && (lastCs != null ? lastCs.length : void 0) - 1 === ((ref3 = item.contentString) != null ? ref3.length : void 0) && (lastCs != null ? lastCs[(lastCs != null ? lastCs.length : void 0) - 1] : void 0) === "\n") {
            isPartial = true;
            looseComplete = true;
          } else {
            isPartial = true;
          }
        }
        clone.append(item);
      }
      clone.isPartial = this.isPartial || isPartial;
      clone.looseComplete = looseComplete;
      return clone;
    };

    COMRichText.prototype.toJSON = function() {
      var json;
      json = COMRichText.__super__.toJSON.call(this);
      delete json.contentString;
      return json;
    };

    return COMRichText;

  })(COMContainer);

  module.exports = COMRichText;

}).call(this);
