// Generated by CoffeeScript 1.10.0
(function() {
  var COMDecorationPolicy, COMNode, COMText, COMVisualPosition, Decoration, InsertTextOperation, Operation, RemoveTextOperation,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMNode = require("./node");

  COMVisualPosition = require("./visualPosition");

  COMDecorationPolicy = require("./decorationPolicy");

  Decoration = require("./decoration");

  Operation = require("./operation");

  COMText = (function(superClass) {
    extend(COMText, superClass);

    COMText.prototype.type = "Text";

    COMText.prototype.toString = function() {
      return this.contentString;
    };

    COMText.prototype.isEmpty = function() {
      return this.contentString.length === 0;
    };

    COMText.prototype.toHumanString = function() {
      return this.toString();
    };

    function COMText(context, data) {
      var ref;
      this.context = context;
      this.data = data != null ? data : {};
      this.skipDirtyCheck = true;
      this.contentString = ((ref = this.data.contentString) != null ? typeof ref.toString === "function" ? ref.toString() : void 0 : void 0) || "";
      this.decorationPolicy = new COMDecorationPolicy(this).behave({
        behavior: "default"
      });
      this.decorationMaintainers = [];
      this.decorations = [];
      this.editIndex = 0;
      this.__defineGetter__("holder", function() {
        if (!this.cache) {
          return null;
        }
        if (!this.cache.holder) {
          this.cache.holder = document.createElement("span");
          this.cache.holder.innerHTML = " ";
          this.cache.holder.classList.add("com-text-holder");
        }
        return this.cache.holder;
      });
      this.__defineGetter__("partials", function() {
        return this.cache.partial || [];
      });
      this.__defineSetter__("partials", function(value) {
        return this.cache.partial = value;
      });
      if (this.appearance == null) {
        this.appearance = {
          tagName: "span",
          classList: ["com", "com-text"]
        };
      }
      this.__defineGetter__("withHolder", (function(_this) {
        return function() {
          return _this._withHolder;
        };
      })(this));
      this.__defineSetter__("withHolder", (function(_this) {
        return function(v) {
          if (v !== _this._withHolder) {
            _this.dirty = true;
          }
          _this._withHolder = v;
          return _this._withHolder;
        };
      })(this));
      this.withHolder = this.data.withHolder;
      COMText.__super__.constructor.call(this, this.context);
      this.__defineGetter__("length", function() {
        return this.contentString.length;
      });
    }

    COMText.prototype.mergeInPlace = function(target) {
      target.remove();
      this.insertText(this.contentString.length, target.contentString);
      return true;
    };

    COMText.prototype.splitInPlace = function(index, option) {
      var next;
      if (option == null) {
        option = {};
      }
      if (index >= this.contentString.length) {
        return null;
      }
      if (index === 0) {
        return null;
      }
      next = this.contentString.slice(index);
      this.removeText(index);
      next = new COMText(this.context, {
        contentString: next
      });
      this.after(next);
      return next;
    };

    COMText.prototype.render = function(rc) {
      var container, content, dec, frag, i, index, j, len, len1, partial, property, ref, ref1, ref2, ref3, secret, secretChar, str, value;
      COMText.__super__.render.call(this, rc, {
        force: true
      });
      this.computePartials();
      frag = document.createDocumentFragment();
      secret = this.secret || this.parent.secret || this.context.secret || false;
      secretChar = this.secretChar || this.parent.secretChar || this.context.secretChar || "*";
      ref = this.partials;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        partial = ref[index];
        partial.el = document.createElement("span");
        partial.el.classList.add("com-text-part");
        partial.el.com = this;
        partial.el.comText = this;
        partial.el.comPartial = partial;
        content = partial.content;
        if (index === this.partials.length - 1 && this.blockTail && content.slice(-1) === "\n") {
          if (this.keepNewlineSpace) {
            content = content.slice(0, -1) + " ";
          } else {
            content = content.slice(0, -1) + "";
          }
        }
        str = content.toString();
        if (secret) {
          str = str.replace(/./g, secretChar || "*");
        }
        partial.textNode = document.createTextNode(str);
        partial.el.appendChild(partial.textNode);
        ref1 = partial.decorations;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          dec = ref1[j];
          dec.apply(partial.el);
        }
        frag.appendChild(partial.el);
      }
      if (this.withHolder) {
        frag.appendChild(this.holder);
      }
      ref2 = this.domProperty || {};
      for (property in ref2) {
        value = ref2[property];
        if ((ref3 = this.el) != null) {
          ref3.setAttribute(property, value);
        }
      }
      container = this.specifyTextContainer();
      container.innerHTML = "";
      return container.appendChild(frag);
    };

    COMText.prototype.specifyTextContainer = function() {
      return this.el;
    };

    COMText.prototype.computePartials = function() {
      var cut, cuts, dec, decorations, i, index, item, j, k, l, len, len1, len2, len3, len4, m, nextCut, nextDec, part, partials, ref;
      partials = [];
      cuts = [0, this.contentString.length];
      ref = this.decorations;
      for (i = 0, len = ref.length; i < len; i++) {
        dec = ref[i];
        for (index = j = 0, len1 = cuts.length; j < len1; index = ++j) {
          item = cuts[index];
          if (item === dec.start) {
            break;
          }
          if (item < dec.start) {
            continue;
          } else {
            cuts.splice(index, 0, dec.start);
            break;
          }
        }
        for (index = k = 0, len2 = cuts.length; k < len2; index = ++k) {
          item = cuts[index];
          if (item === dec.end) {
            break;
          }
          if (item < dec.end) {
            continue;
          } else {
            cuts.splice(index, 0, dec.end);
          }
        }
      }
      decorations = this.decorations.slice();
      for (index = l = 0, len3 = cuts.length; l < len3; index = ++l) {
        cut = cuts[index];
        nextCut = cuts[index + 1];
        if (!nextCut) {
          break;
        }
        part = {
          decorations: [],
          content: this.contentString.slice(cut, nextCut)
        };
        nextDec = [];
        for (m = 0, len4 = decorations.length; m < len4; m++) {
          dec = decorations[m];
          if (dec.end <= cut) {
            continue;
          }
          nextDec.push(dec);
          if (dec.start >= nextCut) {
            continue;
          }
          part.decorations.push(dec);
        }
        decorations = nextDec;
        partials.push(part);
      }
      this.partials = partials;
      return this.partials;
    };

    COMText.prototype.computePartialsBad = function() {
      var c, combination, decDirty, decRef, decorations, i, index, lastCombination, lastDecRef, partStart, partials, ref;
      partials = [];
      partStart = 0;
      decorations = this.decorations.slice();
      lastCombination = "";
      lastDecRef = [];
      for (index = i = 0, ref = this.contentString.length; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
        combination = "";
        decDirty = false;
        decRef = [];
        decorations = decorations.filter(function(dec, decIndex) {
          if (index < dec.start) {
            return true;
          } else if (index >= dec.end) {
            return false;
          }
          combination += dec.mid + "-";
          return decRef.push(dec);
        });
        if (combination !== lastCombination && index > 0) {
          c = this.contentString.slice(partStart, index);
          partials.push({
            content: this.contentString.slice(partStart, index),
            decorations: lastDecRef
          });
          partStart = index;
        }
        lastCombination = combination;
        lastDecRef = decRef;
      }
      if (partStart < this.contentString.length) {
        partials.push({
          content: this.contentString.slice(partStart, this.contentString.length),
          decorations: lastDecRef || []
        });
      }
      this.partials = partials;
      return this.partials;
    };

    COMText.prototype.insertText = function(start, value) {
      var result;
      if (typeof start !== "number") {
        Logger.error("cant insert text at " + start);
        return false;
      }
      if (!value) {
        Logger.error("insert text request value provided");
        return false;
      }
      result = this.context.operate(new InsertTextOperation(this.context, this, {
        start: start,
        value: value
      }));
      if (result) {
        this.pend();
        return true;
      }
      return false;
    };

    COMText.prototype.setDecorations = function(decorations) {
      return this.context.operate(new Decoration.ChangeDecorationOperation(this.context, this, {
        decorations: decorations
      }));
    };

    COMText.prototype.removeText = function(start, length) {
      var result;
      if (typeof start !== "number") {
        return false;
      }
      if (typeof length !== "number") {
        length = this.contentString.length - start;
      }
      if (start >= this.contentString.length) {
        return false;
      }
      if (start + length > this.contentString.length) {
        return false;
      }
      result = this.context.operate(new RemoveTextOperation(this.context, this, {
        start: start,
        length: length
      }));
      if (result) {
        this.pend();
        return true;
      }
      return false;
    };

    COMText.prototype.getVisualBorder = function(index, relativeToCursor) {
      var content, holderIndex, i, last, lastChar, len, nodes, offset, part, partIndex, partialOffset, position, previous, priority, ref, target;
      if (this.dirty && !this.skipDirtyCheck) {
        Logger.error("dirty query", this.root, this, this.dirty, this.context, this.rc.id, this.cache.rev, this.rev);
        throw new Error("shouldn't get caret position when dirty");
      }
      if (relativeToCursor !== "left" && relativeToCursor !== "right") {
        relativeToCursor = "left";
      }
      offset = 0;
      target = null;
      if (relativeToCursor !== "left" && relativeToCursor !== "right") {
        return true;
      }
      if (this.blockTail && index === this.contentString.length - 1) {
        part = this.partials[this.partials.length - 1];
        content = part.content;
        lastChar = content[content.length - 1];
        if (lastChar === "\n" && this.blockTail && this.withHolder) {
          if (relativeToCursor === "right") {
            nodes = [].slice.call(this.holder.parentElement.childNodes);
            holderIndex = nodes.indexOf(this.holder);
            return new COMVisualPosition.COMVisualBorder({
              node: this.holder.parentElement,
              offset: holderIndex,
              position: "left",
              priority: this.leftCaretPriority
            });
          }
        }
      }
      ref = this.partials;
      for (partIndex = i = 0, len = ref.length; i < len; partIndex = ++i) {
        part = ref[partIndex];
        if (offset === index) {
          if (relativeToCursor === "left") {
            previous = this.partials[partIndex - 1];
            if (previous) {
              target = previous;
              partialOffset = target.content.length - 1;
              position = "right";
              break;
            } else {
              target = part;
              partialOffset = 0;
              position = "left";
              break;
            }
          } else {
            target = part;
            partialOffset = 0;
            position = "left";
            break;
          }
        }
        if (offset + part.content.length > index) {
          partialOffset = index - offset;
          target = part;
          position = "left";
          break;
        }
        offset += part.content.length;
      }
      if (offset === index && !target) {
        if (offset === 0) {
          if (this.withHolder && this.holder && this.holder.parentElement) {
            nodes = [].slice.call(this.holder.parentElement.childNodes);
            holderIndex = nodes.indexOf(this.holder);
            return new COMVisualPosition.COMVisualBorder({
              node: this.holder.parentElement,
              offset: holderIndex,
              position: "left",
              priority: this.leftCaretPriority || 0
            });
          }
        }
        target = this.partials[this.partials.length - 1];
        if (relativeToCursor === "right") {
          if (target) {
            partialOffset = target.content.length - 1;
            position = "right";
          }
        } else if (relativeToCursor === "left") {
          if (this.holder && this.holder.parentElement && this.withHolder) {
            nodes = [].slice.call(this.holder.parentElement.childNodes);
            holderIndex = nodes.indexOf(this.holder);
            return new COMVisualPosition.COMVisualBorder({
              node: this.holder.parentElement,
              offset: holderIndex,
              position: "left",
              priority: this.leftCaretPriority || 0
            });
          } else {
            last = this.partials[this.partials.length - 1];
            return new COMVisualPosition.COMVisualBorder({
              node: last.textNode,
              offset: last.textNode.length - 1,
              position: "right",
              priority: this.leftCaretPriority || 0
            });
          }
        } else if (target) {
          partialOffset = target.content.length - 1;
          position = "right";
        }
      }
      if (!target) {
        return null;
      }
      if (position === "left") {
        priority = this.leftCaretPriority || 0;
      } else {
        priority = this.rightCaretPriority || 0;
      }
      return new COMVisualPosition.COMVisualBorder({
        node: target.textNode,
        offset: partialOffset,
        position: position,
        priority: priority
      });
    };

    COMText.prototype.getCorrespondingBoundaryByOffset = function(index, option) {
      var char, i, len, offset, part, partialOffset, ref, target;
      if (option == null) {
        option = {};
      }
      if (this.dirty && !this.skipDirtyCheck) {
        Logger.error("dirty query", this.root, this, this.dirty, this.context, this.rc.id, this.cache.rev, this.rev);
        throw new Error("shouldn't get caret position when dirty");
      }
      offset = 0;
      ref = this.partials;
      for (i = 0, len = ref.length; i < len; i++) {
        part = ref[i];
        offset += part.content.length;
        if (index < offset) {
          target = part;
          partialOffset = index - (offset - part.content.length);
          break;
        }
      }
      if (index === offset) {
        target = this.partials[this.partials.length - 1] || null;
        if (!target) {
          return null;
        }
        partialOffset = target.content.length;
        return {
          node: target.textNode,
          offset: partialOffset,
          via: "Text"
        };
      }
      if (!target) {
        return null;
      }
      char = target.textNode.textContent[partialOffset - 1];
      if (partialOffset > 0 && option.right && char !== "\n") {
        return {
          node: target.textNode,
          offset: partialOffset - 1,
          via: "Text",
          type: "right"
        };
      } else {
        return {
          node: target.textNode,
          offset: partialOffset,
          via: "Text"
        };
      }
      return null;
    };

    COMText.prototype.detectTextOffset = function(textNode, index) {
      var fix, i, len, offset, part, partIndex, ref, ref1;
      if (this.dirty && !this.skipDirtyCheck) {
        throw new Error("shouldn't detect textoffset when dirty");
      }
      offset = 0;
      if (textNode === ((ref = this.holder) != null ? ref.childNodes[0] : void 0)) {
        if (this.blockTail && this.contentString.slice(-1) === "\n") {
          return {
            offset: this.length - 1
          };
        } else {
          return {
            offset: this.length
          };
        }
      }
      ref1 = this.partials;
      for (partIndex = i = 0, len = ref1.length; i < len; partIndex = ++i) {
        part = ref1[partIndex];
        if (part.el.contains(textNode)) {
          fix = 0;
          if (this.blockTail && this.keepNewlineSpace && index === (textNode != null ? textNode.length : void 0) && part.content.slice(-1) === "\n" && partIndex === this.partials.length - 1) {
            fix -= 1;
          }
          return {
            offset: offset + index + fix,
            part: part
          };
        }
        offset += part.content.length;
      }
      if (this.el.contains(textNode)) {
        return {
          offset: this.length
        };
      }
      return null;
    };

    COMText.prototype.toJSON = function(option) {
      var json;
      json = COMText.__super__.toJSON.call(this, option);
      if (!json) {
        return null;
      }
      json.contentString = this.contentString;
      return json;
    };

    COMText.prototype.toHumanString = function() {
      return this.contentString;
    };

    return COMText;

  })(COMNode);

  InsertTextOperation = (function(superClass) {
    extend(InsertTextOperation, superClass);

    function InsertTextOperation() {
      return InsertTextOperation.__super__.constructor.apply(this, arguments);
    }

    InsertTextOperation.prototype.name = "InsertTextOperation";

    InsertTextOperation.prototype.invoke = function() {
      var ref, text;
      text = this.target || this.context.root.getChildByPath(this.path);
      if (typeof this.option.start !== "number" || this.option.start > text.length) {
        this.error("insert at " + this.option.start + " of text with length " + text.length);
        return false;
      }
      if (!this.option.value || typeof this.option.value !== "string") {
        this.error("insert value of " + this.option.value);
        return false;
      }
      if (!(text instanceof COMText)) {
        this.error("target not instanceof COMText");
        return;
      }
      text.contentString = text.contentString.slice(0, this.option.start) + this.option.value + text.contentString.slice(this.option.start);
      text.dirty = true;
      if ((ref = text.parent) != null) {
        ref.pend();
      }
      return true;
    };

    InsertTextOperation.prototype.revoke = function() {
      var ref, text;
      text = this.target || this.context.root.getChildByPath(this.path);
      if (!(text instanceof COMText)) {
        this.error("target not instanceof COMText");
        return;
      }
      if (typeof this.option.start !== "number" || this.option.start + this.option.value.length > text.length) {
        this.error("revoke insert at " + this.option.start + " of text with length " + text.length);
        return false;
      }
      if (!this.option.value) {
        this.error("revoke insert value of " + this.option.value);
        return false;
      }
      if (text.contentString.slice(this.option.start, this.option.start + this.option.value.length) !== this.option.value) {
        this.error("revoke insert value of " + this.option.value + " but the text in the corresponding area is " + (text.contentString.slice(this.option.start, this.option.start + this.option.value.length)));
        return false;
      }
      text.contentString = text.contentString.slice(0, this.option.start) + text.contentString.slice(this.option.start + this.option.value.length);
      text.dirty = true;
      if ((ref = text.parent) != null) {
        ref.pend();
      }
      return true;
    };

    InsertTextOperation.prototype.describe = function() {
      return this.name + ": insert text \"" + this.option.value + "\" at " + this.option.start;
    };

    return InsertTextOperation;

  })(Operation.EditOperation);

  RemoveTextOperation = (function(superClass) {
    extend(RemoveTextOperation, superClass);

    function RemoveTextOperation() {
      return RemoveTextOperation.__super__.constructor.apply(this, arguments);
    }

    RemoveTextOperation.prototype.name = "RemoveTextOperation";

    RemoveTextOperation.prototype.invoke = function() {
      var ref, text;
      text = this.target || this.context.root.getChildByPath(this.path);
      if (!(text instanceof COMText)) {
        this.error("target not instanceof COMText");
        return;
      }
      if (typeof this.option.start !== "number" || this.option.start > text.length) {
        this.error("remove at " + this.option.start + " of text with length " + text.length);
        return false;
      }
      if (!this.option.length) {
        this.option.length = text.contentString.length - this.option.start;
        return false;
      }
      if (this.option.start + this.option.length > text.length) {
        this.error("remove at " + this.option.start + " length " + this.option.length + " exceed the contentString length of " + text.length);
        return false;
      }
      this.option.removed = text.contentString.slice(this.option.start, this.option.start + this.option.length);
      text.contentString = text.contentString.slice(0, this.option.start) + text.contentString.slice(this.option.start + this.option.length);
      text.dirty = true;
      if ((ref = text.parent) != null) {
        ref.pend();
      }
      return true;
    };

    RemoveTextOperation.prototype.revoke = function() {
      var ref, text;
      text = this.target || this.context.root.getChildByPath(this.path);
      if (!(text instanceof COMText)) {
        this.error("target not instanceof COMText");
        return;
      }
      if (typeof this.option.start !== "number" || this.option.start > text.length) {
        this.error("revoke at start " + this.option.start + " but with text with length " + text.length);
        return false;
      }
      if (!this.option.removed) {
        this.error("revoke value of " + this.option.value);
        return false;
      }
      text.contentString = text.contentString.slice(0, this.option.start) + this.option.removed + text.contentString.slice(this.option.start);
      text.dirty = true;
      if ((ref = text.parent) != null) {
        ref.pend();
      }
      return true;
    };

    RemoveTextOperation.prototype.describe = function() {
      return this.name + ": remove text at " + this.option.start + "~" + (this.option.start + this.option.length);
    };

    return RemoveTextOperation;

  })(Operation.EditOperation);

  module.exports = COMText;

}).call(this);
