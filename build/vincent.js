;
(function(){
/**
 * Implementation of base URI resolving algorithm in rfc2396.
 * - Algorithm from section 5.2
 *   (ignoring difference between undefined and '')
 * - Regular expression from appendix B
 * - Tests from appendix C
 *
 * @param {string} uri the relative URI to resolve
 * @param {string} baseuri the base URI (must be absolute) to resolve against
 */

var URI = function(){
    function resolveUri(sUri, sBaseUri) {
	    if (sUri == '' || sUri.charAt(0) == '#') return sUri;
	    var hUri = getUriComponents(sUri);
	    if (hUri.scheme) return sUri;
	    var hBaseUri = getUriComponents(sBaseUri);
	    hUri.scheme = hBaseUri.scheme;
	    if (!hUri.authority) {
	        hUri.authority = hBaseUri.authority;
	        if (hUri.path.charAt(0) != '/') {
		    aUriSegments = hUri.path.split('/');
		    aBaseUriSegments = hBaseUri.path.split('/');
		    aBaseUriSegments.pop();
		    var iBaseUriStart = aBaseUriSegments[0] == '' ? 1 : 0;
		    for (var i = 0;i < aUriSegments.length; i++) {
		        if (aUriSegments[i] == '..')
			    if (aBaseUriSegments.length > iBaseUriStart) aBaseUriSegments.pop();
		        else { aBaseUriSegments.push(aUriSegments[i]); iBaseUriStart++; }
		        else if (aUriSegments[i] != '.') aBaseUriSegments.push(aUriSegments[i]);
		    }
		    if (aUriSegments[i] == '..' || aUriSegments[i] == '.') aBaseUriSegments.push('');
		    hUri.path = aBaseUriSegments.join('/');
	        }
	    }
	    var result = '';
	    if (hUri.scheme   ) result += hUri.scheme + ':';
	    if (hUri.authority) result += '//' + hUri.authority;
	    if (hUri.path     ) result += hUri.path;
	    if (hUri.query    ) result += '?' + hUri.query;
	    if (hUri.fragment ) result += '#' + hUri.fragment;
	    return result;
    }
    uriregexp = new RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?');
    function getUriComponents(uri) {
	    var c = uri.match(uriregexp);
	    return { scheme: c[2], authority: c[4], path: c[5], query: c[7], fragment: c[9] };
    }
    var URI = {}
    URI.resolve = function(base,target){
        return resolveUri(target,base);
    }
    URI.normalize = function(url){
        return URI.resolve("",url);
    }
    return {URI:URI}
}();
BundleBuilder = function BundleBuilder(option) {
      if (option == null) {
        option = {};
      }
      this.prefixCodes = [];
      this.scripts = [];
      this.suffixCodes = [];
      this.contextName = option.contextName || "GlobalContext";
    }
BundleBuilder.prototype["addScript"] = function () {
      var item, ref, scripts, url;
      scripts = (function() {
        var i, len, results1;
        results1 = [];
        for (i = 0, len = arguments.length; i < len; i++) {
          item = arguments[i];
          results1.push(item);
        }
        return results1;
      }).apply(this, arguments);
      url = URI.URI;
      return (ref = this.scripts).push.apply(ref, scripts.map((function(_this) {
        return function(file) {
          var path;
          path = url.normalize(file.path);
          if (path.charAt(0) === "/") {
            path = path.slice(1);
          }
          return {
            path: path,
            content: file.scriptContent
          };
        };
      })(this)));
    };
BundleBuilder.prototype["createFakeWorker"] = function () {
      var guestend, hostend;
      hostend = {
        postMessage: function(message) {
          return typeof guestend.onmessage === "function" ? guestend.onmessage({
            data: message
          }) : void 0;
        },
        addEventListener: function(event, handler) {
          if (event === "message") {
            return this.onmessage = handler;
          }
        }
      };
      guestend = {
        isFakeWorker: true,
        postMessage: function(message) {
          return typeof hostend.onmessage === "function" ? hostend.onmessage({
            data: message
          }) : void 0;
        },
        addEventListener: function(event, handler) {
          if (event === "message") {
            return this.onmessage = handler;
          }
        }
      };
      return {
        hostend: hostend,
        guestend: guestend
      };
    };
BundleBuilder.prototype["addPrefixFunction"] = function (fn) {
      return this.prefixCodes.push("(" + (fn.toString()) + ")();");
    };
BundleBuilder.prototype["addEntryData"] = function (data, name) {
      return this.suffixCodes.push(name + " = " + (JSON.stringify(data)) + ";\n");
    };
BundleBuilder.prototype["addEntryFunction"] = function (fn) {
      return this.suffixCodes.push("(" + (fn.toString()) + ")();");
    };
BundleBuilder.prototype["addEntryModule"] = function (name) {
      return this.suffixCodes.push("(function(){" + this.contextName + ".require(\"" + name + "\")})();");
    };
BundleBuilder.prototype["generateWorker"] = function (option) {
      var js, smUrl, url, worker;
      if (option == null) {
        option = {};
      }
      js = this.generateBundle();
      if (option.sourceMap) {
        smUrl = this.sourceMapUrlFromJs(js);
        js += ";\n//# sourceMappingURL=" + smUrl;
      }
      url = URL.createObjectURL(new Blob([js]));
      worker = new Worker(url);
      return worker;
    };
BundleBuilder.prototype["sourceMapUrlFromJs"] = function (js) {
      var i, index, len, line, map, ref, result, smUrl;
      map = {
        "version": 3,
        "file": this.contextName,
        "sourceRoot": "",
        "sources": [this.contextName],
        "sourcesContent": [js],
        "names": [],
        "mappings": null
      };
      result = [];
      ref = js.split("\n");
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        line = ref[index];
        if (index === 0) {
          result.push("AAAA");
        } else {
          result.push(";AACA");
        }
      }
      map.mappings = result.join("");
      smUrl = "data:application/json;base64," + (btoa(unescape(encodeURIComponent(JSON.stringify(map)))));
      return smUrl;
    };
BundleBuilder.prototype["generateFakeWorker"] = function (option) {
      var code, fakeWorker, js, name, random, script, smUrl;
      if (option == null) {
        option = {};
      }
      js = this.generateBundle();
      fakeWorker = this.createFakeWorker();
      random = Math.random().toString().slice(5, 9);
      code = "(function(){\n    var self = _" + random + this.contextName + "FakeWorkerEnd;\n    " + js + ";\n})();";
      if (option.sourceMap) {
        smUrl = this.sourceMapUrlFromJs(js);
        code += "\n//# sourceMappingURL=" + smUrl;
      }
      name = "_" + random + this.contextName + "FakeWorkerEnd";
      self[name] = fakeWorker.guestend;
      script = document.createElement("script");
      script.innerHTML = code;
      script.setAttribute("worker", name);
      setTimeout(function() {
        return document.body.appendChild(script);
      }, 0);
      return fakeWorker.hostend;
    };
BundleBuilder.prototype["generateBundle"] = function () {
      var core, prefix, scripts, suffix;
      prefix = this.prefixCodes.join(";\n");
      suffix = this.suffixCodes.join(";\n");
      scripts = this.scripts.map((function(_this) {
        return function(script) {
          return _this.moduleTemplate.replace(/{{contextName}}/g, _this.contextName).replace(/{{currentModulePath}}/g, script.path).replace("{{currentModuleContent}}", script.content);
        };
      })(this));
      core = this.coreTemplate.replace(/{{contextName}}/g, this.contextName).replace("{{modules}}", scripts.join(";\n")).replace("{{createContextProcedure}}", this.getPureFunctionProcedure("createBundleContext")).replace("{{entryData}}").replace("{{BundleBuilderCode}}", this.getPureClassCode(BundleBuilder));
      return [prefix, core, suffix].join(";\n");
    };
BundleBuilder.prototype["getPureFunctionProcedure"] = function (name) {
      return "(" + (this["$" + name].toString()) + ")()";
    };
BundleBuilder.prototype["getPureClassCode"] = function (ClassObject, className) {
      var codes, constructor, prop, ref, template, value;
      if (!className) {
        className = ClassObject.name;
      }
      constructor = ClassObject.toString();
      template = className + ".prototype[\"{{prop}}\"] = {{value}};";
      codes = [];
      ref = ClassObject.prototype;
      for (prop in ref) {
        value = ref[prop];
        if (typeof value === "function") {
          value = value.toString();
        } else {
          value = JSON.stringify(value);
        }
        codes.push(template.replace("{{prop}}", prop).replace("{{value}}", value));
      }
      return className + " = " + (constructor.toString()) + "\n" + (codes.join("\n"));
    };
BundleBuilder.prototype["$createBundleContext"] = function () {
      return {
        modules: {},
        wrapCode: function(string) {
          return "(function(){\n" + string + "\n})();";
        },
        createDedicateWorker: function(pathes, option) {
          var bundle, i, item, j, len, len1, path, script, scripts;
          bundle = new BundleBuilder({
            contextName: option.contextName || (this.globalName || "GlobalContext") + "Worker"
          });
          for (i = 0, len = pathes.length; i < len; i++) {
            path = pathes[i];
            if (typeof path === "string") {
              script = this.getRequiredModule(path);
              scripts = [
                {
                  module: script,
                  path: path
                }
              ];
            } else if (path.test) {
              scripts = this.getMatchingModules(path);
            } else {
              continue;
            }
            for (j = 0, len1 = scripts.length; j < len1; j++) {
              item = scripts[j];
              script = {
                path: item.path,
                scriptContent: "(" + (item.module.exec.toString()) + ")()"
              };
              bundle.addScript(script);
            }
          }
          if (option.entryData) {
            bundle.addEntryData(option.entryData, option.entryDataName || "EntryData");
          }
          if (option.entryModule) {
            bundle.addEntryModule(option.entryModule);
          } else if (option.entryFunction) {
            bundle.addEntryFunction(option.entryFunction);
          }
          if (option.fake) {
            return bundle.generateFakeWorker(option);
          } else {
            return bundle.generateWorker(option);
          }
        },
        require: function(path) {
          return this.requireModule(null, path);
        },
        getRequiredModuleContent: function(path, fromPath) {
          var module;
          if (fromPath == null) {
            fromPath = "";
          }
          module = this.getRequiredModule(path, fromPath);
          return "(" + (module.exec.toString()) + ")()";
        },
        getMatchingModules: function(path) {
          var item, modulePath, ref, results;
          results = [];
          ref = this.modules;
          for (modulePath in ref) {
            item = ref[modulePath];
            if (path.test(modulePath)) {
              results.push({
                path: modulePath,
                module: item
              });
            }
          }
          return results;
        },
        getRequiredModule: function(path, fromPath) {
          var module, realPath, url;
          if (fromPath == null) {
            fromPath = "";
          }
          url = URI.URI;
          if (fromPath) {
            realPath = url.resolve(fromPath, path);
          } else {
            realPath = url.normalize(path);
          }
          if (realPath.charAt(0) === "/") {
            realPath = realPath.slice(1);
          }
          if (realPath.slice(-3) !== ".js") {
            realPath += ".js";
          }
          if (!this.modules[realPath]) {
            throw new Error("module " + path + " required at " + (fromPath || "/") + " is not exists");
          }
          module = this.modules[realPath];
          return module;
        },
        requireModule: function(fromPath, path) {
          var module;
          module = this.getRequiredModule(path, fromPath);
          if (module.exports) {
            return module.exports;
          }
          if (module.isRequiring) {
            return module.module.exports;
          }
          module.isRequiring = true;
          module.exec();
          module.exports = module.module.exports;
          module.isRequiring = false;
          return module.exports;
        },
        setModule: function(modulePath, module, exec) {
          if (modulePath.slice(-3) !== ".js") {
            modulePath += ".js";
          }
          return this.modules[modulePath] = {
            module: module,
            exec: exec
          };
        }
      };
    };
BundleBuilder.prototype["moduleTemplate"] = "(function(){\nvar require = {{contextName}}.requireModule.bind({{contextName}},\"{{currentModulePath}}\");\nvar module = {};\nmodule.exports = {};\nvar exports = module.exports;\nfunction exec(){\n    {{currentModuleContent}}\n}\n{{contextName}}.setModule(\"{{currentModulePath}}\",module,exec);\n})()";
BundleBuilder.prototype["coreTemplate"] = "(function(){\n/**\n * Implementation of base URI resolving algorithm in rfc2396.\n * - Algorithm from section 5.2\n *   (ignoring difference between undefined and '')\n * - Regular expression from appendix B\n * - Tests from appendix C\n *\n * @param {string} uri the relative URI to resolve\n * @param {string} baseuri the base URI (must be absolute) to resolve against\n */\n\nvar URI = function(){\n    function resolveUri(sUri, sBaseUri) {\n\t    if (sUri == '' || sUri.charAt(0) == '#') return sUri;\n\t    var hUri = getUriComponents(sUri);\n\t    if (hUri.scheme) return sUri;\n\t    var hBaseUri = getUriComponents(sBaseUri);\n\t    hUri.scheme = hBaseUri.scheme;\n\t    if (!hUri.authority) {\n\t        hUri.authority = hBaseUri.authority;\n\t        if (hUri.path.charAt(0) != '/') {\n\t\t    aUriSegments = hUri.path.split('/');\n\t\t    aBaseUriSegments = hBaseUri.path.split('/');\n\t\t    aBaseUriSegments.pop();\n\t\t    var iBaseUriStart = aBaseUriSegments[0] == '' ? 1 : 0;\n\t\t    for (var i = 0;i < aUriSegments.length; i++) {\n\t\t        if (aUriSegments[i] == '..')\n\t\t\t    if (aBaseUriSegments.length > iBaseUriStart) aBaseUriSegments.pop();\n\t\t        else { aBaseUriSegments.push(aUriSegments[i]); iBaseUriStart++; }\n\t\t        else if (aUriSegments[i] != '.') aBaseUriSegments.push(aUriSegments[i]);\n\t\t    }\n\t\t    if (aUriSegments[i] == '..' || aUriSegments[i] == '.') aBaseUriSegments.push('');\n\t\t    hUri.path = aBaseUriSegments.join('/');\n\t        }\n\t    }\n\t    var result = '';\n\t    if (hUri.scheme   ) result += hUri.scheme + ':';\n\t    if (hUri.authority) result += '//' + hUri.authority;\n\t    if (hUri.path     ) result += hUri.path;\n\t    if (hUri.query    ) result += '?' + hUri.query;\n\t    if (hUri.fragment ) result += '#' + hUri.fragment;\n\t    return result;\n    }\n    uriregexp = new RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?');\n    function getUriComponents(uri) {\n\t    var c = uri.match(uriregexp);\n\t    return { scheme: c[2], authority: c[4], path: c[5], query: c[7], fragment: c[9] };\n    }\n    var URI = {}\n    URI.resolve = function(base,target){\n        return resolveUri(target,base);\n    }\n    URI.normalize = function(url){\n        return URI.resolve(\"\",url);\n    }\n    return {URI:URI}\n}();\n{{BundleBuilderCode}}\n{{contextName}} = {{createContextProcedure}};\n{{contextName}}.contextName = \"{{contextName}}\";\n{{modules}};\n})()";
GlobalContext = (function () {
      return {
        modules: {},
        wrapCode: function(string) {
          return "(function(){\n" + string + "\n})();";
        },
        createDedicateWorker: function(pathes, option) {
          var bundle, i, item, j, len, len1, path, script, scripts;
          bundle = new BundleBuilder({
            contextName: option.contextName || (this.globalName || "GlobalContext") + "Worker"
          });
          for (i = 0, len = pathes.length; i < len; i++) {
            path = pathes[i];
            if (typeof path === "string") {
              script = this.getRequiredModule(path);
              scripts = [
                {
                  module: script,
                  path: path
                }
              ];
            } else if (path.test) {
              scripts = this.getMatchingModules(path);
            } else {
              continue;
            }
            for (j = 0, len1 = scripts.length; j < len1; j++) {
              item = scripts[j];
              script = {
                path: item.path,
                scriptContent: "(" + (item.module.exec.toString()) + ")()"
              };
              bundle.addScript(script);
            }
          }
          if (option.entryData) {
            bundle.addEntryData(option.entryData, option.entryDataName || "EntryData");
          }
          if (option.entryModule) {
            bundle.addEntryModule(option.entryModule);
          } else if (option.entryFunction) {
            bundle.addEntryFunction(option.entryFunction);
          }
          if (option.fake) {
            return bundle.generateFakeWorker(option);
          } else {
            return bundle.generateWorker(option);
          }
        },
        require: function(path) {
          return this.requireModule(null, path);
        },
        getRequiredModuleContent: function(path, fromPath) {
          var module;
          if (fromPath == null) {
            fromPath = "";
          }
          module = this.getRequiredModule(path, fromPath);
          return "(" + (module.exec.toString()) + ")()";
        },
        getMatchingModules: function(path) {
          var item, modulePath, ref, results;
          results = [];
          ref = this.modules;
          for (modulePath in ref) {
            item = ref[modulePath];
            if (path.test(modulePath)) {
              results.push({
                path: modulePath,
                module: item
              });
            }
          }
          return results;
        },
        getRequiredModule: function(path, fromPath) {
          var module, realPath, url;
          if (fromPath == null) {
            fromPath = "";
          }
          url = URI.URI;
          if (fromPath) {
            realPath = url.resolve(fromPath, path);
          } else {
            realPath = url.normalize(path);
          }
          if (realPath.charAt(0) === "/") {
            realPath = realPath.slice(1);
          }
          if (realPath.slice(-3) !== ".js") {
            realPath += ".js";
          }
          if (!this.modules[realPath]) {
            throw new Error("module " + path + " required at " + (fromPath || "/") + " is not exists");
          }
          module = this.modules[realPath];
          return module;
        },
        requireModule: function(fromPath, path) {
          var module;
          module = this.getRequiredModule(path, fromPath);
          if (module.exports) {
            return module.exports;
          }
          if (module.isRequiring) {
            return module.module.exports;
          }
          module.isRequiring = true;
          module.exec();
          module.exports = module.module.exports;
          module.isRequiring = false;
          return module.exports;
        },
        setModule: function(modulePath, module, exec) {
          if (modulePath.slice(-3) !== ".js") {
            modulePath += ".js";
          }
          return this.modules[modulePath] = {
            module: module,
            exec: exec
          };
        }
      };
    })();
GlobalContext.contextName = "GlobalContext";
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/LRU.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var LRU;

  LRU = (function() {
    function LRU() {
      this.limit = 50;
      this.items = [];
      this._equal = function() {
        return false;
      };
    }

    LRU.prototype.setComparer = function(_equal) {
      this._equal = _equal;
    };

    LRU.prototype.get = function(which) {
      var i, item, ref;
      ref = this.items;
      for (i = ref.length - 1; i >= 0; i += -1) {
        item = ref[i];
        if (this._equal(item.target, which)) {
          item.date = Date.now();
          this.sort();
          return item.target;
        }
      }
      return null;
    };

    LRU.prototype.sort = function() {
      return this.items.sort(function(a, b) {
        return a.date - b.date;
      });
    };

    LRU.prototype.update = function(cand) {
      return this.add(cand);
    };

    LRU.prototype.add = function(cand) {
      var find, i, item, len, ref;
      find = false;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (this._equal(item.target, cand)) {
          find = true;
          item.date = Date.now();
          break;
        }
      }
      if (!find) {
        this.items.push({
          date: Date.now(),
          target: cand
        });
      }
      this.sort();
      if (this.items.length > 50) {
        return this.items = this.items.slice(item.length - 50);
      }
    };

    LRU.prototype.remove = function(cand) {
      return this.items = this.items.filter((function(_this) {
        return function(item) {
          return _this._equal(item.target, cand);
        };
      })(this));
    };

    LRU.prototype.toArray = function() {
      return this.items.map(function(item) {
        return item.target;
      });
    };

    return LRU;

  })();

  module.exports = LRU;

}).call(this);

}
GlobalContext.setModule("component/LRU.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/animationFrame.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var SharedCallbacks;

  SharedCallbacks = require("./sharedCallbacks");

  module.exports = {
    callbacks: SharedCallbacks.create(),
    nextFrame: function(callback) {
      this.callbacks.push(callback);
      return this._startAnimationFrame();
    },
    _startAnimationFrame: function() {
      if (this.callbacks.count > 0 && !this.isRequesting) {
        this.isRequesting = true;
        return window.requestAnimationFrame((function(_this) {
          return function() {
            _this.isRequesting = false;
            return _this.callbacks();
          };
        })(this));
      }
    }
  };

}).call(this);

}
GlobalContext.setModule("component/animationFrame.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/arrayCompare.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var arrayCompare;

  module.exports = arrayCompare = function(a, b, cmp) {
    var i, ia, ib, index, j, la, len, len1, map, match;
    if (a == null) {
      a = [];
    }
    if (b == null) {
      b = [];
    }
    if (!cmp) {
      cmp = function(x, y) {
        return x === y;
      };
    }
    map = [];
    map.length = b.length;
    a = a.slice();
    b = b.slice();
    la = [];
    for (i = 0, len = a.length; i < len; i++) {
      ia = a[i];
      match = false;
      for (index = j = 0, len1 = b.length; j < len1; index = ++j) {
        ib = b[index];
        if (cmp(ia, ib)) {
          b.splice(index, 1);
          match = true;
          break;
        }
      }
      if (!match) {
        la.push(ia);
      }
    }
    return {
      left: la,
      right: b
    };
  };

  arrayCompare.match = function(a, b, cmp) {
    var diff;
    diff = arrayCompare(a, b, cmp);
    return diff.left.length === 0 && diff.right.length === 0;
  };

  arrayCompare.exactly = function(a, b, cmp) {
    var i, index, item, len;
    if (a.length !== b.length) {
      return false;
    }
    for (index = i = 0, len = a.length; i < len; index = ++i) {
      item = a[index];
      if (!cmp(item, b[index])) {
        return false;
      }
    }
    return true;
  };

  arrayCompare.sortByExample = function(target, example, cmp) {
    var arr, found, i, index, item, j, k, len, len1, ref, results, shouldBe, swap, swapIndex, swaped, toSwap;
    if (target == null) {
      target = [];
    }
    if (example == null) {
      example = [];
    }
    if (cmp == null) {
      cmp = function(a, b) {
        return a === b;
      };
    }
    if (target.length !== example.length) {
      return false;
    }
    swaped = false;
    swap = function(array, left, right) {
      var _;
      if (left === right) {
        return;
      }
      _ = array[left];
      array[left] = array[right];
      return array[right] = _;
    };
    for (index = i = 0, len = target.length; i < len; index = ++i) {
      item = target[index];
      shouldBe = example[index];
      found = false;
      arr = (function() {
        results = [];
        for (var j = index, ref = target.length; index <= ref ? j < ref : j > ref; index <= ref ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this);
      for (k = 0, len1 = arr.length; k < len1; k++) {
        swapIndex = arr[k];
        toSwap = target[swapIndex];
        if (cmp(toSwap, shouldBe)) {
          swap(target, index, swapIndex);
          if (index !== swapIndex) {
            swaped = true;
          }
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return swaped;
  };

}).call(this);

}
GlobalContext.setModule("component/arrayCompare.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/async.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    /*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = setImmediate;
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}
GlobalContext.setModule("component/async.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/bufferedEndlessLoader.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var BufferedEndlessLoader, Errors, Property,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Property = require("/component/property");

  Errors = Leaf.ErrorDoc.create().define("ProgrammerError").define("DelegateError").define("Reset").generate();

  BufferedEndlessLoader = (function(superClass) {
    extend(BufferedEndlessLoader, superClass);

    BufferedEndlessLoader.Errors = Errors;

    function BufferedEndlessLoader() {
      BufferedEndlessLoader.__super__.constructor.call(this);
      Property.define(this, "isLoading").afterSet((function(_this) {
        return function(isLoading, isPreviousLoading) {
          if (isLoading && !isPreviousLoading) {
            return _this.emit("startLoading");
          } else if (isPreviousLoading && !isLoading) {
            return _this.emit("endLoading");
          }
        };
      })(this));
      Property.define(this, "isDrain").atGet((function(_this) {
        return function() {
          return _this.data.index >= _this.data.buffer.length && _this.data.remoteDrain;
        };
      })(this));
      this.limit = 20;
      this.bufferLimit = 20;
      this.reset();
    }

    BufferedEndlessLoader.prototype.atPanic = function() {
      var err, ref, state;
      ref = [this.panicError, this.panicState], err = ref[0], state = ref[1];
      Logger.error(err, state);
      this.recover();
      this.setState("wait");
      this.isLoading = false;
      return this.callback(err);
    };

    BufferedEndlessLoader.prototype.get = function(count, callback) {
      var index;
      if (this.data.buffer.length - this.data.index >= count) {
        this.data.index += count;
        return callback(null, this.data.buffer.slice(this.data.index - count, this.data.index));
      } else if (this.state === "drain") {
        index = this.data.index;
        this.data.index = this.data.buffer.length;
        return callback(null, this.data.buffer.slice(index));
      } else {
        this.data.fetchedCallbacks.push({
          count: count,
          callback: callback
        });
        return this.ensureFetching();
      }
    };

    BufferedEndlessLoader.prototype.reset = function() {
      var i, item, len, ref;
      this.isLoading = false;
      ref = this.data.fetchedCallbacks || [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item != null) {
          if (typeof item.callback === "function") {
            item.callback(new Errors.Reset("Endless loader is reseted"));
          }
        }
      }
      BufferedEndlessLoader.__super__.reset.call(this);
      this.data.fetchedCallbacks = [];
      this.data.index = 0;
      this.data.buffer = [];
      return this.data.remoteDrain = false;
    };

    BufferedEndlessLoader.prototype.setLoadDelegator = function(delegator) {
      return this.delegator = delegator;
    };

    BufferedEndlessLoader.prototype.ensureFetching = function() {
      if (this.state === "panic") {
        return false;
      }
      this.give("fetchSignal");
      return true;
    };

    BufferedEndlessLoader.prototype.start = function() {
      if (this.state !== "void") {
        return false;
      }
      return this.setState("fetch");
    };

    BufferedEndlessLoader.prototype.atFetch = function(stale) {
      if (!this.delegator) {
        this.error(new Errors.ProgrammerError("should set load delegator before start"));
        return;
      }
      this.isLoading = true;
      return this.delegator(this.data.buffer[this.data.buffer.length - 1] || null, this.data.buffer.length, this.limit, (function(_this) {
        return function(err, results) {
          var ref;
          if (stale()) {
            return;
          }
          _this.isLoading = false;
          if (err) {
            _this.error(new Errors.DelegateError("Fail to load due to delegate error", {
              via: err
            }));
            return;
          }
          if (!results || results.length === 0) {
            _this.setState("remoteDrain");
            return;
          }
          (ref = _this.data.buffer).push.apply(ref, results);
          return _this.setState("distribute");
        };
      })(this));
    };

    BufferedEndlessLoader.prototype.atDistribute = function() {
      var i, index, item, len, ref, solved;
      solved = 0;
      ref = this.data.fetchedCallbacks;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        if (this.data.buffer.length - this.data.index >= item.count) {
          this.data.index += item.count;
          solved = index + 1;
          item.callback(null, this.data.buffer.slice(this.data.index - item.count, this.data.index));
        } else {
          break;
        }
      }
      this.data.fetchedCallbacks = this.data.fetchedCallbacks.slice(solved);
      if (this.data.fetchedCallbacks.length > 0 || this.data.buffer.length - this.data.index < this.bufferLimit) {
        return this.setState("fetch");
      } else {
        return this.setState("wait");
      }
    };

    BufferedEndlessLoader.prototype.atWait = function() {
      this.isLoading = false;
      return this.waitFor("fetchSignal", (function(_this) {
        return function() {
          return _this.setState("fetch");
        };
      })(this));
    };

    BufferedEndlessLoader.prototype.atRemoteDrain = function() {
      var i, item, left, len, ref;
      this.isLoading = false;
      this.data.remoteDrain = true;
      left = this.data.buffer.slice(this.data.index);
      ref = this.data.fetchedCallbacks;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        item.callback(null, left.splice(0, item.count));
      }
      this.data.fetchedCallbacks.length = 0;
      if (left.length > 0) {
        this.data.index = this.data.buffer.length - left.length;
      }
      return this.setState("drain");
    };

    BufferedEndlessLoader.prototype.callback = function() {
      var args, cb, i, len, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ref = this.data.fetchedCallbacks;
      for (i = 0, len = ref.length; i < len; i++) {
        cb = ref[i];
        cb.callback.apply(cb, args);
      }
      return this.data.fetchedCallbacks = [];
    };

    BufferedEndlessLoader.prototype.atDrain = function() {};

    return BufferedEndlessLoader;

  })(Leaf.States);

  module.exports = BufferedEndlessLoader;

}).call(this);

}
GlobalContext.setModule("component/bufferedEndlessLoader.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/color.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = {
    colors: {
      "black": "#000",
      "white": "#fff",
      "red": "#f00"
    },
    RGBString: function(r, g, b) {
      var bs, gs, rs, str;
      rs = Math.min(Math.max(parseInt(r), 0), 255).toString(16);
      gs = Math.min(Math.max(parseInt(g), 0), 255).toString(16);
      bs = Math.min(Math.max(parseInt(b), 0), 255).toString(16);
      if (rs.length < 2) {
        rs = "0" + rs;
      }
      if (gs.length < 2) {
        gs = "0" + gs;
      }
      if (bs.length < 2) {
        bs = "0" + bs;
      }
      str = "#" + rs + gs + bs;
      return str;
    },
    fromRGBString: function(string) {
      var bs, gs, rs;
      string = string.replace(/#/g, "");
      if (string.length === 3) {
        rs = string[0] + string[0];
        gs = string[1] + string[1];
        bs = string[2] + string[2];
      } else if (string.length === 6) {
        rs = string.slice(0, 2);
        gs = string.slice(2, 4);
        bs = string.slice(4, 6);
      } else {
        return null;
      }
      return {
        r: parseInt(rs, 16),
        g: parseInt(gs, 16),
        b: parseInt(bs, 16)
      };
    },
    nameToColor: function(name) {
      return this.colors[name] || name;
    },
    interpolate: function(c1, c2, position) {
      var prop;
      c1 = this.nameToColor(c1);
      c2 = this.nameToColor(c2);
      c1 = this.fromRGBString(c1);
      c2 = this.fromRGBString(c2);
      return this.RGBString.apply(this, (function() {
        var i, len, ref, results;
        ref = "rgb";
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          prop = ref[i];
          results.push(c1[prop] + position * (c2[prop] - c1[prop]));
        }
        return results;
      })());
    }
  };

}).call(this);

}
GlobalContext.setModule("component/color.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/dateExtra.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Month, MonthAbbreviation, expandNumberWidth;

  Date.prototype.forward = function(milsec) {
    return new Date(this.getTime() + milsec);
  };

  Date.prototype.backward = function(milsec) {
    return this.forward(-milsec);
  };

  Date.Hour = 60 * 60 * 1000;

  Date.Day = 24 * Date.Hour;

  Date.Week = Date.Day * 7;

  Date.prototype.firstMonthDate = function() {
    return this.backward(Date.Day * (this.getDate() - 1));
  };

  Date.prototype.prevMonth = function() {
    var prevMonth, yearFix;
    prevMonth = this.getMonth() - 1;
    yearFix = 0;
    if (prevMonth < 0) {
      prevMonth = 11;
      yearFix = -1;
    }
    return new Date(this.getFullYear() + yearFix, prevMonth);
  };

  Date.prototype.nextMonth = function() {
    var nextMonth, yearFix;
    yearFix = 0;
    nextMonth = this.getMonth() + 1;
    if (nextMonth > 11) {
      nextMonth = 0;
      yearFix = 1;
    }
    return new Date(this.getFullYear() + yearFix, nextMonth);
  };

  Date.prototype.prevYear = function() {
    var prevYear;
    prevYear = this.getFullYear() - 1;
    return new Date(prevYear, this.getMonth());
  };

  Date.prototype.nextYear = function() {
    var nextYear;
    nextYear = this.getFullYear() + 1;
    return new Date(nextYear, this.getMonth());
  };

  Month = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

  MonthAbbreviation = ["Jan.", "Feb.", "Mar.", "Apr.", "May", "June", "July", "Aug.", "Sept.", "Oct.", "Nov.", "Dec."];

  MonthAbbreviation = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"];

  Date.prototype.getMonthString = function() {
    return Month[this.getMonth()];
  };

  Date.prototype.getMonthAbbreviation = function() {
    return MonthAbbreviation[this.getMonth()];
  };

  expandNumberWidth = function(number, bit) {
    var str;
    if (!bit || isNaN(bit)) {
      bit = 2;
    }
    str = number.toString();
    if (str.length >= bit) {
      return str;
    } else {
      str = "0" + str;
      return expandNumberWidth(str, bit);
    }
  };

  Date.prototype.getHoursString = function() {
    return expandNumberWidth(this.getHours(), 2);
  };

  Date.prototype.getSecondsString = function() {
    return expandNumberWidth(this.getSeconds(), 2);
  };

  Date.prototype.getMinutesString = function() {
    return expandNumberWidth(this.getMinutes(), 2);
  };

  Date.prototype.format = function(string) {
    var e, error;
    try {
      string = string.replace(/\$monthString/g, this.getMonthString()).replace(/\$monthAbbreviation/g, this.getMonthAbbreviation()).replace(/\$hours/g, this.getHoursString()).replace(/\$minutes/g, this.getMinutesString()).replace(/\$seconds/g, this.getSecondsString()).replace(/\$dayString/g, this.getDateString()).replace(/\$day/g, this.getDate()).replace(/\$month/g, this.getMonth() + 1).replace(/\$year/g, this.getFullYear());
      return string;
    } catch (error) {
      e = error;
      return Logger.error(e);
    }
  };

  Date.prototype.getDateString = function() {
    var day;
    day = this.getDate();
    if (day === 1) {
      return "1st";
    } else if (day === 2) {
      return "2nd";
    } else if (day === 3) {
      return "3rd";
    } else {
      return day + "th";
    }
  };

  Date.prototype.sameDay = function(date) {
    if (this.getDate() === date.getDate() && this.getFullYear() === date.getFullYear() && this.getMonth() === date.getMonth()) {
      return true;
    }
    return false;
  };

  Date.prototype.sameYear = function(date) {
    if (Math.floor(date.getTime() / Date.Year) === Math.floor(this.getTime() / Date.Year)) {
      return true;
    }
    return false;
  };

  Date.prototype.beginOfTheDay = function() {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate());
  };

}).call(this);

}
GlobalContext.setModule("component/dateExtra.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/debounce.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Debounce,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Debounce = (function(superClass) {
    extend(Debounce, superClass);

    Debounce.debounce = function(time, method) {
      var db, option;
      if (time == null) {
        time = 0;
      }
      if (typeof time === "number") {
        option = {
          time: time
        };
      } else {
        option = time;
      }
      db = new Debounce(option, method);
      return db.trigger.bind(db);
    };

    function Debounce(option, handler) {
      if (option == null) {
        option = {};
      }
      this.handler = handler != null ? handler : function() {};
      Debounce.__super__.constructor.call(this);
      this.time = option.time || 1000;
      this.max = option.max || null;
      this.reset();
    }

    Debounce.prototype.setHandler = function(handler) {
      this.handler = handler;
    };

    Debounce.prototype.trigger = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.triggerArgs = args;
      if (!this.firstTriggerDate && this.max) {
        this.firstTriggerDate = Date.now();
        clearTimeout(this.maxTimer);
        this.maxTimer = setTimeout((function(_this) {
          return function() {
            clearTimeout(_this.timer);
            _this.firstTriggerDate = null;
            _this.handler.apply(_this, _this.triggerArgs);
            return _this.triggerArgs = [];
          };
        })(this), this.max);
      }
      clearTimeout(this.timer);
      this.timer = setTimeout((function(_this) {
        return function() {
          clearTimeout(_this.maxTimer);
          _this.maxTimer = null;
          _this.firstTriggerDate = null;
          _this.handler.apply(_this, _this.triggerArgs);
          return _this.triggerArgs = [];
        };
      })(this), this.time);
      return this;
    };

    Debounce.prototype.cancel = function() {
      return this.reset();
    };

    Debounce.prototype.reset = function() {
      clearTimeout(this.timer);
      clearTimeout(this.maxTimer);
      this.firstTriggerDate = null;
      return this.triggerArgs = [];
    };

    return Debounce;

  })(Leaf.EventEmitter);

  module.exports = Debounce;

}).call(this);

}
GlobalContext.setModule("component/debounce.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/diff.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    /**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.Diff;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push([DIFF_EQUAL, '']);
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var a = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = a.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, a[j]);
          }
          pointer = pointer + a.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge_(text1);
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastequality && (lastequality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastequality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push([DIFF_EQUAL, precontext]);
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push([diff_type, diff_text]);
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push([diff_type, diff_text]);
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push([DIFF_EQUAL, postcontext]);
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// Export these global variables so that they survive Google's JS compiler.
// In a browser, 'this' will be 'window'.
// Users of node.js should 'require' the uncompressed version since Google's
// JS compiler may break the following exports for non-browser environments.
exports['diff_match_patch'] = diff_match_patch;
exports['DIFF_DELETE'] = DIFF_DELETE;
exports['DIFF_INSERT'] = DIFF_INSERT;
exports['DIFF_EQUAL'] = DIFF_EQUAL;
exports.Differ = diff_match_patch

}
GlobalContext.setModule("component/diff.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/domCopy.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  Element.prototype.serializeWithStyles = (function(_this) {
    return function() {
      var computeDefaultStyleByTagName, defaultStylesByTagName, getDefaultStyleByTagName, i, j, noStyleTags, ref, serializeWithStyles, tagNames;
      defaultStylesByTagName = {};
      noStyleTags = {
        "BASE": true,
        "HEAD": true,
        "HTML": true,
        "META": true,
        "NOFRAME": true,
        "NOSCRIPT": true,
        "PARAM": true,
        "SCRIPT": true,
        "STYLE": true,
        "TITLE": true
      };
      tagNames = ["A", "ABBR", "ADDRESS", "AREA", "ARTICLE", "ASIDE", "AUDIO", "B", "BASE", "BDI", "BDO", "BLOCKQUOTE", "BODY", "BR", "BUTTON", "CANVAS", "CAPTION", "CENTER", "CITE", "CODE", "COL", "COLGROUP", "COMMAND", "DATALIST", "DD", "DEL", "DETAILS", "DFN", "DIV", "DL", "DT", "EM", "EMBED", "FIELDSET", "FIGCAPTION", "FIGURE", "FONT", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "HEAD", "HEADER", "HGROUP", "HR", "HTML", "I", "IFRAME", "IMG", "INPUT", "INS", "KBD", "KEYGEN", "LABEL", "LEGEND", "LI", "LINK", "MAP", "MARK", "MATH", "MENU", "META", "METER", "NAV", "NOBR", "NOSCRIPT", "OBJECT", "OL", "OPTION", "OPTGROUP", "OUTPUT", "P", "PARAM", "PRE", "PROGRESS", "Q", "RP", "RT", "RUBY", "S", "SAMP", "SCRIPT", "SECTION", "SELECT", "SMALL", "SOURCE", "SPAN", "STRONG", "STYLE", "SUB", "SUMMARY", "SUP", "SVG", "TABLE", "TBODY", "TD", "TEXTAREA", "TFOOT", "TH", "THEAD", "TIME", "TITLE", "TR", "TRACK", "U", "UL", "VAR", "VIDEO", "WBR"];
      computeDefaultStyleByTagName = function(tagName) {
        var computedStyle, defaultStyle, element, i, j, ref;
        defaultStyle = {};
        element = document.body.appendChild(document.createElement(tagName));
        computedStyle = getComputedStyle(element);
        for (i = j = 0, ref = computedStyle.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          defaultStyle[computedStyle[i]] = computedStyle[computedStyle[i]];
        }
        document.body.removeChild(element);
        return defaultStyle;
      };
      getDefaultStyleByTagName = function(tagName) {
        tagName = tagName.toUpperCase();
        if (!defaultStylesByTagName[tagName]) {
          defaultStylesByTagName[tagName] = computeDefaultStyleByTagName(tagName);
        }
        return defaultStylesByTagName[tagName];
      };
      for (i = j = 0, ref = tagNames.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (!noStyleTags[tagNames[i]]) {
          defaultStylesByTagName[tagNames[i]] = computeDefaultStyleByTagName(tagNames[i]);
        }
      }
      return serializeWithStyles = function() {
        var computedStyle, cssPropName, cssTexts, defaultStyle, e, elements, ii, k, l, m, ref1, ref2, ref3, result;
        if (this.nodeType !== Node.ELEMENT_NODE) {
          throw new TypeError();
        }
        cssTexts = [];
        elements = this.querySelectorAll("*");
        for (i = k = 0, ref1 = elements.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          e = elements[i];
          if (!noStyleTags[e.tagName]) {
            computedStyle = getComputedStyle(e);
            defaultStyle = getDefaultStyleByTagName(e.tagName);
            cssTexts[i] = e.style.cssText;
            for (ii = l = 0, ref2 = computedStyle.length; 0 <= ref2 ? l < ref2 : l > ref2; ii = 0 <= ref2 ? ++l : --l) {
              cssPropName = computedStyle[ii];
              if (computedStyle[cssPropName] !== defaultStyle[cssPropName]) {
                e.style[cssPropName] = computedStyle[cssPropName];
              }
            }
          }
        }
        result = this.outerHTML;
        for (i = m = 0, ref3 = elements.length; 0 <= ref3 ? m < ref3 : m > ref3; i = 0 <= ref3 ? ++m : --m) {
          elements[i].style.cssText = cssTexts[i];
        }
        return result;
      };
    };
  })(this)();

  Element.prototype.cloneWithStyles = (function(_this) {
    return function() {
      var cloneWithStyles, computeDefaultStyleByTagName, defaultStylesByTagName, getDefaultStyleByTagName, i, j, noStyleTags, ref, tagNames;
      defaultStylesByTagName = {};
      noStyleTags = {
        "BASE": true,
        "HEAD": true,
        "HTML": true,
        "META": true,
        "NOFRAME": true,
        "NOSCRIPT": true,
        "PARAM": true,
        "SCRIPT": true,
        "STYLE": true,
        "TITLE": true
      };
      tagNames = ["A", "ABBR", "ADDRESS", "AREA", "ARTICLE", "ASIDE", "AUDIO", "B", "BASE", "BDI", "BDO", "BLOCKQUOTE", "BODY", "BR", "BUTTON", "CANVAS", "CAPTION", "CENTER", "CITE", "CODE", "COL", "COLGROUP", "COMMAND", "DATALIST", "DD", "DEL", "DETAILS", "DFN", "DIV", "DL", "DT", "EM", "EMBED", "FIELDSET", "FIGCAPTION", "FIGURE", "FONT", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "HEAD", "HEADER", "HGROUP", "HR", "HTML", "I", "IFRAME", "IMG", "INPUT", "INS", "KBD", "KEYGEN", "LABEL", "LEGEND", "LI", "LINK", "MAP", "MARK", "MATH", "MENU", "META", "METER", "NAV", "NOBR", "NOSCRIPT", "OBJECT", "OL", "OPTION", "OPTGROUP", "OUTPUT", "P", "PARAM", "PRE", "PROGRESS", "Q", "RP", "RT", "RUBY", "S", "SAMP", "SCRIPT", "SECTION", "SELECT", "SMALL", "SOURCE", "SPAN", "STRONG", "STYLE", "SUB", "SUMMARY", "SUP", "SVG", "TABLE", "TBODY", "TD", "TEXTAREA", "TFOOT", "TH", "THEAD", "TIME", "TITLE", "TR", "TRACK", "U", "UL", "VAR", "VIDEO", "WBR"];
      computeDefaultStyleByTagName = function(tagName) {
        var computedStyle, defaultStyle, element, i, j, ref;
        defaultStyle = {};
        element = document.body.appendChild(document.createElement(tagName));
        computedStyle = getComputedStyle(element);
        for (i = j = 0, ref = computedStyle.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          defaultStyle[computedStyle[i]] = computedStyle[computedStyle[i]];
        }
        document.body.removeChild(element);
        return defaultStyle;
      };
      getDefaultStyleByTagName = function(tagName) {
        tagName = tagName.toUpperCase();
        if (!defaultStylesByTagName[tagName]) {
          defaultStylesByTagName[tagName] = computeDefaultStyleByTagName(tagName);
        }
        return defaultStylesByTagName[tagName];
      };
      for (i = j = 0, ref = tagNames.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (!noStyleTags[tagNames[i]]) {
          defaultStylesByTagName[tagNames[i]] = computeDefaultStyleByTagName(tagNames[i]);
        }
      }
      return cloneWithStyles = function() {
        var computedStyle, cssPropName, cssTexts, defaultStyle, e, elements, ii, k, l, len, m, ref1, ref2, result;
        if (this.nodeType !== Node.ELEMENT_NODE) {
          throw new TypeError();
        }
        cssTexts = [];
        elements = Array.prototype.slice.call(this.querySelectorAll("*"));
        elements.push(this);
        for (i = k = 0, len = elements.length; k < len; i = ++k) {
          e = elements[i];
          if (!noStyleTags[e.tagName]) {
            computedStyle = getComputedStyle(e);
            defaultStyle = getDefaultStyleByTagName(e.tagName);
            cssTexts[i] = e.style.cssText;
            for (ii = l = 0, ref1 = computedStyle.length; 0 <= ref1 ? l < ref1 : l > ref1; ii = 0 <= ref1 ? ++l : --l) {
              cssPropName = computedStyle[ii];
              if (computedStyle[cssPropName] !== defaultStyle[cssPropName]) {
                e.style[cssPropName] = computedStyle[cssPropName];
              }
            }
          }
        }
        result = this.cloneNode(true);
        for (i = m = 0, ref2 = elements.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
          elements[i].style.cssText = cssTexts[i];
        }
        return result;
      };
    };
  })(this)();

  module.exports = (function(_this) {
    return function(element) {
      var child, el, j, len, ref, span, string;
      el = element.cloneWithStyles();
      ref = el.querySelectorAll("*");
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        child.className = "";
        child.id = "";
      }
      el.className = "";
      el.id = "";
      return el;
      string = element.serializeWithStyles();
      span = document.createElement("span");
      span.innerHTML = string;
      return span.children[0];
    };
  })(this);

}).call(this);

}
GlobalContext.setModule("component/domCopy.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/dragContext.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DragContext, DraggableState, DroppableState,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DragContext = (function(superClass) {
    extend(DragContext, superClass);

    Leaf.EventEmitter.mixin(DragContext);

    function DragContext() {
      DragContext.__super__.constructor.call(this);
      this.droppables = [];
      this.draggables = [];
      this.mouseupListener = this.mouseupListener.bind(this);
      this.mousemoveListener = this.mousemoveListener.bind(this);
      this.dragFix = {
        x: 0,
        y: 0
      };
      this.init();
    }

    DragContext.prototype.init = function() {
      var capture;
      capture = true;
      window.addEventListener("mouseup", this.mouseupListener, capture);
      return window.addEventListener("mousemove", this.mousemoveListener, capture);
    };

    DragContext.prototype.destroy = function() {
      var i, item, j, len, len1, ref, ref1, results;
      window.removeEventListener("mouseup", this.mouseupListener);
      window.removeEventListener("mousemove", this.mousemoveListener);
      ref = this.droppables.slice(0);
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        this.removeDroppable(item);
      }
      ref1 = this.draggables.slice(0);
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        item = ref1[j];
        results.push(this.removeDraggable(item));
      }
      return results;
    };

    DragContext.prototype.addContext = function(node) {
      this.addDraggable(node);
      return this.addDroppable(node);
    };

    DragContext.prototype.addDraggable = function(node) {
      var draggable, i, item, len, ref;
      ref = this.draggables;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.node === node) {
          return;
        }
      }
      draggable = new DraggableState(node, this);
      this.draggables.push(draggable);
      return draggable.on("start", (function(_this) {
        return function(e) {
          if (_this.currentDraggableState) {
            throw new Error("already dragging");
          }
          _this.currentDraggableState = draggable;
          e.dragSession = _this.currentDraggableState.session;
          _this.emit("start", e);
          return DragContext.emit("start", e);
        };
      })(this));
    };

    DragContext.prototype.addDroppable = function(node) {
      var droppable, i, item, len, ref;
      ref = this.droppables;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.node === node) {
          return;
        }
      }
      droppable = new DroppableState(node, this);
      this.droppables.push(droppable);
      droppable.on("drop", (function(_this) {
        return function(e) {
          if (!_this.currentDraggableState) {
            throw new Error("drop with no draggable");
          }
          if (_this.draggingShadow && _this.draggingShadow.parentElement) {
            _this.draggingShadow.parentElement.removeChild(_this.draggingShadow);
          }
          _this.draggingShadow = null;
          e.draggable = _this.currentDraggableState.node;
          e.dragSession = _this.currentDraggableState.session;
          e.droppable = droppable.node;
          e.stopPropagation();
          _this.emit("drop", e);
          DragContext.emit("drop", e);
          return _this.currentDraggableState = null;
        };
      })(this));
      return droppable.on("hover", (function(_this) {
        return function(e) {
          if (!_this.currentDraggableState) {
            throw "drop on no draggable";
          }
          e.draggable = _this.currentDraggableState.node;
          e.dragSession = _this.currentDraggableState.session;
          e.droppable = droppable.node;
          _this.hasHover = true;
          _this.emit("hover", e);
          return DragContext.emit("hover", e);
        };
      })(this));
    };

    DragContext.prototype.removeDraggable = function(node) {
      return this.draggables = this.draggables.filter(function(item) {
        if (item.node === node) {
          item.destroy();
          return false;
        }
        return true;
      });
    };

    DragContext.prototype.removeDroppable = function(node) {
      return this.droppables = this.droppables.filter(function(item) {
        if (item.node === node) {
          item.destroy();
          return false;
        }
        return true;
      });
    };

    DragContext.prototype.clearContext = function(node) {
      this.removeDraggable(node);
      return this.removeDroppable(node);
    };

    DragContext.prototype.mouseupListener = function(e) {
      if (!this.currentDraggableState) {
        return;
      }
      document.body.classList.remove("no-select");
      e.draggable = this.currentDraggableState.node;
      e.dragSession = this.currentDraggableState.session;
      this.emit("release", e);
      DragContext.emit("release", e);
      return setTimeout((function(_this) {
        return function() {
          if (_this.draggingShadow && _this.draggingShadow.parentElement) {
            _this.draggingShadow.parentElement.removeChild(_this.draggingShadow);
          }
          _this.currentDraggableState = null;
          return _this.draggingShadow = null;
        };
      })(this), 0);
    };

    DragContext.prototype.mousemoveListener = function(e) {
      this.lastMousePoint = {
        x: e.clientX,
        y: e.clientY
      };
      if (!this.currentDraggableState) {
        return;
      }
      document.body.classList.add("no-select");
      e.draggable = this.currentDraggableState.node;
      e.dragSession = this.currentDraggableState.session;
      e.preventDefault();
      if (this.hasHover) {
        this.hasHover = false;
        e.dragHover = true;
      } else {
        e.dragHover = false;
      }
      this.emit("move", e);
      DragContext.emit("move", e);
      return this.updateShadow();
    };

    DragContext.prototype.updateShadow = function() {
      if (this.draggingShadow && this.lastMousePoint) {
        this.draggingShadow.style.top = this.lastMousePoint.y + this.dragFix.y + "px";
        return this.draggingShadow.style.left = this.lastMousePoint.x + this.dragFix.x + "px";
      }
    };

    DragContext.prototype.addDraggingShadow = function(node, fix) {
      var base, base1;
      if (fix == null) {
        fix = {};
      }
      this.draggingShadow = node;
      if (DragContext.draggingShadow && DragContext.draggingShadow.parentElement) {
        DragContext.draggingShadow.parentElement.removeChild(DragContext.draggingShadow);
      }
      DragContext.draggingShadow = node;
      document.body.appendChild(node);
      node.style.position = "absolute";
      this.dragFix = fix;
      if ((base = this.dragFix).x == null) {
        base.x = 0;
      }
      if ((base1 = this.dragFix).y == null) {
        base1.y = 0;
      }
      node.style.pointerEvents = "none";
      return this.updateShadow();
    };

    return DragContext;

  })(Leaf.EventEmitter);

  DroppableState = (function(superClass) {
    extend(DroppableState, superClass);

    function DroppableState(node1, parent) {
      this.node = node1;
      this.parent = parent;
      DroppableState.__super__.constructor.call(this);
      this.onMove = this._onMove.bind(this);
      this.onUp = this._onUp.bind(this);
      this.node.addEventListener("mousemove", this.onMove, true);
      this.node.addEventListener("mouseup", this.onUp, true);
    }

    DroppableState.prototype._onMove = function(e) {
      var ref;
      if ((ref = this.parent) != null ? ref.currentDraggableState : void 0) {
        e.preventDefault();
        this.emit("hover", e);
        return false;
      }
    };

    DroppableState.prototype._onUp = function(e) {
      var ref, ref1;
      if (((ref = this.parent) != null ? ref.currentDraggableState : void 0) && ((ref1 = this.parent) != null ? ref1.currentDraggableState.node : void 0) !== this.node) {
        this.emit("drop", e);
        return false;
      }
    };

    DroppableState.prototype.destroy = function() {
      this.node.removeEventListener("mousemove", this.onMove);
      this.node.removeEventListener("mouseup", this.onUp);
      this.node = null;
      return this.parent = null;
    };

    return DroppableState;

  })(Leaf.EventEmitter);

  DraggableState = (function(superClass) {
    extend(DraggableState, superClass);

    function DraggableState(node1, parent) {
      this.node = node1;
      this.parent = parent;
      DraggableState.__super__.constructor.call(this);
      this.onMove = this._onMove.bind(this);
      this.onDown = this._onDown.bind(this);
      this.node.onmousemove = this.onMove;
      this.node.onmousedown = this.onDown;
      this.node.addEventListener("mousemove", this.onMove, true);
      this.node.addEventListener("mousedown", this.onDown, true);
      this.session = {};
    }

    DraggableState.prototype._onMove = function(e) {
      var ref;
      if ((ref = this.parent) != null ? ref.currentDraggableState : void 0) {
        return true;
      }
      return this.emit("move", e);
    };

    DraggableState.prototype._onDown = function(e) {
      var ref;
      if (e.which !== 1) {
        return;
      }
      e.draggable = this.node;
      if ((ref = this.parent) != null ? ref.currentDraggableState : void 0) {
        return;
      }
      e.stopImmediatePropagation();
      e.preventDefault();
      return this.emit("start", e);
    };

    DraggableState.prototype.destroy = function() {
      this.node.removeEventListener("mousemove", this.onMove);
      this.node.removeEventListener("mousedown", this.onDown);
      this.node = null;
      return this.parent = null;
    };

    return DraggableState;

  })(Leaf.EventEmitter);

  module.exports = DragContext;

}).call(this);

}
GlobalContext.setModule("component/dragContext.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/dragManager.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DragEventBehavior, DragManager, DragSession, DragShadowManager, MouseEventHelper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DragManager = (function(superClass) {
    extend(DragManager, superClass);

    function DragManager() {
      DragManager.__super__.constructor.call(this);
      this.mouseupListener = this.mouseupListener.bind(this);
      this.mousedownListener = this.mousedownListener.bind(this);
      this.mousemoveListener = this.mousemoveListener.bind(this);
      new DragEventBehavior(this);
      new DragShadowManager(this);
      new MouseEventHelper(this);
      this.init();
      this.minMovement = 6;
    }

    DragManager.prototype.init = function() {
      var capture;
      capture = true;
      window.addEventListener("mousedown", this.mouseupListener, capture);
      window.addEventListener("mouseup", this.mouseupListener, capture);
      window.addEventListener("mousemove", this.mousemoveListener, capture);
      this.reset();
      return this.setState("waitMouseDown");
    };

    DragManager.prototype.destroy = function() {
      this.reset();
      window.removeEventListener("mouseup", this.mouseupListener);
      window.removeEventListener("mousedown", this.mousedownListener);
      return window.removeEventListener("mousemove", this.mousemoveListener);
    };

    DragManager.prototype.reset = function() {
      DragManager.__super__.reset.call(this);
      return this.clearDrag();
    };

    DragManager.prototype.mouseupListener = function(e) {
      this.lastMouseEvent = e;
      return this.feed("mouse", e);
    };

    DragManager.prototype.mousedownListener = function(e) {
      this.lastMouseEvent = e;
      return this.feed("mouse", e);
    };

    DragManager.prototype.mousemoveListener = function(e) {
      this.lastMouseEvent = e;
      return this.feed("mouse", e);
    };

    DragManager.prototype.atWaitMouseDown = function() {
      this.clearDrag();
      return this.consumeWhenAvailable("mouse", (function(_this) {
        return function(e) {
          if (e.type === "mousedown") {
            _this.data.initMouseDown = e;
            return _this.setState("waitInitMouseMove");
          } else {
            return _this.setState("waitMouseDown");
          }
        };
      })(this));
    };

    DragManager.prototype.atWaitInitMouseMove = function() {
      return this.consumeWhenAvailable("mouse", (function(_this) {
        return function(e) {
          if (e.type === "mousemove") {
            if (_this.getMouseDistance(e, _this.data.initMouseDown) < _this.minMovement) {
              return _this.setState("waitInitMouseMove");
            } else {
              _this.data.initMoveEvent = e;
              return _this.setState("handleInitMove");
            }
          } else {
            return _this.setState("waitMouseDown");
          }
        };
      })(this));
    };

    DragManager.prototype.atHandleInitMove = function() {
      if (!this.dragStart(this.data.initMouseDown)) {
        this.setState("waitMouseDown");
        return;
      }
      return this.setState("waitMouseContinue");
    };

    DragManager.prototype.atWaitMouseContinue = function() {
      return this.consumeWhenAvailable("mouse", (function(_this) {
        return function(e) {
          if (e.type === "mousemove") {
            _this.dragMove(e);
            return _this.setState("waitMouseContinue");
          } else if (e.type === "mouseup") {
            _this.data.finalUpEvent = e;
            return _this.setState("handleMouseUp");
          } else {
            return _this.setState("waitMouseDown");
          }
        };
      })(this));
    };

    DragManager.prototype.atHandleMouseUp = function() {
      this.drop(this.data.finalUpEvent);
      return this.setState("waitMouseDown");
    };

    return DragManager;

  })(Leaf.States);

  MouseEventHelper = (function(superClass) {
    extend(MouseEventHelper, superClass);

    function MouseEventHelper() {
      return MouseEventHelper.__super__.constructor.apply(this, arguments);
    }

    MouseEventHelper.prototype.computeRelativeMousePosition = function(el, e) {
      var rect, src;
      src = this.getMouseSrc(e);
      if (!el.contains(src)) {
        return null;
      }
      rect = el.getBoundingClientRect();
      return {
        x: rect.left - e.clientX,
        y: rect.top - e.clientY
      };
    };

    MouseEventHelper.prototype.getMousePosition = function(e) {
      if (!e) {
        return null;
      }
      return {
        x: e.clientX,
        y: e.clientY
      };
    };

    MouseEventHelper.prototype.getMouseDistance = function(e1, e2) {
      var dx, dy, p1, p2;
      p1 = this.getMousePosition(e1);
      p2 = this.getMousePosition(e2);
      dx = p1.x - p2.x;
      dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    };

    MouseEventHelper.prototype.getDefaultShadow = function(el) {
      var copy, domCopy, prop;
      domCopy = require("/component/domCopy");
      copy = domCopy(el);
      for (prop in copy.style) {
        if (!prop) {
          delete copy.style;
        }
      }
      copy.style.opacity = 0.5;
      copy.style.backgroundColor = "white";
      copy.style.pointerEvents = "none";
      copy.style.transition = "opacity 200ms";
      copy.style.webkitTransfrom = "scale(0.7)";
      window.cpyy = copy;
      return copy;
    };

    MouseEventHelper.prototype.getMouseSrc = function(e) {
      return e.srcElement || e.target;
    };

    MouseEventHelper.prototype.isElementDraggable = function(el) {
      return el && (el.dragSupport === "support" || el.getAttribute("drag-support") === "support");
    };

    MouseEventHelper.prototype.isElementDragless = function(el) {
      return !el || el.dragSupport === "disable" || el.getAttribute("drag-support") === "disable";
    };

    MouseEventHelper.prototype.getDraggable = function(e) {
      var el;
      el = this.getMouseSrc(e);
      while (el) {
        if (this.isElementDragless(el)) {
          return null;
        } else if (this.isElementDraggable(el)) {
          return el;
        }
        el = el.parentElement;
      }
    };

    MouseEventHelper.prototype.createCustomEvent = function(name, data) {
      return new CustomEvent(name, data);
    };

    return MouseEventHelper;

  })(Leaf.Trait);

  DragShadowManager = (function(superClass) {
    extend(DragShadowManager, superClass);

    function DragShadowManager() {
      return DragShadowManager.__super__.constructor.apply(this, arguments);
    }

    DragShadowManager.prototype.dragFix = {
      x: 0,
      y: 0
    };

    DragShadowManager.prototype.shadowScale = 0.7;

    DragShadowManager.prototype.clearShadow = function() {
      var ref, ref1;
      if ((ref = this.draggingShadow) != null ? ref.parentElement : void 0) {
        if ((ref1 = this.draggingShadow) != null) {
          ref1.parentElement.removeChild(this.draggingShadow);
        }
      }
      return this.draggingShadow = null;
    };

    DragShadowManager.prototype.setShadowElement = function(el, fix) {
      var base, base1, ref, ref1;
      if (fix == null) {
        fix = {};
      }
      if ((ref = this.draggingShadow) != null ? ref.parentElement : void 0) {
        if ((ref1 = this.draggingShadow) != null) {
          ref1.parentElement.removeChild(this.draggingShadow);
        }
      }
      this.draggingShadow = el;
      document.body.appendChild(el);
      el.style.position = "absolute";
      el.style.pointerEvents = "none";
      el.style.top = "0";
      el.style.left = "0";
      el.style.zIndex = 100000;
      this.dragFix = fix || {};
      if ((base = this.dragFix).x == null) {
        base.x = 0;
      }
      if ((base1 = this.dragFix).y == null) {
        base1.y = 0;
      }
      return this.updateShadowPosition();
    };

    DragShadowManager.prototype.updateShadowPosition = function() {
      var point, ref, ref1, ref2, ref3, scaleFix, transform, transformOrigin;
      if (!this.draggingShadow) {
        return;
      }
      point = this.getMousePosition(this.lastMouseEvent);
      this.shadowScale = 0.7;
      scaleFix = this.shadowScale;
      transform = "translateX(" + (point.x + this.dragFix.x * scaleFix) + "px) translateY(" + (point.y + this.dragFix.y * scaleFix) + "px) scale(" + this.shadowScale + ")";
      transformOrigin = "top left";
      if ((ref = this.draggingShadow.style) != null) {
        ref.transform = transform;
      }
      if ((ref1 = this.draggingShadow.style) != null) {
        ref1.webkitTransform = transform;
      }
      if ((ref2 = this.draggingShadow.style) != null) {
        ref2.transformOrigin = transformOrigin;
      }
      return (ref3 = this.draggingShadow.style) != null ? ref3.webkitTransformOrigin = transformOrigin : void 0;
    };

    DragShadowManager.prototype.setDraggingStyle = function() {
      if (this._setTarget) {
        this.restoreDraggingstyle();
      }
      this._setTarget = this.draggingElement;
      this._opacity = this._setTarget.style.opacity;
      this._transition = this._setTarget.style.transition;
      this._setTarget.style.opacity = 0.15;
      return this._setTarget.style.transition = "all 200ms";
    };

    DragShadowManager.prototype.restoreDraggingstyle = function() {
      var ref, ref1;
      if ((ref = this._setTarget) != null) {
        ref.style.opacity = this._opacity;
      }
      if ((ref1 = this._setTarget) != null) {
        ref1.style.transition = this._transition;
      }
      return this._setTarget = null;
    };

    return DragShadowManager;

  })(Leaf.Trait);

  DragEventBehavior = (function(superClass) {
    extend(DragEventBehavior, superClass);

    function DragEventBehavior() {
      return DragEventBehavior.__super__.constructor.apply(this, arguments);
    }

    DragEventBehavior.prototype.initialize = function() {
      var preventDefault;
      preventDefault = function(e) {
        e.preventDefault();
        return e.stopImmediatePropagation();
      };
      this.__defineGetter__("draggingElement", (function(_this) {
        return function() {
          return _this._draggingElement;
        };
      })(this));
      return this.__defineSetter__("draggingElement", (function(_this) {
        return function(v) {
          var _draggingElement;
          if (v === _this._draggingElement) {
            return;
          }
          if (_this._draggingElement) {
            _draggingElement = _this._draggingElement;
            setTimeout(function() {
              return _draggingElement.removeEventListener("click", preventDefault, true);
            }, 1);
          }
          _this._draggingElement = v;
          if (!v) {
            return;
          }
          return _this._draggingElement.addEventListener("click", preventDefault, true);
        };
      })(this));
    };

    DragEventBehavior.prototype.clearDrag = function() {
      this.clearShadow();
      this.draggingElement = null;
      return document.body.classList.remove("dragging");
    };

    DragEventBehavior.prototype.dragStart = function(e) {
      var event, src;
      src = this.getDraggable(e);
      this.clearDrag();
      if (!src) {
        return false;
      }
      document.body.classList.add("dragging");
      this.dragSession = new DragSession(this);
      this.currentDraggable = src;
      event = this.createCustomEvent("user-draginit", {
        detail: this.dragSession,
        bubbles: true
      });
      src.dispatchEvent(event);
      this.draggingElement = src;
      if (this.draggingElement.dragBehavior === "auto" || this.draggingElement.getAttribute("dragBehavior") === "auto") {
        this.shadowScale = 0.7;
        this.setDraggingStyle();
        this.setShadowElement(this.getDefaultShadow(this.draggingElement), this.computeRelativeMousePosition(src, e));
      }
      return true;
    };

    DragEventBehavior.prototype.dragMove = function(e) {
      var event, i, len, protocol, ref, ref1, target;
      event = this.createCustomEvent("user-dragging", {
        detail: this.dragSession,
        bubbles: true
      });
      if ((ref = this.draggingElement) != null) {
        ref.dispatchEvent(event);
      }
      target = this.getMouseSrc(e);
      event = this.createCustomEvent("user-dropstand", {
        detail: this.dragSession,
        bubbles: true
      });
      if (target != null) {
        target.dispatchEvent(event);
      }
      if (!event.defaultPrevented) {
        ref1 = this.dragSession.protocols;
        for (i = 0, len = ref1.length; i < len; i++) {
          protocol = ref1[i];
          event = this.createCustomEvent("user-dropstand/" + protocol.type, {
            detail: protocol,
            bubbles: true
          });
          target.dispatchEvent(event);
        }
      }
      return this.updateShadowPosition();
    };

    DragEventBehavior.prototype.drop = function(e) {
      var event, i, len, protocol, ref, ref1, target;
      this.restoreDraggingstyle();
      target = this.getMouseSrc(e);
      event = this.createCustomEvent("user-drop", {
        detail: this.dragSession,
        bubbles: true
      });
      target.dispatchEvent(event);
      if (!event.defaultPrevented) {
        ref = this.dragSession.protocols;
        for (i = 0, len = ref.length; i < len; i++) {
          protocol = ref[i];
          event = this.createCustomEvent("user-drop/" + protocol.type, {
            detail: protocol,
            bubbles: true
          });
          target.dispatchEvent(event);
        }
      }
      event = this.createCustomEvent("user-dragfinish", {
        detail: this.dragSession,
        bubbles: true
      });
      if (this.draggingElement.contains(target)) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
      if ((ref1 = this.draggingElement) != null) {
        ref1.dispatchEvent(event);
      }
      this.draggingElement = null;
      return this.clearShadow();
    };

    return DragEventBehavior;

  })(Leaf.Trait);

  DragSession = (function() {
    function DragSession(behavior) {
      this.behavior = behavior;
      this.protocols = [];
      this.__defineGetter__("protocol", (function(_this) {
        return function() {
          return _this.protocols[0];
        };
      })(this));
    }

    DragSession.prototype.addProtocol = function(type, data) {
      var protocol;
      protocol = new DragManager.Protocol(type, data);
      return this.protocols.push(protocol);
    };

    return DragSession;

  })();

  DragManager.Protocol = (function() {
    Protocol.prototype.type = "Void";

    Protocol.prototype.data = null;

    function Protocol(type1, data1) {
      this.type = type1;
      this.data = data1;
    }

    return Protocol;

  })();

  module.exports = DragManager;

}).call(this);

}
GlobalContext.setModule("component/dragManager.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/endlessLoadingBehavior.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var AnimationFrame, BufferedEndlessLoader, EndlessLoadingBehavior,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BufferedEndlessLoader = require("./bufferedEndlessLoader");

  AnimationFrame = require("./animationFrame");

  EndlessLoadingBehavior = (function(superClass) {
    extend(EndlessLoadingBehavior, superClass);

    function EndlessLoadingBehavior() {
      this.loader = new BufferedEndlessLoader();
      this.limit = 20;
      this.bufferLimit = 40;
      this.instantLoadCount = 1;
      this.loader.listenBy(this, "startLoading", (function(_this) {
        return function() {
          return _this.onStartLoading();
        };
      })(this));
      this.loader.listenBy(this, "endLoading", (function(_this) {
        return function() {
          return _this.onEndLoading();
        };
      })(this));
      this.itemInterval = 0;
      EndlessLoadingBehavior.__super__.constructor.call(this);
    }

    EndlessLoadingBehavior.prototype.onStartLoading = function() {
      return this.emit("startLoading");
    };

    EndlessLoadingBehavior.prototype.onEndLoading = function() {
      return this.emit("endLoading");
    };

    EndlessLoadingBehavior.prototype.onDrain = function() {
      return this.emit("drain");
    };

    EndlessLoadingBehavior.prototype.onFetch = function(last, offset, limit, callback) {
      return setTimeout((function(_this) {
        return function() {
          return callback(null, []);
        };
      })(this), 0);
    };

    EndlessLoadingBehavior.prototype.push = function() {
      return null;
    };

    EndlessLoadingBehavior.prototype.handlePanic = function() {
      return false;
    };

    EndlessLoadingBehavior.prototype.checkRequireMore = function() {
      return false;
    };

    EndlessLoadingBehavior.prototype.reset = function() {
      EndlessLoadingBehavior.__super__.reset.call(this);
      return this.loader.reset();
    };

    EndlessLoadingBehavior.prototype.start = function() {
      if (this.state === "void") {
        return this.setState("init");
      }
    };

    EndlessLoadingBehavior.prototype.atInit = function() {
      this.loader.reset();
      this.loader.setLoadDelegator(this.onFetch.bind(this));
      this.loader.limit = this.limit;
      this.loader.bufferLimit = this.bufferLimit;
      return this.setState("decideLoadMore");
    };

    EndlessLoadingBehavior.prototype.recoverToLoad = function() {
      if (this.state !== "panic") {
        return false;
      }
      this.recover();
      this.setState("loadMore");
      return true;
    };

    EndlessLoadingBehavior.prototype.recoverToDecide = function() {
      if (this.state !== "panic") {
        return false;
      }
      this.recover();
      this.setState("decideLoadMore");
      return true;
    };

    EndlessLoadingBehavior.prototype.atPanic = function() {
      return this.handlePanic();
    };

    EndlessLoadingBehavior.prototype.atLoadMore = function(stale) {
      this.loader.start();
      return this.loader.get(this.instantLoadCount, (function(_this) {
        return function(err, items) {
          if (stale()) {
            return;
          }
          if (err) {
            _this.error(err);
            return;
          }
          return AnimationFrame.nextFrame(function() {
            var i, item, len;
            if (stale()) {
              return;
            }
            for (i = 0, len = items.length; i < len; i++) {
              item = items[i];
              _this.push(item);
            }
            if (_this.loader.isDrain) {
              _this.setState("drain");
              return;
            }
            return _this.setState("decideLoadMore");
          });
        };
      })(this));
    };

    EndlessLoadingBehavior.prototype.atDecideLoadMore = function(stale) {
      var action;
      clearTimeout(this._decideTimer);
      action = (function(_this) {
        return function() {
          if (stale()) {
            return;
          }
          if (_this.loader.isDrain) {
            _this.setState("drain");
            return;
          }
          if (_this.checkRequireMore()) {
            _this.setState("loadMore");
            return true;
          }
          return _this.setState("wait");
        };
      })(this);
      if (this.itemInterval) {
        return this._decideTimer = setTimeout((function(_this) {
          return function() {
            return action();
          };
        })(this), this.itemInterval);
      } else {
        return action();
      }
    };

    EndlessLoadingBehavior.prototype.atWait = function() {
      this.consumeWhenAvailable("moreSignal", (function(_this) {
        return function() {
          while (_this.consume("moreSignal")) {
            continue;
          }
          return _this.setState("loadMore");
        };
      })(this));
      return this.consumeWhenAvailable("checkSignal", (function(_this) {
        return function() {
          while (_this.consume("checkSignal")) {
            continue;
          }
          return _this.setState("decideLoadMore");
        };
      })(this));
    };

    EndlessLoadingBehavior.prototype.atDrain = function() {
      return this.onDrain();
    };

    return EndlessLoadingBehavior;

  })(Leaf.States);

  module.exports = EndlessLoadingBehavior;

}).call(this);

}
GlobalContext.setModule("component/endlessLoadingBehavior.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/fastclick.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    ;(function () {
	//'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};


	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {

		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	} else {
		window.FastClick = FastClick;
	}
}());

}
GlobalContext.setModule("component/fastclick.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/fullscreen.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var SharedCallbacks, screenreset;

  screenreset = function(e) {
    var base;
    if (!module.exports.isFullscreen() && module.exports.currentFullScreenElement) {
      module.exports.currentFullScreenElement.classList.remove("fullscreen");
      module.exports.currentFullScreenElement = null;
      if (typeof (base = module.exports).currentFullScreenCallback === "function") {
        base.currentFullScreenCallback();
      }
    }
    if (module.exports.isFullscreen()) {
      return module.exports.fullscreenOnCallback();
    } else {
      return module.exports.fullscreenOffCallback();
    }
  };

  window.addEventListener("webkitfullscreenchange", screenreset);

  window.addEventListener("mozfullscreenchange", screenreset);

  window.addEventListener("fullscreenchange", screenreset);

  SharedCallbacks = require("./sharedCallbacks");

  module.exports = {
    fullscreenOnCallback: SharedCallbacks.create(),
    fullscreenOffCallback: SharedCallbacks.create(),
    canFullscreen: function() {
      var body;
      body = document.body;
      return body.requestFullScreen || body.webkitRequestFullscreen || body.mozRequestFullScreen || body.msRequestFullscreen && true || false;
    },
    requestElementFullscreen: function(el, callback) {
      var i, len, method, ref;
      if (callback == null) {
        callback = function() {};
      }
      if (this.currentFullScreenElement) {
        return false;
      }
      ref = ["requestFullScreen", "webkitRequestFullscreen", "mozRequestFullScreen", "msRequestFullscreen"];
      for (i = 0, len = ref.length; i < len; i++) {
        method = ref[i];
        if (el[method]) {
          el.classList.add("fullscreen");
          this.currentFullScreenElement = el;
          this.currentFullScreenCallback = callback;
          el[method]();
          return true;
        }
      }
      return false;
    },
    onceFullscreenOn: function(callback) {
      return this.fullscreenOnCallback.push(callback);
    },
    onceFullscreenOff: function(callback) {
      return this.fullscreenOffCallback.push(callback);
    },
    isFullscreen: function() {
      return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement && true || false;
    }
  };

}).call(this);

}
GlobalContext.setModule("component/fullscreen.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/gridListReflower.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var GridListReflower;

  GridListReflower = (function() {
    GridListReflower.prototype.itemSize = {
      width: 180,
      height: 240,
      itemMargin: 12,
      sideMargin: 12,
      itemMarginTop: 12
    };

    function GridListReflower(list, itemSize1) {
      this.list = list;
      this.itemSize = itemSize1;
      this.node$ = this.list.node$;
      window.addEventListener("resize", (function(_this) {
        return function() {
          return _this.reflow();
        };
      })(this));
    }

    GridListReflower.prototype.setItemSize = function(itemSize1) {
      this.itemSize = itemSize1;
    };

    GridListReflower.prototype.parsePercentageItemSize = function(fullWidth, itemSize1) {
      var heightPercentage, isHeightPercentage, itemSize, k, n, ref, v, width;
      this.itemSize = itemSize1;
      itemSize = {};
      isHeightPercentage = false;
      heightPercentage = 0;
      if (!(fullWidth > 0)) {
        return this.itemSize;
      }
      ref = this.itemSize;
      for (k in ref) {
        v = ref[k];
        if ((typeof v === "string") && v.match(/[0-9]+%$/)) {
          v = parseInt(v.replace('%', ''), 10);
          if (k === "width") {
            n = Math.floor(100 / v);
            width = Math.floor(1 / n * (fullWidth - this.itemSize.itemMargin * 2 - this.itemSize.itemMargin * (n - 1)));
            itemSize.width = width;
          } else if (k === "height") {
            isHeightPercentage = true;
            heightPercentage = v;
          }
        } else {
          itemSize[k] = v;
        }
      }
      if (isHeightPercentage) {
        itemSize.height = Math.round(itemSize.width * heightPercentage / 100);
      }
      return itemSize;
    };

    GridListReflower.prototype.reflow = function() {
      var fullWidth, i, index, item, len, n, ref, x, y;
      fullWidth = this.node$.width();
      this.itemSize = this.parsePercentageItemSize(fullWidth, this.itemSize);
      n = (fullWidth - 2 * this.itemSize.sideMargin + this.itemSize.itemMargin) / (this.itemSize.width + this.itemSize.itemMargin);
      n = Math.floor(n);
      this.sideMargin = (fullWidth - n * this.itemSize.width - (n - 1) * this.itemSize.itemMargin) / 2;
      this.itemMargin = this.itemSize.itemMargin;
      this.itemPerRow = n;
      ref = this.list;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        x = index % n;
        y = Math.floor(index / n);
        this.setItemGeometry(item, x, y);
      }
      return this.applyHeight();
    };

    GridListReflower.prototype.reflowByItemMargin = function() {
      var fullWidth, i, index, item, len, n, ref, results, x, y;
      fullWidth = this.node$.width();
      this.itemSize = this.parsePercentageItemSize(fullWidth, this.itemSize);
      n = (fullWidth - 2 * this.itemSize.sideMargin + this.itemSize.itemMargin) / (this.itemSize.width + this.itemSize.itemMargin);
      n = Math.floor(n);
      if (n === 1) {
        this.itemMargin = 0;
      } else {
        this.itemMargin = (fullWidth - 2 * this.itemSize.sideMargin - n * this.itemSize.width) / (n - 1);
      }
      this.sideMargin = this.itemSize.sideMargin;
      this.itemPerRow = n;
      ref = this.list;
      results = [];
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        x = index % n;
        y = Math.floor(index / n);
        results.push(this.setItemGeometry(item, x, y));
      }
      return results;
    };

    GridListReflower.prototype.setItemGeometry = function(item, x, y) {
      var hash;
      hash = JSON.stringify([x, y, this.itemMargin, this.sideMargin, this.itemSize]);
      if (item.hash === hash) {
        return;
      }
      item.hash = hash;
      return item.node$.css({
        left: this.sideMargin + x * (this.itemMargin + this.itemSize.width),
        top: (this.itemSize.itemMarginTop + this.itemSize.height) * y,
        width: this.itemSize.width,
        height: this.itemSize.height,
        position: "absolute"
      });
    };

    GridListReflower.prototype.removeItem = function(item) {
      this.list.removeItem(item);
      return this.reflow();
    };

    GridListReflower.prototype.push = function(item) {
      var index;
      if (!this.itemPerRow) {
        this.reflow();
      }
      this.list.push(item);
      index = this.list.length - 1;
      this.setItemGeometry(item, index % this.itemPerRow, Math.floor(index / this.itemPerRow));
      return this.applyHeight();
    };

    GridListReflower.prototype.unshift = function(item) {
      return this.list.unshift(item);
    };

    GridListReflower.prototype.applyHeight = function() {
      var height;
      height = Math.ceil(this.list.length / this.itemPerRow) * (this.itemSize.height + this.itemSize.itemMarginTop);
      return this.node$.css({
        height: height
      });
    };

    return GridListReflower;

  })();

  module.exports = GridListReflower;

}).call(this);

}
GlobalContext.setModule("component/gridListReflower.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/guid.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  function createGuid() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
      .toString(16)
      .substring(1);
  }
  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
    s4() + '-' + s4() + s4() + s4();
}
;
  exports.createHex = createGuid;

}).call(this);

}
GlobalContext.setModule("component/guid.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/hash.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // This file was automatically generated from "xxhash.lmd.json"
(function (global, main, modules, modules_options, options) {
    var initialized_modules = {},
        global_eval = function (code) {
            return global.Function('return ' + code)();
        },
        
        global_document = global.document,
        local_undefined,
        /**
         * @param {String} moduleName module name or path to file
         * @param {*}      module module content
         *
         * @returns {*}
         */
        register_module = function (moduleName, module) {
            lmd_trigger('lmd-register:before-register', moduleName, module);
            // Predefine in case of recursive require
            var output = {'exports': {}};
            initialized_modules[moduleName] = 1;
            modules[moduleName] = output.exports;

            if (!module) {
                // if undefined - try to pick up module from globals (like jQuery)
                // or load modules from nodejs/worker environment
                module = lmd_trigger('js:request-environment-module', moduleName, module)[1] || global[moduleName];
            } else if (typeof module === 'function') {
                // Ex-Lazy LMD module or unpacked module ("pack": false)
                var module_require = lmd_trigger('lmd-register:decorate-require', moduleName, lmd_require)[1];

                // Make sure that sandboxed modules cant require
                if (modules_options[moduleName] &&
                    modules_options[moduleName].sandbox &&
                    typeof module_require === 'function') {

                    module_require = local_undefined;
                }

                module = module(module_require, output.exports, output) || output.exports;
            }

            module = lmd_trigger('lmd-register:after-register', moduleName, module)[1];
            return modules[moduleName] = module;
        },
        /**
         * List of All lmd Events
         *
         * @important Do not rename it!
         */
        lmd_events = {},
        /**
         * LMD event trigger function
         *
         * @important Do not rename it!
         */
        lmd_trigger = function (event, data, data2, data3) {
            var list = lmd_events[event],
                result;

            if (list) {
                for (var i = 0, c = list.length; i < c; i++) {
                    result = list[i](data, data2, data3) || result;
                    if (result) {
                        // enable decoration
                        data = result[0] || data;
                        data2 = result[1] || data2;
                        data3 = result[2] || data3;
                    }
                }
            }
            return result || [data, data2, data3];
        },
        /**
         * LMD event register function
         *
         * @important Do not rename it!
         */
        lmd_on = function (event, callback) {
            if (!lmd_events[event]) {
                lmd_events[event] = [];
            }
            lmd_events[event].push(callback);
        },
        /**
         * @param {String} moduleName module name or path to file
         *
         * @returns {*}
         */
        lmd_require = function (moduleName) {
            var module = modules[moduleName];

            var replacement = lmd_trigger('*:rewrite-shortcut', moduleName, module);
            if (replacement) {
                moduleName = replacement[0];
                module = replacement[1];
            }

            lmd_trigger('*:before-check', moduleName, module);
            // Already inited - return as is
            if (initialized_modules[moduleName] && module) {
                return module;
            }

            lmd_trigger('*:before-init', moduleName, module);

            // Lazy LMD module not a string
            if (typeof module === 'string' && module.indexOf('(function(') === 0) {
                module = global_eval(module);
            }

            return register_module(moduleName, module);
        },
        output = {'exports': {}},

        /**
         * Sandbox object for plugins
         *
         * @important Do not rename it!
         */
        sandbox = {
            'global': global,
            'modules': modules,
            'modules_options': modules_options,
            'options': options,

            'eval': global_eval,
            'register': register_module,
            'require': lmd_require,
            'initialized': initialized_modules,

            
            'document': global_document,
            
            

            'on': lmd_on,
            'trigger': lmd_trigger,
            'undefined': local_undefined
        };

    for (var moduleName in modules) {
        // reset module init flag in case of overwriting
        initialized_modules[moduleName] = 0;
    }



    main(lmd_trigger('lmd-register:decorate-require', 'main', lmd_require)[1], output.exports, output);
})/*DO NOT ADD ; !*/
(this,(function (require, exports, module) { /* wrapped by builder */
window['XXH'] = require('xxhash')
}),{
"./lib/uint32": (function (require, exports, module) { /* wrapped by builder */
/**
	C-like unsigned 32 bits integers in Javascript
	Copyright (C) 2013, Pierre Curto
	MIT license
 */
;(function (root) {

	// Local cache for typical radices
	var radixPowerCache = {
		36: UINT32( Math.pow(36, 5) )
	,	16: UINT32( Math.pow(16, 7) )
	,	10: UINT32( Math.pow(10, 9) )
	,	2:  UINT32( Math.pow(2, 30) )
	}
	var radixCache = {
		36: UINT32(36)
	,	16: UINT32(16)
	,	10: UINT32(10)
	,	2:  UINT32(2)
	}

	/**
	 *	Represents an unsigned 32 bits integer
	 * @constructor
	 * @param {Number|String|Number} low bits     | integer as a string 		 | integer as a number
	 * @param {Number|Number|Undefined} high bits | radix (optional, default=10)
	 * @return 
	 */
	function UINT32 (l, h) {
		if ( !(this instanceof UINT32) )
			return new UINT32(l, h)

		this._low = 0
		this._high = 0
		this.remainder = null
		if (typeof h == 'undefined')
			return fromNumber.call(this, l)

		if (typeof l == 'string')
			return fromString.call(this, l, h)

		fromBits.call(this, l, h)
	}

	/**
	 * Set the current _UINT32_ object with its low and high bits
	 * @method fromBits
	 * @param {Number} low bits
	 * @param {Number} high bits
	 * @return ThisExpression
	 */
	function fromBits (l, h) {
		this._low = l | 0
		this._high = h | 0

		return this
	}
	UINT32.prototype.fromBits = fromBits

	/**
	 * Set the current _UINT32_ object from a number
	 * @method fromNumber
	 * @param {Number} number
	 * @return ThisExpression
	 */
	function fromNumber (value) {
		this._low = value & 0xFFFF
		this._high = value >>> 16

		return this
	}
	UINT32.prototype.fromNumber = fromNumber

	/**
	 * Set the current _UINT32_ object from a string
	 * @method fromString
	 * @param {String} integer as a string
	 * @param {Number} radix (optional, default=10)
	 * @return ThisExpression
	 */
	function fromString (s, radix) {
		var value = parseInt(s, radix || 10)

		this._low = value & 0xFFFF
		this._high = value >>> 16

		return this
	}
	UINT32.prototype.fromString = fromString

	/**
	 * Convert this _UINT32_ to a number
	 * @method toNumber
	 * @return {Number} the converted UINT32
	 */
	UINT32.prototype.toNumber = function () {
		return (this._high << 16) | this._low
	}

	/**
	 * Convert this _UINT32_ to a string
	 * @method toString
	 * @param {Number} radix (optional, default=10)
	 * @return {String} the converted UINT32
	 */
	UINT32.prototype.toString = function (radix) {
		radix = radix || 10
		var radixUint = radixCache[radix] || new UINT32(radix)

		if ( !this.gt(radixUint) ) return this.toNumber().toString(radix)

		var self = this.clone()
		var res = new Array(32)
		for (var i = 31; i >= 0; i--) {
			self.div(radixUint)
			res[i] = self.remainder.toNumber().toString(radix)
			if ( !self.gt(radixUint) ) break
		}
		res[i-1] = self.toNumber().toString(radix)

		return res.join('')
	}

	/**
	 * Add two _UINT32_. The current _UINT32_ stores the result
	 * @method add
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.add = function (other) {
		var a00 = this._low + other._low
		var a16 = a00 >>> 16

		a16 += this._high + other._high

		this._low = a00 & 0xFFFF
		this._high = a16 & 0xFFFF

		return this
	}

	/**
	 * Subtract two _UINT32_. The current _UINT32_ stores the result
	 * @method subtract
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.subtract = function (other) {
		//TODO inline
		return this.add( other.clone().negate() )
	}

	/**
	 * Multiply two _UINT32_. The current _UINT32_ stores the result
	 * @method multiply
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.multiply = function (other) {
		/*
			a = a00 + a16
			b = b00 + b16
			a*b = (a00 + a16)(b00 + b16)
				= a00b00 + a00b16 + a16b00 + a16b16
			a16b16 overflows the 32bits
		 */
		var a16 = this._high
		var a00 = this._low
		var b16 = other._high
		var b00 = other._low

/* Removed to increase speed under normal circumstances (i.e. not multiplying by 0 or 1)
		// this == 0 or other == 1: nothing to do
		if ((a00 == 0 && a16 == 0) || (b00 == 1 && b16 == 0)) return this
		// other == 0 or this == 1: this = other
		if ((b00 == 0 && b16 == 0) || (a00 == 1 && a16 == 0)) {
			this._low = other._low
			this._high = other._high
			return this
		}
*/

		var c16, c00
		c00 = a00 * b00
		c16 = c00 >>> 16

		c16 += a16 * b00
		c16 &= 0xFFFF		// Not required but improves performance
		c16 += a00 * b16

		this._low = c00 & 0xFFFF
		this._high = c16 & 0xFFFF

		return this
	}

	/**
	 * Divide two _UINT32_. The current _UINT32_ stores the result.
	 * The remainder is made available as the _remainder_ property on
	 * the _UINT32_ object. It can be null, meaning there are no remainder.
	 * @method div
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.div = function (other) {
		if ( (other._low == 0) && (other._high == 0) ) throw Error('division by zero')

		// other == 1
		if (other._high == 0 && other._low == 1) {
			this.remainder = new UINT32(0)
			return this
		}

		// other > this: 0
		if ( other.gt(this) ) {
			this.remainder = new UINT32(0)
			this._low = 0
			this._high = 0
			return this
		}
		// other == this: 1
		if ( this.eq(other) ) {
			this.remainder = new UINT32(0)
			this._low = 1
			this._high = 0
			return this
		}

		// Shift the divisor left until it is higher than the dividend
		var _other = other.clone()
		var i = -1
		while ( !this.lt(_other) ) {
			// High bit can overflow the default 16bits
			// Its ok since we right shift after this loop
			// The overflown bit must be kept though
			_other.shiftLeft(1, true)
			i++
		}

		// Set the remainder
		this.remainder = this.clone()
		// Initialize the current result to 0
		this._low = 0
		this._high = 0
		for (; i >= 0; i--) {
			_other.shiftRight(1)
			// If shifted divisor is smaller than the dividend
			// then subtract it from the dividend
			if ( !this.remainder.lt(_other) ) {
				this.remainder.subtract(_other)
				// Update the current result
				if (i >= 16) {
					this._high |= 1 << (i - 16)
				} else {
					this._low |= 1 << i
				}
			}
		}

		return this
	}

	/**
	 * Negate the current _UINT32_
	 * @method negate
	 * @return ThisExpression
	 */
	UINT32.prototype.negate = UINT32.prototype.not = function () {
		var v = ( ~this._low & 0xFFFF ) + 1
		this._low = v & 0xFFFF
		this._high = (~this._high + (v >>> 16)) & 0xFFFF

		return this
	}

	/**
	 * Equals
	 * @method eq
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.equals = UINT32.prototype.eq = function (other) {
		return (this._low == other._low) && (this._high == other._high)
	}

	/**
	 * Greater than (strict)
	 * @method gt
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.greaterThan = UINT32.prototype.gt = function (other) {
		if (this._high > other._high) return true
		if (this._high < other._high) return false
		return this._low > other._low
	}

	/**
	 * Less than (strict)
	 * @method lt
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.lessThan = UINT32.prototype.lt = function (other) {
		if (this._high < other._high) return true
		if (this._high > other._high) return false
		return this._low < other._low
	}

	/**
	 * Bitwise OR
	 * @method or
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.or = function (other) {
		this._low |= other._low
		this._high |= other._high

		return this
	}

	/**
	 * Bitwise AND
	 * @method and
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.and = function (other) {
		this._low &= other._low
		this._high &= other._high

		return this
	}

	/**
	 * Bitwise XOR
	 * @method xor
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.xor = function (other) {
		this._low ^= other._low
		this._high ^= other._high

		return this
	}

	/**
	 * Bitwise shift right
	 * @method shiftRight
	 * @param {Number} number of bits to shift
	 * @return ThisExpression
	 */
	UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function (n) {
		if (n > 16) {
			this._low = this._high >> (n - 16)
			this._high = 0
		} else if (n == 16) {
			this._low = this._high
			this._high = 0
		} else {
			this._low = (this._low >> n) | ( (this._high << (16-n)) & 0xFFFF )
			this._high >>= n
		}

		return this
	}

	/**
	 * Bitwise shift left
	 * @method shiftLeft
	 * @param {Number} number of bits to shift
	 * @param {Boolean} allow overflow
	 * @return ThisExpression
	 */
	UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function (n, allowOverflow) {
		if (n > 16) {
			this._high = this._low << (n - 16)
			this._low = 0
			if (!allowOverflow) {
				this._high &= 0xFFFF
			}
		} else if (n == 16) {
			this._high = this._low
			this._low = 0
		} else {
			this._high = (this._high << n) | (this._low >> (16-n))
			this._low = (this._low << n) & 0xFFFF
			if (!allowOverflow) {
				// Overflow only allowed on the high bits...
				this._high &= 0xFFFF
			}
		}

		return this
	}

	/**
	 * Bitwise rotate left
	 * @method rotl
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function (n) {
		var v = (this._high << 16) | this._low
		v = (v << n) | (v >>> (32 - n))
		this._low = v & 0xFFFF
		this._high = v >>> 16

		return this
	}

	/**
	 * Bitwise rotate right
	 * @method rotr
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT32.prototype.rotateRight = UINT32.prototype.rotr = function (n) {
		var v = (this._high << 16) | this._low
		v = (v >>> n) | (v << (32 - n))
		this._low = v & 0xFFFF
		this._high = v >>> 16

		return this
	}

	/**
	 * Clone the current _UINT32_
	 * @method clone
	 * @return {Object} cloned UINT32
	 */
	UINT32.prototype.clone = function () {
		return new UINT32(this._low, this._high)
	}

	if (typeof define != 'undefined' && define.amd) {
		// AMD / RequireJS
		define([], function () {
			return UINT32
		})
	} else if (typeof module != 'undefined' && module.exports) {
		// Node.js
		module.exports = UINT32
	} else {
		// Browser
		root['UINT32'] = UINT32
	}

})(this)
}),
"cuint": (function (require, exports, module) { /* wrapped by builder */
exports.UINT32 = require('./lib/uint32')
exports.UINT64 = require('./lib/uint64')
}),
"xxhash": (function (require, exports, module) { /* wrapped by builder */
/**
	xxHash implementation in pure Javascript
	Copyright (C) 2013, Pierre Curto
	MIT license
 */
;(function (root) {

	var UINT32 = require('cuint').UINT32

	/*
		Merged this sequence of method calls as it speeds up
		the calculations by a factor of 2
	 */
	// this.v1.add( other.multiply(PRIME32_2) ).rotl(13).multiply(PRIME32_1);
	UINT32.prototype.xxh_update = function (low, high) {
		var b00 = PRIME32_2._low
		var b16 = PRIME32_2._high

		var c16, c00
		c00 = low * b00
		c16 = c00 >>> 16

		c16 += high * b00
		c16 &= 0xFFFF		// Not required but improves performance
		c16 += low * b16

		var a00 = this._low + (c00 & 0xFFFF)
		var a16 = a00 >>> 16

		a16 += this._high + (c16 & 0xFFFF)

		var v = (a16 << 16) | (a00 & 0xFFFF)
		v = (v << 13) | (v >>> 19)

		a00 = v & 0xFFFF
		a16 = v >>> 16

		b00 = PRIME32_1._low
		b16 = PRIME32_1._high

		c00 = a00 * b00
		c16 = c00 >>> 16

		c16 += a16 * b00
		c16 &= 0xFFFF		// Not required but improves performance
		c16 += a00 * b16

		this._low = c00 & 0xFFFF
		this._high = c16 & 0xFFFF
	}

	/*
	 * Constants
	 */
	var PRIME32_1 = UINT32( '2654435761' )
	var PRIME32_2 = UINT32( '2246822519' )
	var PRIME32_3 = UINT32( '3266489917' )
	var PRIME32_4 = UINT32(  '668265263' )
	var PRIME32_5 = UINT32(  '374761393' )

	var PRIME32_1plus2 = PRIME32_1.clone().add(PRIME32_2)

	/**
	* Convert string to proper UTF-8 array
	* @param str Input string
	* @returns {Uint8Array} UTF8 array is returned as uint8 array
	*/
	function toUTF8Array (str) {
		var utf8 = []
		for (var i=0, n=str.length; i < n; i++) {
			var charcode = str.charCodeAt(i)
			if (charcode < 0x80) utf8.push(charcode)
			else if (charcode < 0x800) {
				utf8.push(0xc0 | (charcode >> 6),
				0x80 | (charcode & 0x3f))
			}
			else if (charcode < 0xd800 || charcode >= 0xe000) {
				utf8.push(0xe0 | (charcode >> 12),
				0x80 | ((charcode>>6) & 0x3f),
				0x80 | (charcode & 0x3f))
			}
			// surrogate pair
			else {
				i++;
				// UTF-16 encodes 0x10000-0x10FFFF by
				// subtracting 0x10000 and splitting the
				// 20 bits of 0x0-0xFFFFF into two halves
				charcode = 0x10000 + (((charcode & 0x3ff)<<10)
				| (str.charCodeAt(i) & 0x3ff))
				utf8.push(0xf0 | (charcode >>18),
				0x80 | ((charcode>>12) & 0x3f),
				0x80 | ((charcode>>6) & 0x3f),
				0x80 | (charcode & 0x3f))
			}
		}

		return new Uint8Array(utf8)
	}

	/**
	 * XXH object used as a constructor or a function
	 * @constructor
	 * or
	 * @param {Object|String} input data
	 * @param {Number|UINT32} seed
	 * @return ThisExpression
	 * or
	 * @return {UINT32} xxHash
	 */
	function XXH () {
		if (arguments.length == 2)
			return new XXH( arguments[1] ).update( arguments[0] ).digest()

		if (!(this instanceof XXH))
			return new XXH( arguments[0] )

		init.call(this, arguments[0])
	}

	/**
	 * Initialize the XXH instance with the given seed
	 * @method init
	 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
	 * @return ThisExpression
	 */
	 function init (seed) {
		this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed)
		this.v1 = this.seed.clone().add(PRIME32_1plus2)
		this.v2 = this.seed.clone().add(PRIME32_2)
		this.v3 = this.seed.clone()
		this.v4 = this.seed.clone().subtract(PRIME32_1)
		this.total_len = 0
		this.memsize = 0
		this.memory = null

		return this
	}
	XXH.prototype.init = init

	/**
	 * Add data to be computed for the XXH hash
	 * @method update
	 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
	 * @return ThisExpression
	 */
	XXH.prototype.update = function (input) {
		var isString = typeof input == 'string'
		var isArrayBuffer

		// Convert all strings to utf-8 first (issue #5)
		if (isString) {
			input = toUTF8Array(input)
			isString = false
			isArrayBuffer = true
		}

		if (input instanceof ArrayBuffer)
		{
			isArrayBuffer = true
			input = new Uint8Array(input);
		}

		var p = 0
		var len = input.length
		var bEnd = p + len

		if (len == 0) return this

		this.total_len += len

		if (this.memsize == 0)
		{
			if (isString) {
				this.memory = ''
			} else if (isArrayBuffer) {
				this.memory = new Uint8Array(16)
			} else {
				this.memory = new Buffer(16)
			}
		}

		if (this.memsize + len < 16)   // fill in tmp buffer
		{
			// XXH_memcpy(this.memory + this.memsize, input, len)
			if (isString) {
				this.memory += input
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(0, len), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, 0, len )
			}

			this.memsize += len
			return this
		}

		if (this.memsize > 0)   // some data left from previous update
		{
			// XXH_memcpy(this.memory + this.memsize, input, 16-this.memsize);
			if (isString) {
				this.memory += input.slice(0, 16 - this.memsize)
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(0, 16 - this.memsize), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, 0, 16 - this.memsize )
			}

			var p32 = 0
			if (isString) {
				this.v1.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
				p32 += 4
				this.v2.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
				p32 += 4
				this.v3.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
				p32 += 4
				this.v4.xxh_update(
					(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
				,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
				)
			} else {
				this.v1.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
				p32 += 4
				this.v2.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
				p32 += 4
				this.v3.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
				p32 += 4
				this.v4.xxh_update(
					(this.memory[p32+1] << 8) | this.memory[p32]
				,	(this.memory[p32+3] << 8) | this.memory[p32+2]
				)
			}

			p += 16 - this.memsize
			this.memsize = 0
			if (isString) this.memory = ''
		}

		if (p <= bEnd - 16)
		{
			var limit = bEnd - 16

			do
			{
				if (isString) {
					this.v1.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
					p += 4
					this.v2.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
					p += 4
					this.v3.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
					p += 4
					this.v4.xxh_update(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					)
				} else {
					this.v1.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
					p += 4
					this.v2.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
					p += 4
					this.v3.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
					p += 4
					this.v4.xxh_update(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					)
				}
				p += 4
			} while (p <= limit)
		}

		if (p < bEnd)
		{
			// XXH_memcpy(this.memory, p, bEnd-p);
			if (isString) {
				this.memory += input.slice(p)
			} else if (isArrayBuffer) {
				this.memory.set( input.subarray(p, bEnd), this.memsize )
			} else {
				input.copy( this.memory, this.memsize, p, bEnd )
			}

			this.memsize = bEnd - p
		}

		return this
	}

	/**
	 * Finalize the XXH computation. The XXH instance is ready for reuse for the given seed
	 * @method digest
	 * @return {UINT32} xxHash
	 */
	XXH.prototype.digest = function () {
		var input = this.memory
		var isString = typeof input == 'string'
		var p = 0
		var bEnd = this.memsize
		var h32, h
		var u = new UINT32

		if (this.total_len >= 16)
		{
			h32 = this.v1.rotl(1).add( this.v2.rotl(7).add( this.v3.rotl(12).add( this.v4.rotl(18) ) ) )
		}
		else
		{
			h32  = this.seed.add( PRIME32_5 )
		}

		h32.add( u.fromNumber(this.total_len) )

		while (p <= bEnd - 4)
		{
			if (isString) {
				u.fromBits(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
			} else {
				u.fromBits(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
			}
			h32
				.add( u.multiply(PRIME32_3) )
				.rotl(17)
				.multiply( PRIME32_4 )
			p += 4
		}

		while (p < bEnd)
		{
			u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0 )
			h32
				.add( u.multiply(PRIME32_5) )
				.rotl(11)
				.multiply(PRIME32_1)
		}

		h = h32.clone().shiftRight(15)
		h32.xor(h).multiply(PRIME32_2)

		h = h32.clone().shiftRight(13)
		h32.xor(h).multiply(PRIME32_3)

		h = h32.clone().shiftRight(16)
		h32.xor(h)

		// Reset the state
		this.init( this.seed )

		return h32
	}

	if (typeof define != 'undefined' && define.amd) {
		// AMD / RequireJS
		define([], function () {
			return XXH
		})
	} else if (typeof module != 'undefined' && module.exports) {
		// Node.js
		module.exports = XXH
	} else {
		// Browser
		root['XXH'] = XXH
	}

})(this)

})
},{},{});

//By NStal
module.exports.hash = function(string,length,seed){
    if(!length){
        length = 16
    }
    if(!seed){
        seed = 0xABCD
    }
    var H = XXH(seed)
    var h = H.update(string).digest().toString(length)
    return h
}

}
GlobalContext.setModule("component/hash.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/hex.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var HEX;

  HEX = "0123456789abcdef";

  module.exports = {
    random: function(length) {
      var hex, i, index, offset, ref;
      if (length == null) {
        length = 2;
      }
      hex = "";
      for (index = i = 0, ref = length; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
        offset = Math.floor(Math.random() * 16);
        hex += HEX[offset];
      }
      return hex;
    }
  };

}).call(this);

}
GlobalContext.setModule("component/hex.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/history.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    module.exports = (function() {
    return function(option) {
        // we push h1,h2  hijack state
        // should always at h2 when every thing is finished
        // I found that browser history.back is not sync method
        //        var history = null;

        //var console = {debug:function(){}}
        // fake history for browser don't support history
        var option = option || {};
        var history = null;
        var hasHistory = !! window.history.pushState;
        var virtualLocation = document.location.toString();
        var fakeHistory = {
            pushState: function(data,title,url) {
                if(option.fake){
                    return;
                }
                if (window.history.pushState) {
                    window.history.pushState.apply(this, arguments);
                }else{
                    setLocation(url);
                }
            },
            replaceState: function() {
                if(option.fake){
                    return;
                }
                if (window.history.replaceState) {
                    window.history.replaceState.apply(this, arguments);
                }else{
                    setLocation(url);
                }
            },
            back: function() {
                if(option.fake){
                    return;
                }
                if (window.history.back) {
                    window.history.back.apply(this, arguments);
                }
            },
            forward: function() {
                if(option.fake){
                    return;
                }
                if (window.history.forward) {
                    window.history.forward.apply(this, arguments);
                }
            }
        }

        var setLocation = function(url){
            document.location;
            virtualLocation = url;
        }

        var getLocation = function(){
            if(hasHistory){
                return document.location.toString();
            }else{
                return virtualLocation || document.location.toString();
            }
        }

        if (hasHistory && !option.fake) {
            history = window.history;
        } else {
            history = fakeHistory;
        }

        // end history polly fill
        var obj = {
            stack:[]
            ,push:function(id,callback){
                this.stack.push({id:id,callback:callback});
            }
            ,unshift:function(id,callback){
                this.stack.unshift({id:id,callback:callback});
            }
            ,pop:function(){
                return this.stack.pop();
            }
            ,remove:function(id){
                this.stack = this.stack.filter(function(item){return item.id != id});
            }
            ,active:function(){
                this._tick = this.tick.bind(this);
                window.addEventListener("popstate",this._tick);
                this.debug("before recover",history.length);
                this.recoverHistoryHooks("h1");
                this.debug("after recover",history.length,history.state);
                this.isActive = true
            }
            ,deactive:function(){
                window.removeEventListener("popstate",this._tick);
                this.isActive = false
            }
            ,clearStack:function(){
                // clear stacked back button hijack
                while(this.stack.length > 0){
                    var item = this.pop();
                    if (item) {
                        try {
                            item.callback();
                        } catch (e) {
                            console.error(e);
                            console.error(e.stack);
                        }
                    }
                }
            }

            // I have to use a state machine since history.back
            // is an  async method not even has a call back to indicate me it's done
            // I have to use a state machine to track what to do
            ,stateMachineMap:{
                // hstate-hasBackButtonHook-unloadState-pushingUrl
                "h1-true-none-\\w+":"_callHookAndRecoverH2"
                ,"h1-false-none-\\w+":"_backBeforeH1AndRouting"
                ,"\\w+-\\w+-route-\\w+":"_previousRoute"
                ,"route-true-none-\\w+":"_recoverH1AndClearHooksAndRouteToCurrentUrl"
                ,"route-false-none-\\w+":"_recoverH1AndRouteToCurrentUrl"
                ,"\\w+-\\w+-h2-\\w+":"_unloadToH1"
                ,"\\w+-\\w+-h1-true":"_pushUrl"
                ,"none-\\w+-none-\\w+":"_recoverH1"
            }
            ,unloadState:"none"
            ,hstate:"none"
            ,debug:function(){
                if(!option.debug){
                    return;
                }
                var args = [].slice.call(arguments,0)
                console.debug.apply(console,args)
            }
            ,tick:function(e){
                var tickInfo = e.state || {}
                var hstate = tickInfo.hstate || "none";
                var hasBackButtonHook = this.stack.length > 0;
                var states = [hstate,hasBackButtonHook,this.unloadState,this.pushingUrl].join("-");
                //debugger;
                this.hstate = hstate;
                var mapHandler = null;

                this.debug("states",states,history.length);
                for(checker in this.stateMachineMap){
                    var reg = new RegExp(checker,"i");

                    if(reg.test(states)){
                        mapHandler = this.stateMachineMap[checker]
                    }
                }
                if(this[mapHandler]){
                    this.debug("e.state",e.state,"maps:",mapHandler);
                    return this[mapHandler]();
                }else{
                    // default action just go silent
                    console.error("unknown state",states);
                    if(option.debug){
                        this.debug("likely to be empty history")
                        this.debug("just go back...")
                        return true;
                        this.debug("prevent it to easier debug.");
                        return false;
                    }else{
                        this.debug("head of history")
                        this.emit("handless",e);
                        return false;
                        this.debug("let it go.");
                        this.emit("handless",e);
                        return true;
                    }
                }
                return false;
            }
            // Note: no callback or pop callback
            // can be excuted when not full recover to h2
            ,_callHookAndRecoverH2:function(){
                this.recoverHistoryHooks("h2");
                var handler = this.pop();
                handler.callback();
                return false;
            }
            ,_backBeforeH1AndRouting:function(){
                this.unloadState = "route"
                history.back();
                return false;
            }
            ,_recoverH1AndRouteToCurrentUrl:function(){
                this.recoverHistoryHooks("h1")
                this.emit("routeTo", getLocation());
                return false;
            }
            ,_recoverH1AndClearHooksAndRouteToCurrentUrl:function(){
                this.recoverHistoryHooks("h1");
                this.clearStack();
                this.emit("routeTo", getLocation());
                return false;
            }
            ,_unloadToH1:function(){
                this.debug("unload to h1",history.length);
                this.unloadState = "h1";
                history.back();
                return false;
            }
            ,_unloadToRoute:function(){

                this.debug("unload to route",history.length);
                this.unloadState = "route";
                history.back();
                return false;
            }
            ,_previousRoute:function(){
                this.debug("to previous route",history.length);
                this.unloadState = "none";
                history.back();
            }
            ,_pushUrl:function(){
                // this is an expectation for the above Note "no callback before recover to h2"
                // because we need to modify something before h1 and h2

                this.debug("push url",this._pushHistoryUrl,history.length);
                this.unloadState = "none";
                this.pushingUrl = false
                if(this._pushHistoryUrl){
                    history.pushState({hstate:"route"},"",this._pushHistoryUrl);
                }
                this.recoverHistoryHooks("h1");
                if(this._doneUnloadBackButton){
                    var callback = this._doneUnloadBackButton;
                    this._doneUnloadBackButton = null;
                    callback();
                }
                return false;
            }
            ,_previousRoute:function(){
                this.unloadState = "none";
                this.pushingUrl = false;
                history.back();
                return false;
            }
            ,_back:function(){
                history.back();
                return false;
            }
            ,_recoverH1:function(){
                this.recoverHistoryHooks("h1");
                return false;
            }
            ,ensure:function(url,silent){
                var urlModule = require("/lib/url").url
                var target = urlModule.parse(url)
                var current = urlModule.parse(getLocation())
                if(target.pathname === current.pathname){
                    return true;
                }
                this.goto(url,silent);
            }
            ,goto:function(url,silent){
                if(!this.isActive){
                    return;
                }
                if(this.gotoModifier){
                    url = this.gotoModifier(url)
                }
                if(this.unloadState != "none"){
                    this.debug("can't goto any where before fully unload h2");
                    return;
                }
                this._pushHistoryUrl = url;
                this._doneUnloadBackButton = function(){
                    if (silent) {
                        return;
                    }
                    this.emit("routeTo",getLocation());
                }.bind(this);
                this.unloadState = "h2";
                this.pushingUrl = true;
                history.back();
            }
            ,recoverHistoryHooks:function(from){
                if(from == "h2"){
                    history.pushState({hstate:"h2"},"",this._bhUrl || getLocation());
                }else{
                    history.pushState({hstate:"h1"},"",getLocation());
                    history.pushState({hstate:"h2"},"",this._bhUrl || getLocation());
                }
                this.hstate = "h2";
            }
            ,getLocation:function(){
                return getLocation();
            }
            ,setBackButtonHistory:function(url){
                this.debug("setBackButtonHistory",url);
                if(!this._oldUrl){
                    this._oldUrl = window.location.toString();
                    this.debug("save old",this._oldUrl,"from",url);
                }
                if(!url){
                    this.debug("recover old url",this._oldUrl);
                    history.replaceState({hstate:"h2"},"",this._oldUrl);
                    this._oldUrl = null
                    this._bhUrl = null;
                }else{
                    this._bhUrl = url;
                    history.replaceState({hstate:"h2"},"",url);
                }
            }
        }
        Leaf.EventEmitter.mixin(obj)
        return obj;
    }
})()

}
GlobalContext.setModule("component/history.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/html2markdown.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DomEl, HTMLParser, HTMLStack, _stack, flatten, htmlEntity, toMarkdown,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  HTMLParser = require("./htmlparser");

  htmlEntity = require("./htmlEntity");

  DomEl = (function() {
    function DomEl(name1, attrs, children) {
      var i, item, len;
      this.name = name1;
      if (attrs == null) {
        attrs = [];
      }
      this.children = children != null ? children : [];
      this.attrs = [];
      this.contentLength = 0;
      for (i = 0, len = attrs.length; i < len; i++) {
        item = attrs[i];
        this.attrs[item.name] = item.value;
      }
      this.name = this.name.toUpperCase();
    }

    DomEl.prototype.push = function(child) {
      child.parent = this;
      return this.children.push(child);
    };

    return DomEl;

  })();

  HTMLStack = (function() {
    function HTMLStack() {
      this.__defineGetter__("tag", (function(_this) {
        return function() {
          return _this.stack[_this.stack.length - 1];
        };
      })(this));
      this.__defineGetter__("indentString", (function(_this) {
        return function() {
          return _this.getIndentSpace(_this.indent);
        };
      })(this));
      this.inlineTags = ["a", "img", "bold", "strong", "font", "center", "italic", "span", "b", "em"];
      this.singleLineTags = ["h1", "h2", "h3", "h4", "h5", "h6", "li"];
      this.multiLineTags = ["code", "pre"];
      this.orderTags = ["li"];
      this.singleLineSplit = ["blockquote"];
      this.indentTags = ["ul", "ol"];
      this.ignoreTags = ["script", "link", "template", "meta", "header", "title", "br", "base"];
    }

    HTMLStack.prototype.escapeMarkdownUrl = function(string) {
      var _map, result;
      if (string == null) {
        string = "";
      }
      _map = {
        "(": "\\(",
        ")": "\\)",
        "\\": "\\\\"
      };
      result = string.replace(/\(|\)|\\/g, function(match) {
        return _map[match] || match;
      });
      return result;
    };

    HTMLStack.prototype.escapeMarkdownUrlContent = function(string) {
      var _map, result;
      if (string == null) {
        string = "";
      }
      if (/^!\[.*\]\(.*\)$/.test(string)) {
        return string.replace(/\n/g, "");
      }
      _map = {
        "[": "\\[",
        "]": "\\]",
        "\\": "\\\\"
      };
      result = string.replace(/\[|\]|\\/g, function(match) {
        return _map[match] || match;
      });
      return result;
    };

    HTMLStack.prototype.createTagData = function(tag, attrs, unary) {
      var _, count, data, headline, i, item, j, len, ref, url;
      for (i = 0, len = attrs.length; i < len; i++) {
        item = attrs[i];
        attrs[item.name] = item.value;
      }
      data = {
        name: tag,
        attrs: attrs,
        unary: unary,
        childTexts: [],
        children: [],
        transformContent: function(str) {
          return str;
        },
        decorationBefore: "",
        decorationAfter: "",
        marks: [],
        containMarks: function(marks) {
          var j, len1, mark;
          if (marks == null) {
            marks = [];
          }
          for (j = 0, len1 = marks.length; j < len1; j++) {
            mark = marks[j];
            if (indexOf.call(this.marks, mark) >= 0) {
              return true;
            }
          }
          return false;
        }
      };
      if (indexOf.call(this.inlineTags, tag) >= 0) {
        data.inline = true;
      } else if (indexOf.call(this.ignoreTags, tag) >= 0) {
        data.ignore = true;
      } else if (indexOf.call(this.indentTags, tag) >= 0) {
        data.indent = true;
      } else if (indexOf.call(this.singleLineTags, tag) >= 0) {
        data.singleLine = true;
      } else if (indexOf.call(this.multiLineTags, tag) >= 0) {
        data.multiLine = true;
      } else {
        data.raw = true;
      }
      if (tag === "a") {
        url = this.escapeMarkdownUrl(data.attrs.href);
        data.decorationBefore = function() {
          if (data.containMarks(["h1", "h2", "h3", "h4", "h5", "h6", "a", "li", "ul", "ol", "code", "pre", "li", "blockquote", "img"])) {
            return "";
          } else {
            return " [";
          }
        };
        data.decorationAfter = function(content, length) {
          if (data.containMarks(["h1", "h2", "h3", "h4", "h5", "h6", "a", "li", "ul", "ol", "code", "pre", "li", "blockquote", "img"])) {
            return "";
          } else {
            return "](" + url + ") ";
          }
        };
        data.transformContent = (function(_this) {
          return function(content, length) {
            if (data.containMarks(["h1", "h2", "h3", "h4", "h5", "h6", "a", "li", "ul", "ol", "code", "pre", "li", "blockquote", "img"])) {
              return content;
            }
            return _this.escapeMarkdownUrlContent(content);
          };
        })(this);
      }
      if (tag === "img") {
        if (!data.attrs.src) {
          data.markdownString = "";
        } else {
          data.markdownString = "![" + (this.escapeMarkdownUrlContent(data.attrs.alt || data.attrs.title || "")) + "](" + (this.escapeMarkdownUrl(data.attrs.src || "")) + ")";
        }
      }
      if (tag === "li") {
        data.decorationBefore = function(content) {
          if (content == null) {
            content = "";
          }
          if (content.trim().length === 0) {
            return "";
          } else {
            return "* ";
          }
        };
        data.transformContent = function(str) {
          return str.replace(/\n/, "");
        };
      }
      if (tag === "blockquote") {
        data.decorationBefore = "> ";
      }
      if (tag === "h1" || tag === "h2" || tag === "h3" || tag === "h4" || tag === "h5" || tag === "h6") {
        count = parseInt(tag[1]) || 1;
        headline = "";
        for (_ = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; _ = 0 <= ref ? ++j : --j) {
          headline += "#";
        }
        data.decorationBefore = headline + " ";
      }
      if (tag === "pre" || tag === "code") {
        data.decorationBefore = (function(_this) {
          return function() {
            if (data.containMarks(["code", "pre"])) {
              return "";
            } else {
              return "```\n";
            }
          };
        })(this);
        data.decorationAfter = (function(_this) {
          return function() {
            if (data.containMarks(["code", "pre"])) {
              return "";
            } else {
              return "\n```";
            }
          };
        })(this);
        data.transformContent = function(str) {
          if (str == null) {
            str = "";
          }
          if (data.containMarks(["code", "pre"])) {
            return str;
          } else {
            return str.replace(/```/g, "\\`\\`\\`");
          }
        };
      }
      return data;
    };

    HTMLStack.prototype.getIndentSpace = function(n) {
      var item;
      if (n == null) {
        n = 0;
      }
      return ((function() {
        var i, ref, results;
        results = [];
        for (item = i = 0, ref = n; 0 <= ref ? i < ref : i > ref; item = 0 <= ref ? ++i : --i) {
          results.push("    ");
        }
        return results;
      })()).join("");
    };

    HTMLStack.prototype.markAncestor = function(name) {
      var i, item, len, ref, results;
      ref = this.stack;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (indexOf.call(item.marks, name) < 0) {
          results.push(item.marks.push(name));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    HTMLStack.prototype.parse = function(html) {
      this.indent = 0;
      this.stack = [];
      this.disabledTagNames = ["script", "link", "style", "meta", "template", "header"];
      this.indentTagNames = ["ul", "ol"];
      this.stack.push(this.createTagData("root", [], false));
      HTMLParser(html, {
        start: (function(_this) {
          return function(tag, attrs, unary) {
            var data;
            tag = tag.toLowerCase();
            data = _this.createTagData(tag, attrs, unary);
            _this.tag.children.push(data);
            _this.markAncestor(tag);
            if (unary) {
              return _this.tag.childTexts.push(data.markdownString || "");
            } else {
              return _this.stack.push(data);
            }
          };
        })(this),
        end: (function(_this) {
          return function(tag) {
            var after, before, content, text;
            content = _this.tag.transformContent(_this.tag.childTexts.join(""));
            before = "";
            after = "";
            if (typeof _this.tag.decorationBefore === "function") {
              before = _this.tag.decorationBefore(content, _this.tag.childTexts, _this.tag.childTexts);
            } else if (typeof _this.tag.decorationBefore === "string") {
              before = _this.tag.decorationBefore;
            }
            if (typeof _this.tag.decorationAfter === "function") {
              after = _this.tag.decorationAfter(content, _this.tag.childTexts, _this.tag.childTexts);
            } else if (typeof _this.tag.decorationAfter === "string") {
              after = _this.tag.decorationAfter;
            }
            text = before + content + after;
            if (_this.tag.ignore) {
              text = "";
            } else if (_this.tag.inline) {
              text = text;
            } else if (_this.tag.singleLine) {
              text = "\n" + text.replace(/\n/g, "");
            } else {
              text = "\n" + text.replace(/\n\n+/g, "\n\n").trim() + "\n";
            }
            _this.tag.text = text;
            _this.stack.pop();
            _this.tag.childTexts.push(text);
            if (indexOf.call(_this.indentTagNames, tag) >= 0) {
              return _this.indent -= 1;
            }
          };
        })(this),
        chars: (function(_this) {
          return function(text) {
            return _this.tag.childTexts.push(htmlEntity.decode(text));
          };
        })(this)
      });
      return this.stack[0].childTexts.join("").trim();
      return "";
    };

    return HTMLStack;

  })();

  module.exports = (function(_this) {
    return function(html) {
      var items, markdown, stack;
      stack = [];
      items = [];
      HTMLParser(html, {
        start: function(tag, attrs, unary) {
          var current, el, last;
          el = new DomEl(tag, attrs);
          last = stack[stack.length - 1];
          if (!last) {
            stack.push(el);
            if (unary) {
              stack.pop();
            }
            return items.push(el);
          } else {
            stack.push(el);
            current = last;
            current.push(el);
            if (unary) {
              return stack.pop();
            }
          }
        },
        end: function(tag) {
          return stack.pop();
        },
        chars: function(text) {
          var el, last, results;
          el = new DomEl("TEXT_CONTENT", [
            {
              value: htmlEntity.decode(text),
              name: "text"
            }
          ]);
          last = stack[stack.length - 1];
          if (last) {
            last.push(el);
          } else {
            items.push(el);
          }
          el.contentLength = text.length;
          results = [];
          while (el.parent) {
            el = el.parent;
            results.push(el.contentLength += text.length);
          }
          return results;
        },
        comment: function() {}
      });
      markdown = toMarkdown(flatten(items));
      markdown = markdown.replace(/\n\n\n+/g, "\n\n").replace(/\s*/g, " ");
      return markdown = markdown.replace(new RegExp("  +", "g"), " ");
    };
  })(this);

  flatten = function(items) {
    return items;
  };

  _stack = [];

  toMarkdown = function(doms, option) {
    var _, content, count, escapeMarkdownUrl, headline, hint, href, i, item, j, len, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, result, texts;
    if (option == null) {
      option = {};
    }
    texts = [];
    count = 0;
    escapeMarkdownUrl = function(string) {
      var _map, result;
      _map = {
        "(": "\\(",
        ")": "\\)",
        "\\": "\\\\"
      };
      result = string.replace(/\(|\)|\\/g, function(match) {
        return _map[match] || match;
      });
      return result;
    };
    for (i = 0, len = doms.length; i < len; i++) {
      item = doms[i];
      _stack.push(item.name);
      if (((ref = option.filter) != null ? ref.length : void 0) > 0 && (ref1 = item.name, indexOf.call(option.filter, ref1) < 0)) {
        if (option.plainWithoutFilter) {
          option.plain = true;
        } else {
          continue;
        }
      }
      if (option.limit) {
        count += 1;
        if (count > option.limit) {
          break;
        }
      }
      if ((ref2 = item.name) === "P" || ref2 === "div") {
        texts.push(toMarkdown(item.children, option).replace(/\n+/g, "\n") + "\n\n");
      } else if ((ref3 = item.name) === "H1" || ref3 === "H2" || ref3 === "H3" || ref3 === "H4" || ref3 === "H5" || ref3 === "H6") {
        if (option.plain) {
          headline = "";
        } else {
          count = parseInt(item.name[1]) || 1;
          headline = "";
          for (_ = j = 0, ref4 = count; 0 <= ref4 ? j < ref4 : j > ref4; _ = 0 <= ref4 ? ++j : --j) {
            headline += "#";
          }
          headline += " ";
        }
        texts.push("\n" + headline + " " + (toMarkdown(item.children, option).replace(/\n/g, " ")) + "\n");
      } else if (item.name === "PRE") {
        if (option.plain) {
          texts.push((toMarkdown(item.children, option).replace(/\n/g, " ")) + "\n\n");
        } else {
          texts.push("\b```\n");
          texts.push((toMarkdown(item.children, option).replace(/`/g, "\\`")) + "\n\n");
          texts.push("\n```\n");
        }
      } else if (item.name === "QUOTE") {
        if (option.plain) {
          headline = "";
        } else {
          headline = "> ";
        }
        texts.push("> " + (toMarkdown(item.children, option).replace(/\n/g, " ")) + "\n\n");
      } else if (item.name === "TEXT_CONTENT") {
        texts.push(((ref5 = item.attrs.text) != null ? typeof ref5.trim === "function" ? ref5.trim() : void 0 : void 0) || "");
      } else if (item.name === "A") {
        if (option.plain) {
          texts.push(toMarkdown(item.children, {
            plain: true
          }));
        } else {
          hint = toMarkdown(item.children, {
            plain: true,
            limit: 1,
            plainWithoutFilter: true,
            filter: ["IMG", "TEXT_CONTENT"]
          }).trim();
          href = item.attrs.href || "";
          if ((href != null ? href.indexOf("javascript:") : void 0) === 0) {
            href = "";
          }
          href = escapeMarkdownUrl(href || "");
          if (!href && !hint) {
            texts.push("");
          } else {
            texts.push(" [" + hint + "](" + href + ") ");
          }
        }
      } else if (item.name === "SPAN") {
        texts.push(toMarkdown(item.children, option));
      } else if (item.name === "IMG") {
        content = " ![" + (item.attrs.alt || item.attrs.title || "") + "](" + (escapeMarkdownUrl(item.attrs.src || "")) + ") ";
        if (option.plain) {
          texts.push(content);
        } else {
          texts.push("\n" + content + "\n");
        }
      } else if ((ref6 = item.name) === "B" || ref6 === "STRONG") {
        texts.push(" *" + (toMarkdown(item.children, {
          plain: true
        })) + "* ");
      } else if (item.name === "BR") {
        texts.push("\n");
      } else if ((ref7 = item.name) === "SCRIPT" || ref7 === "LINK" || ref7 === "STYLE") {
        texts.push("");
      } else {
        texts.push(toMarkdown(item.children, option));
      }
    }
    result = texts.join("").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    return result;
  };

  module.exports = (function(_this) {
    return function(html) {
      var stack;
      stack = new HTMLStack();
      return stack.parse(html);
    };
  })(this);

  module.exports.isHTMLSimple = function(html) {
    var complicatedTags, e, error, meaningfulTags;
    try {
      complicatedTags = ["IMG", "VIDEO", "TABLE", "NAV"];
      meaningfulTags = ["H1", "H2", "H3", "H4", "H5", "H6", "UL", "OL", "LI"];
      HTMLParser(html, {
        start: function(tag) {
          var ref;
          if (ref = tag != null ? tag.toUpperCase() : void 0, indexOf.call(complicatedTags, ref) >= 0) {
            throw new Error("Not Simple!");
          }
        },
        chars: function() {},
        end: function() {}
      });
      return true;
    } catch (error) {
      e = error;
      Logger.error(e);
      return false;
    }
  };

}).call(this);

}
GlobalContext.setModule("component/html2markdown.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/htmlEntity.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var decodeReg, decodeTable, encodeTable, prop, regStrs, value;

  encodeTable = {
    "\"": "&quot;",
    "'": "&apos;",
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    " ": "&nbsp;",
    "": "&iexcl;",
    "": "&cent;",
    "": "&pound;",
    "": "&curren;",
    "": "&yen;",
    "": "&brvbar;",
    "": "&sect;",
    "": "&uml;",
    "": "&copy;",
    "": "&ordf;",
    "": "&laquo;",
    "": "&not;",
    "": "&shy;",
    "": "&reg;",
    "": "&macr;",
    "": "&deg;",
    "": "&plusmn;",
    "": "&sup2;",
    "": "&sup3;",
    "": "&acute;",
    "": "&micro;",
    "": "&para;",
    "": "&middot;",
    "": "&cedil;",
    "": "&sup1;",
    "": "&ordm;",
    "": "&raquo;",
    "": "&frac14;",
    "": "&frac12;",
    "": "&frac34;",
    "": "&iquest;",
    "": "&times;",
    "": "&divide;",
    "": "&Agrave;",
    "": "&Aacute;",
    "": "&Acirc;",
    "": "&Atilde;",
    "": "&Auml;",
    "": "&Aring;",
    "": "&AElig;",
    "": "&Ccedil;",
    "": "&Egrave;",
    "": "&Eacute;",
    "": "&Ecirc;",
    "": "&Euml;",
    "": "&Igrave;",
    "": "&Iacute;",
    "": "&Icirc;",
    "": "&Iuml;",
    "": "&ETH;",
    "": "&Ntilde;",
    "": "&Ograve;",
    "": "&Oacute;",
    "": "&Ocirc;",
    "": "&Otilde;",
    "": "&Ouml;",
    "": "&Oslash;",
    "": "&Ugrave;",
    "": "&Uacute;",
    "": "&Ucirc;",
    "": "&Uuml;",
    "": "&Yacute;",
    "": "&THORN;",
    "": "&szlig;",
    "": "&agrave;",
    "": "&aacute;",
    "": "&acirc;",
    "": "&atilde;",
    "": "&auml;",
    "": "&aring;",
    "": "&aelig;",
    "": "&ccedil;",
    "": "&egrave;",
    "": "&eacute;",
    "": "&ecirc;",
    "": "&euml;",
    "": "&igrave;",
    "": "&iacute;",
    "": "&icirc;",
    "": "&iuml;",
    "": "&eth;",
    "": "&ntilde;",
    "": "&ograve;",
    "": "&oacute;",
    "": "&ocirc;",
    "": "&otilde;",
    "": "&ouml;",
    "": "&oslash;",
    "": "&ugrave;",
    "": "&uacute;",
    "": "&ucirc;",
    "": "&uuml;",
    "": "&yacute;",
    "": "&thorn;",
    "": "&yuml;"
  };

  decodeTable = {};

  regStrs = [];

  for (prop in encodeTable) {
    value = encodeTable[prop];
    decodeTable[value] = prop;
    regStrs.push(value);
  }

  decodeReg = new RegExp(regStrs.join("|"), "g");

  module.exports.decode = function(string) {
    decodeReg.lastIndex = 0;
    return string.replace(decodeReg, function(match) {
      value = decodeTable[match];
      if (value) {
        return value;
      } else {
        return match;
      }
    });
  };

}).call(this);

}
GlobalContext.setModule("component/htmlEntity.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/htmlparser.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    /*
 * HTML5 Parser By Sam Blowes
 *
 * Designed for HTML5 documents
 *
 * Original code by John Resig (ejohn.org)
 * http://ejohn.org/blog/pure-javascript-html-parser/
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 *
 * ----------------------------------------------------------------------------
 * License
 * ----------------------------------------------------------------------------
 *
 * This code is triple licensed using Apache Software License 2.0,
 * Mozilla Public License or GNU Public License
 * 
 * ////////////////////////////////////////////////////////////////////////////
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 * 
 * ////////////////////////////////////////////////////////////////////////////
 * 
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * 
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * The Original Code is Simple HTML Parser.
 * 
 * The Initial Developer of the Original Code is Erik Arvidsson.
 * Portions created by Erik Arvidssson are Copyright (C) 2004. All Rights
 * Reserved.
 * 
 * ////////////////////////////////////////////////////////////////////////////
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * ----------------------------------------------------------------------------
 * Usage
 * ----------------------------------------------------------------------------
 *
 * // Use like so:
 * HTMLParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 * // or to get an XML string:
 * HTMLtoXML(htmlString);
 *
 * // or to get an XML DOM Document
 * HTMLtoDOM(htmlString);
 *
 * // or to inject into an existing document/DOM node
 * HTMLtoDOM(htmlString, document);
 * HTMLtoDOM(htmlString, document.body);
 *
 */

(function () {

    // Regular Expressions for parsing tags and attributes
    var startTag = /^<([-A-Za-z0-9_]+)((?:\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/,
	endTag = /^<\/([-A-Za-z0-9_]+)[^>]*>/,
	attr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g;
    // fix for https:=abc
    startTag = /^<([-A-Za-z0-9_]+)((?:\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*(?:\s*=\:?\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/
    // Empty Elements - HTML 5
    var empty = makeMap("area,base,basefont,br,col,frame,hr,img,input,link,meta,param,embed,command,keygen,source,track,wbr");

    // Block Elements - HTML 5
    var block = makeMap("a,address,article,applet,aside,audio,blockquote,button,canvas,center,dd,del,dir,div,dl,dt,fieldset,figcaption,figure,footer,form,frameset,h1,h2,h3,h4,h5,h6,header,hgroup,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,output,p,pre,section,script,table,tbody,td,tfoot,th,thead,tr,ul,video");

    // Inline Elements - HTML 5
    var inline = makeMap("abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var");

    // Elements that you can, intentionally, leave open
    // (and which close themselves)
    var closeSelf = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");

    // Attributes that have their values filled in disabled="disabled"
    var fillAttrs = makeMap("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");

    // Special Elements (can contain anything)
    var special = makeMap("script,style");

    var HTMLParser = this.HTMLParser = function (html, handler) {
	var index, chars, match, stack = [], last = html;
	stack.last = function () {
	    return this[this.length - 1];
	};

	while (html) {
	    chars = true;

	    // Make sure we're not in a script or style element
	    if (!stack.last() || !special[stack.last()]) {

		// Comment
		if (html.indexOf("<!--") == 0) {
		    index = html.indexOf("-->");

		    if (index >= 0) {
			if (handler.comment)
			    handler.comment(html.substring(4, index));
			html = html.substring(index + 3);
			chars = false;
		    }

		    // end tag
		} else if (html.indexOf("</") == 0) {
		    match = html.match(endTag);

		    if (match) {
			html = html.substring(match[0].length);
			match[0].replace(endTag, parseEndTag);
			chars = false;
		    }

		    // start tag
		} else if (html.indexOf("<") == 0) {
		    match = html.match(startTag);

		    if (match) {
			html = html.substring(match[0].length);
			match[0].replace(startTag, parseStartTag);
			chars = false;
		    }
		}

		if (chars) {
		    index = html.indexOf("<");

		    var text = index < 0 ? html : html.substring(0, index);
		    html = index < 0 ? "" : html.substring(index);

		    if (handler.chars)
			handler.chars(text);
		}
                console.error("S1")
	    } else {
		html = html.replace(new RegExp("([\\s\\S]*?)<\/" + stack.last() + "[^>]*>"), function (all, text) {
		    text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, "$1$2");
		    if (handler.chars)
			handler.chars(text);

		    return "";
		});

		parseEndTag("", stack.last());
                console.error("S2")
	    }

	    if (html == last)
		throw "Parse Error: " + html;
	    last = html;
	}

	// Clean up any remaining tags
	parseEndTag();

	function parseStartTag(tag, tagName, rest, unary) {
	    tagName = tagName.toLowerCase();

	    if (block[tagName]) {
		while (stack.last() && inline[stack.last()]) {
		    parseEndTag("", stack.last());
		}
	    }

	    if (closeSelf[tagName] && stack.last() == tagName) {
		parseEndTag("", tagName);
	    }

	    unary = empty[tagName] || !!unary;

	    if (!unary)
		stack.push(tagName);

	    if (handler.start) {
		var attrs = [];

		rest.replace(attr, function (match, name) {
		    var value = arguments[2] ? arguments[2] :
			arguments[3] ? arguments[3] :
			arguments[4] ? arguments[4] :
			fillAttrs[name] ? name : "";

		    attrs.push({
			name: name,
			value: value,
			escaped: value.replace(/(^|[^\\])"/g, '$1\\\"') //"
		    });
		});

		if (handler.start)
		    handler.start(tagName, attrs, unary);
	    }
	}

	function parseEndTag(tag, tagName) {
	    // If no tag name is provided, clean shop
	    if (!tagName)
		var pos = 0;

	    // Find the closest opened tag of the same type
	    else
		for (var pos = stack.length - 1; pos >= 0; pos--)
		    if (stack[pos] == tagName)
			break;

	    if (pos >= 0) {
		// Close all the open elements, up the stack
		for (var i = stack.length - 1; i >= pos; i--)
		    if (handler.end)
			handler.end(stack[i]);

		// Remove the open elements from the stack
		stack.length = pos;
	    }
	}
    };

    this.HTMLtoXML = function (html) {
	var results = "";

	HTMLParser(html, {
	    start: function (tag, attrs, unary) {
		results += "<" + tag;

		for (var i = 0; i < attrs.length; i++)
		    results += " " + attrs[i].name + '="' + attrs[i].escaped + '"';
		results += ">";
	    },
	    end: function (tag) {
		results += "</" + tag + ">";
	    },
	    chars: function (text) {
		results += text;
	    },
	    comment: function (text) {
		results += "<!--" + text + "-->";
	    }
	});

	return results;
    };

    this.HTMLtoDOM = function (html, doc) {
	// There can be only one of these elements
	var one = makeMap("html,head,body,title");

	// Enforce a structure for the document
	var structure = {
	    link: "head",
	    base: "head"
	};

	if (!doc) {
	    if (typeof DOMDocument != "undefined")
		doc = new DOMDocument();
	    else if (typeof document != "undefined" && document.implementation && document.implementation.createDocument)
		doc = document.implementation.createDocument("", "", null);
	    else if (typeof ActiveX != "undefined")
		doc = new ActiveXObject("Msxml.DOMDocument");

	} else
	    doc = doc.ownerDocument ||
	    doc.getOwnerDocument && doc.getOwnerDocument() ||
	    doc;

	var elems = [],
	    documentElement = doc.documentElement ||
	    doc.getDocumentElement && doc.getDocumentElement();

	// If we're dealing with an empty document then we
	// need to pre-populate it with the HTML document structure
	if (!documentElement && doc.createElement) (function () {
	    var html = doc.createElement("html");
	    var head = doc.createElement("head");
	    head.appendChild(doc.createElement("title"));
	    html.appendChild(head);
	    html.appendChild(doc.createElement("body"));
	    doc.appendChild(html);
	})();

	// Find all the unique elements
	if (doc.getElementsByTagName)
	    for (var i in one)
		one[i] = doc.getElementsByTagName(i)[0];

	// If we're working with a document, inject contents into
	// the body element
	var curParentNode = one.body;

	HTMLParser(html, {
	    start: function (tagName, attrs, unary) {
		// If it's a pre-built element, then we can ignore
		// its construction
		if (one[tagName]) {
		    curParentNode = one[tagName];
		    if (!unary) {
			elems.push(curParentNode);
		    }
		    return;
		}

		var elem = doc.createElement(tagName);

		for (var attr in attrs)
		    elem.setAttribute(attrs[attr].name, attrs[attr].value);

		if (structure[tagName] && typeof one[structure[tagName]] != "boolean")
		    one[structure[tagName]].appendChild(elem);

		else if (curParentNode && curParentNode.appendChild)
		    curParentNode.appendChild(elem);

		if (!unary) {
		    elems.push(elem);
		    curParentNode = elem;
		}
	    },
	    end: function (tag) {
		elems.length -= 1;

		// Init the new parentNode
		curParentNode = elems[elems.length - 1];
	    },
	    chars: function (text) {
		curParentNode.appendChild(doc.createTextNode(text));
	    },
	    comment: function (text) {
		// create comment node
	    }
	});

	return doc;
    };

    function makeMap(str) {
	var obj = {}, items = str.split(",");
	for (var i = 0; i < items.length; i++)
	    obj[items[i]] = true;
	return obj;
    }
})();
module.exports = HTMLParser

}
GlobalContext.setModule("component/htmlparser.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/imageLoader.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Errors, ImageLoader,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Errors = Leaf.ErrorDoc.create().define("Abort").generate();

  ImageLoader = (function(superClass) {
    var ChromeImageLoaderWorker, ImageLoaderWorker, Worker, ref, ref1;

    extend(ImageLoader, superClass);

    ImageLoader.Errors = Errors;

    ImageLoaderWorker = (function(superClass1) {
      extend(ImageLoaderWorker, superClass1);

      function ImageLoaderWorker() {
        ImageLoaderWorker.__super__.constructor.call(this);
        this.timeout = 1000 * 60;
      }

      ImageLoaderWorker.prototype.load = function(src1) {
        this.src = src1;
        this.isReserved = false;
        if (this.state !== "void") {
          return;
        }
        return this.setState("loading");
      };

      ImageLoaderWorker.prototype.reserve = function() {
        return this.isReserved = true;
      };

      ImageLoaderWorker.prototype.reset = function() {
        if (this.data.img) {
          this.data.img.removeAttribute("src");
        }
        if (this.isWaitingFor("giveup")) {
          this.stopWaiting("giveup");
        }
        clearTimeout(this.data.timer);
        this.removeAllListeners();
        return ImageLoaderWorker.__super__.reset.call(this);
      };

      ImageLoaderWorker.prototype.atLoading = function() {
        var img, onerror, onload;
        this.data.timeStart = Date.now();
        img = document.createElement("img");
        img.src = this.src;
        this.clear((function(_this) {
          return function() {
            img.removeEventListener("load", onload);
            img.removeEventListener("error", onerror);
            if (_this.isWaitingFor("giveup")) {
              _this.stopWaiting("giveup");
            }
            _this.data.isPending = false;
            return clearTimeout(_this.data.timer);
          };
        })(this));
        onload = (function(_this) {
          return function() {
            _this.clear();
            return _this.setState("ready");
          };
        })(this);
        onerror = (function(_this) {
          return function() {
            _this.clear();
            return _this.setState("fail");
          };
        })(this);
        this.data.timer = setTimeout((function(_this) {
          return function() {
            _this.data.isPending = true;
            _this.waitFor("giveup", function() {
              _this.clear();
              _this.data.failError = new Error("give up due to timeup to " + _this.timeout + " and someone else is waiting to load");
              return _this.setState("abort");
            });
            return _this.emit("pending");
          };
        })(this), this.timeout);
        img.addEventListener("load", onload);
        img.addEventListener("error", onerror);
        return this.data.img = img;
      };

      ImageLoaderWorker.prototype.atReady = function() {
        var result;
        result = this.data.img;
        this.data.img = null;
        return this.emit("finish", null, result);
      };

      ImageLoaderWorker.prototype.atFail = function() {
        return this.emit("finish", this.data.failError || new Error("fail to load image"));
      };

      ImageLoaderWorker.prototype.atAbort = function() {
        return this.setState("fail");
      };

      ImageLoaderWorker.prototype.isPending = function() {
        return this.data.isPending;
      };

      ImageLoaderWorker.prototype.isAvailable = function() {
        var ref;
        return (ref = this.state) === "ready" || ref === "fail" || ref === "void";
      };

      ImageLoaderWorker.prototype.isIdle = function() {
        return this.isAvailable() || this.isPending();
      };

      return ImageLoaderWorker;

    })(Leaf.States);

    ChromeImageLoaderWorker = (function(superClass1) {
      extend(ChromeImageLoaderWorker, superClass1);

      function ChromeImageLoaderWorker() {
        ChromeImageLoaderWorker.__super__.constructor.call(this);
      }

      ChromeImageLoaderWorker.prototype.atLoading = function() {
        var img, onerror, onreadystatechange, xhr;
        this.data.timeStart = Date.now();
        img = document.createElement("img");
        this.data.img = img;
        this.clear((function(_this) {
          return function() {
            var xhr;
            xhr = _this.data.xhr;
            xhr.removeEventListener("readystatechange", onreadystatechange);
            xhr.removeEventListener("error", onerror);
            if (_this.isWaitingFor("giveup")) {
              _this.stopWaiting("giveup");
            }
            _this.data.isPending = false;
            return clearTimeout(_this.data.timer);
          };
        })(this));
        onreadystatechange = (function(_this) {
          return function() {
            if (xhr.readyState === 4) {
              _this.clear();
              return _this.setState("ready");
            }
          };
        })(this);
        onerror = (function(_this) {
          return function() {
            _this.clear();
            return _this.setState("fail");
          };
        })(this);
        this.data.timer = setTimeout((function(_this) {
          return function() {
            _this.data.isPending = true;
            _this.waitFor("giveup", function() {
              _this.clear();
              _this.data.failError = new Error("give up due to timeup to " + _this.timeout + " and someone else is waiting to load");
              return _this.setState("abort");
            });
            return _this.emit("pending");
          };
        })(this), this.timeout);
        xhr = new XMLHttpRequest();
        this.data.xhr = xhr;
        xhr.open('GET', this.src);
        xhr.responseType = 'blob';
        xhr.addEventListener("readystatechange", onreadystatechange);
        xhr.addEventListener("error", onerror);
        return xhr.send();
      };

      ChromeImageLoaderWorker.prototype.atReady = function() {
        var result, src;
        src = URL.createObjectURL(this.data.xhr.response);
        this.data.img.src = src || "";
        this.data.xhr = null;
        result = this.data.img;
        return this.emit("finish", null, result);
      };

      return ChromeImageLoaderWorker;

    })(ImageLoaderWorker);

    if ((ref = window.chrome) != null ? (ref1 = ref.runtime) != null ? ref1.id : void 0 : void 0) {
      Worker = ChromeImageLoaderWorker;
    } else {
      Worker = ImageLoaderWorker;
    }

    function ImageLoader() {
      ImageLoader.__super__.constructor.call(this);
      this.queue = [];
      this.workers = [];
      this.caches = {};
      this.fails = {};
      this.coherency = 0;
      this.setCoherency(20);
    }

    ImageLoader.prototype.setCoherency = function(count) {
      if (count == null) {
        count = 5;
      }
      return this._initWorkers(5);
    };

    ImageLoader.prototype._initWorkers = function(count) {
      if (count === this.coherency) {
        return;
      }
      this.coherency = count;
      while (this.coherency > this.workers.length) {
        this.workers.push(new Worker());
      }
      return this._next();
    };

    ImageLoader.prototype._onWorkerIdle = function(worker) {
      if (this.workers.length > this.coherency) {
        this.workers = this.workers.filter(function(item) {
          return item !== worker;
        });
      }
      return this._next();
    };

    ImageLoader.prototype._next = function() {
      var i, info, j, len, len1, ref2, ref3, worker;
      if (this.queue.length === 0) {
        return;
      }
      ref2 = this.workers;
      for (i = 0, len = ref2.length; i < len; i++) {
        worker = ref2[i];
        if (worker.isAvailable() && !worker.isReserved) {
          info = this.queue.shift();
          this._load(worker, info);
          this._next();
          return;
        }
      }
      ref3 = this.workers;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        worker = ref3[j];
        if (worker.isPending() && !worker.isReserved) {
          worker.reserve();
          worker.give("giveup");
          info = this.queue.shift();
          this._load(worker, info);
          this._next();
          return;
        }
      }
    };

    ImageLoader.prototype._load = function(worker, info) {
      worker.reserve();
      if (worker.isPending()) {
        worker.give("giveup");
      }
      worker.reset();
      worker.once("pending", (function(_this) {
        return function() {
          return _this._onWorkerIdle(worker);
        };
      })(this));
      worker.once("finish", (function(_this) {
        return function(err, img) {
          if (!err) {
            _this.caches[info.src] = img;
          } else {
            _this.fails[info.src] = err;
          }
          info.callback(err, img);
          return _this._onWorkerIdle(worker);
        };
      })(this));
      if (info.option) {
        if (info.option.giveup) {
          worker.timeout = info.option.giveup;
        }
      }
      worker.info = info;
      return worker.load(info.src);
    };

    ImageLoader.prototype.isBusy = function() {
      var i, item, len, ref2;
      ref2 = this.workers;
      for (i = 0, len = ref2.length; i < len; i++) {
        item = ref2[i];
        if (item.isAvailable() || item.isPending()) {
          return false;
        }
      }
      return true;
    };

    ImageLoader.prototype.hasCache = function(src) {
      return this.caches[src];
    };

    ImageLoader.prototype.hasFail = function(src) {
      return this.fails[src];
    };

    ImageLoader.prototype.hurry = function(src) {
      var i, index, info, len, ref2;
      ref2 = this.queue;
      for (index = i = 0, len = ref2.length; i < len; index = ++i) {
        info = ref2[index];
        if (info.src === src) {
          this.queue.splice(index, 1);
          this.queue.unshift(info);
          return;
        }
      }
    };

    ImageLoader.prototype.now = function(src) {
      var delayInfo, i, index, info, j, justStartWorker, latest, len, len1, ref2, ref3, worker;
      ref2 = this.queue;
      for (index = i = 0, len = ref2.length; i < len; index = ++i) {
        info = ref2[index];
        if (info.src === src) {
          this.queue.splice(index, 1);
          latest = 0;
          justStartWorker = null;
          ref3 = this.workers;
          for (j = 0, len1 = ref3.length; j < len1; j++) {
            worker = ref3[j];
            if (worker.data && worker.data.timeStart > latest) {
              justStartWorker = worker;
              latest = worker.data.timeStart;
            }
          }
          delayInfo = worker.info;
          this.queue.unshift(delayInfo);
          worker.reset();
          this._load(worker, info);
          return;
        }
      }
    };

    ImageLoader.prototype.load = function(option, callback) {
      var info, src;
      src = option.src || option;
      info = {
        src: src,
        option: option,
        callback: callback,
        type: "load"
      };
      if (this.caches[src]) {
        callback(null, this.caches[src]);
        return;
      }
      if (option.hurry) {
        this.queue.unshift(info);
      } else {
        this.queue.push(info);
      }
      return this._next();
    };

    ImageLoader.prototype.cache = function(option, callback) {
      var src;
      src = option.src || option;
      if (this.caches[src]) {
        callback();
      }
      return this.load(option, function(err, img) {
        return callback(err);
      });
    };

    ImageLoader.prototype.clear = function() {
      var i, item, j, len, len1, ref2, ref3, worker;
      ref2 = this.workers;
      for (i = 0, len = ref2.length; i < len; i++) {
        worker = ref2[i];
        worker.reset();
        if (worker.info && worker.info.callback) {
          worker.info.callback(new Error("clear"));
        }
      }
      ref3 = this.queue;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        item = ref3[j];
        item.callback(new Error("clear"));
      }
      return this.queue = [];
    };

    ImageLoader.prototype.stop = function() {
      var aborts, err, i, idleWorker, index, item, j, k, l, len, len1, len2, len3, ref2, ref3, ref4, ref5, results, srcs, worker;
      srcs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      err = new Errors.Abort("manually abort image loading");
      aborts = [];
      ref2 = this.queue;
      for (index = i = 0, len = ref2.length; i < len; index = ++i) {
        item = ref2[index];
        if (ref3 = item.src, indexOf.call(srcs, ref3) >= 0) {
          this.queue[index] = null;
          aborts.push(item);
        }
      }
      this.queue = this.queue.filter(function(item) {
        return item;
      });
      idleWorker = [];
      ref4 = this.workers;
      for (j = 0, len1 = ref4.length; j < len1; j++) {
        worker = ref4[j];
        if (ref5 = worker.info.src, indexOf.call(srcs, ref5) >= 0) {
          aborts.push(worker.info);
          worker.reset();
          idleWorker.push(worker);
        }
      }
      for (k = 0, len2 = aborts.length; k < len2; k++) {
        item = aborts[k];
        item.callback(err);
      }
      results = [];
      for (l = 0, len3 = idleWorker.length; l < len3; l++) {
        worker = idleWorker[l];
        results.push(this._onWorkerIdle(worker));
      }
      return results;
    };

    return ImageLoader;

  })(Leaf.EventEmitter);

  module.exports = ImageLoader;

}).call(this);

}
GlobalContext.setModule("component/imageLoader.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/indexedDBShim.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    /*! indexeddbshim - v2.2.1 - 2015-08-20 */
var idbModules={util:{cleanInterface:!1}};!function(){"use strict";var a={test:!0};if(Object.defineProperty)try{Object.defineProperty(a,"test",{enumerable:!1}),a.test&&(idbModules.util.cleanInterface=!0)}catch(b){}}(),function(a){"use strict";function b(a,b,c){c.target=b,"function"==typeof b[a]&&b[a].apply(b,[c])}var c=function(){this.length=0,this._items=[],a.util.cleanInterface&&Object.defineProperty(this,"_items",{enumerable:!1})};if(c.prototype={contains:function(a){return-1!==this._items.indexOf(a)},item:function(a){return this._items[a]},indexOf:function(a){return this._items.indexOf(a)},push:function(a){this._items.push(a),this.length+=1;for(var b=0;b<this._items.length;b++)this[b]=this._items[b]},splice:function(){this._items.splice.apply(this._items,arguments),this.length=this._items.length;for(var a in this)a===String(parseInt(a,10))&&delete this[a];for(a=0;a<this._items.length;a++)this[a]=this._items[a]}},a.util.cleanInterface)for(var d in{indexOf:!1,push:!1,splice:!1})Object.defineProperty(c.prototype,d,{enumerable:!1});a.util.callback=b,a.util.StringList=c,a.util.quote=function(a){return'"'+a+'"'}}(idbModules),function(a){"use strict";function b(){(navigator.userAgent.match(/MSIE/)||navigator.userAgent.match(/Trident/)||navigator.userAgent.match(/Edge/))&&c()}function c(){var a=IDBFactory.prototype.cmp,b=IDBDatabase.prototype.createObjectStore,c=IDBObjectStore.prototype.createIndex,f=IDBObjectStore.prototype.add,j=IDBObjectStore.prototype.put,k=IDBIndex.prototype.get,l=IDBIndex.prototype.getKey,m=IDBIndex.prototype.openCursor,n=IDBIndex.prototype.openKeyCursor,o=IDBObjectStore.prototype.get,p=IDBObjectStore.prototype["delete"],q=IDBObjectStore.prototype.openCursor,r=IDBObjectStore.prototype.openKeyCursor,s=IDBKeyRange.bound,t=IDBKeyRange.upperBound,u=IDBKeyRange.lowerBound,v=IDBKeyRange.only,w=Object.getOwnPropertyDescriptor(IDBRequest.prototype,"result"),x=Object.getOwnPropertyDescriptor(IDBCursor.prototype,"primaryKey"),y=Object.getOwnPropertyDescriptor(IDBCursor.prototype,"key"),z=Object.getOwnPropertyDescriptor(IDBCursorWithValue.prototype,"value");IDBFactory.prototype.cmp=function(b,c){var d=Array.prototype.slice.call(arguments);return b instanceof Array&&(d[0]=i(b)),c instanceof Array&&(d[1]=i(c)),a.apply(this,d)},IDBDatabase.prototype.createObjectStore=function(a,c){return c&&c.keyPath instanceof Array&&(c.keyPath=e(c.keyPath)),b.apply(this,arguments)},IDBObjectStore.prototype.createIndex=function(a,b,d){var f=Array.prototype.slice.call(arguments);return b instanceof Array&&(f[1]=e(b)),c.apply(this,f)},IDBObjectStore.prototype.add=function(a,b){return this.__insertData(f,arguments)},IDBObjectStore.prototype.put=function(a,b){return this.__insertData(j,arguments)},IDBObjectStore.prototype.__insertData=function(a,b){b=Array.prototype.slice.call(b);var c=b[0],e=b[1];if(e instanceof Array&&(b[1]=i(e)),"object"==typeof c){d(this.keyPath)&&g(c,this.keyPath);for(var f=0;f<this.indexNames.length;f++){var h=this.index(this.indexNames[f]);if(d(h.keyPath))try{g(c,h.keyPath)}catch(j){}}}return a.apply(this,b)},IDBIndex.prototype.get=function(a){var b=Array.prototype.slice.call(arguments);return a instanceof Array&&(b[0]=i(a)),k.apply(this,b)},IDBIndex.prototype.getKey=function(a){var b=Array.prototype.slice.call(arguments);return a instanceof Array&&(b[0]=i(a)),l.apply(this,b)},IDBIndex.prototype.openCursor=function(a){var b=Array.prototype.slice.call(arguments);return a instanceof Array&&(b[0]=i(a)),m.apply(this,b)},IDBIndex.prototype.openKeyCursor=function(a){var b=Array.prototype.slice.call(arguments);return a instanceof Array&&(b[0]=i(a)),n.apply(this,b)},IDBObjectStore.prototype.get=function(a){var b=Array.prototype.slice.call(arguments);return a instanceof Array&&(b[0]=i(a)),o.apply(this,b)},IDBObjectStore.prototype["delete"]=function(a){var b=Array.prototype.slice.call(arguments);return a instanceof Array&&(b[0]=i(a)),p.apply(this,b)},IDBObjectStore.prototype.openCursor=function(a){var b=Array.prototype.slice.call(arguments);return a instanceof Array&&(b[0]=i(a)),q.apply(this,b)},IDBObjectStore.prototype.openKeyCursor=function(a){var b=Array.prototype.slice.call(arguments);return a instanceof Array&&(b[0]=i(a)),r.apply(this,b)},IDBKeyRange.bound=function(a,b,c,d){var e=Array.prototype.slice.call(arguments);return a instanceof Array&&(e[0]=i(a)),b instanceof Array&&(e[1]=i(b)),s.apply(IDBKeyRange,e)},IDBKeyRange.upperBound=function(a,b){var c=Array.prototype.slice.call(arguments);return a instanceof Array&&(c[0]=i(a)),t.apply(IDBKeyRange,c)},IDBKeyRange.lowerBound=function(a,b){var c=Array.prototype.slice.call(arguments);return a instanceof Array&&(c[0]=i(a)),u.apply(IDBKeyRange,c)},IDBKeyRange.only=function(a){var b=Array.prototype.slice.call(arguments);return a instanceof Array&&(b[0]=i(a)),v.apply(IDBKeyRange,b)},Object.defineProperty(IDBRequest.prototype,"result",{enumerable:w.enumerable,configurable:w.configurable,get:function(){var a=w.get.call(this);return h(a)}}),Object.defineProperty(IDBCursor.prototype,"primaryKey",{enumerable:x.enumerable,configurable:x.configurable,get:function(){var a=x.get.call(this);return h(a)}}),Object.defineProperty(IDBCursor.prototype,"key",{enumerable:y.enumerable,configurable:y.configurable,get:function(){var a=y.get.call(this);return h(a)}}),Object.defineProperty(IDBCursorWithValue.prototype,"value",{enumerable:z.enumerable,configurable:z.configurable,get:function(){var a=z.get.call(this);return h(a)}});try{IDBTransaction.VERSION_CHANGE||(IDBTransaction.VERSION_CHANGE="versionchange")}catch(A){}}function d(a){return a&&0===a.indexOf(l+".")}function e(a){for(var b=0;b<a.length;b++)a[b]=a[b].replace(/\./g,n);return l+"."+a.join(o)}function f(a){a=a.substr(l.length+1),a=a.split(o);for(var b=0;b<a.length;b++)a[b]=a[b].replace(m,".");return a}function g(b,c){var d=f(c),e=a.Key.getValue(b,d),g=i(e);c=c.substr(l.length+1),b[l]=b[l]||{},b[l][c]=g}function h(a){return"string"==typeof a&&d(a)?j(a):(a&&"object"==typeof a[l]&&delete a[l],a)}function i(b){return a.Key.validate(b),b=a.Key.encode(b),b=l+"."+b,k(b),b}function j(b){return k(b),b=b.substr(l.length+1),b=a.Key.decode(b)}function k(b){if(b.length>889)throw a.util.createDOMException("DataError","The encoded key is "+b.length+" characters long, but IE only allows 889 characters. Consider replacing numeric keys with strings to reduce the encoded length.")}var l="__$compoundKey",m=/\$\$/g,n="$",o="$_$";a.polyfill=b}(idbModules),function(idbModules){"use strict";var Sca=function(){return{decycle:function(object,callback){function checkForCompletion(){0===queuedObjects.length&&returnCallback(derezObj)}function readBlobAsDataURL(a,b){var c=new FileReader;c.onloadend=function(c){var d=c.target.result,e="Blob";a instanceof File,updateEncodedBlob(d,b,e)},c.readAsDataURL(a)}function updateEncodedBlob(dataURL,path,blobtype){var encoded=queuedObjects.indexOf(path);path=path.replace("$","derezObj"),eval(path+'.$enc="'+dataURL+'"'),eval(path+'.$type="'+blobtype+'"'),queuedObjects.splice(encoded,1),checkForCompletion()}function derez(a,b){var c,d,e;if(!("object"!=typeof a||null===a||a instanceof Boolean||a instanceof Date||a instanceof Number||a instanceof RegExp||a instanceof Blob||a instanceof String)){for(c=0;c<objects.length;c+=1)if(objects[c]===a)return{$ref:paths[c]};if(objects.push(a),paths.push(b),"[object Array]"===Object.prototype.toString.apply(a))for(e=[],c=0;c<a.length;c+=1)e[c]=derez(a[c],b+"["+c+"]");else{e={};for(d in a)Object.prototype.hasOwnProperty.call(a,d)&&(e[d]=derez(a[d],b+"["+JSON.stringify(d)+"]"))}return e}return a instanceof Blob?(queuedObjects.push(b),readBlobAsDataURL(a,b)):a instanceof Boolean?a={$type:"Boolean",$enc:a.toString()}:a instanceof Date?a={$type:"Date",$enc:a.getTime()}:a instanceof Number?a={$type:"Number",$enc:a.toString()}:a instanceof RegExp?a={$type:"RegExp",$enc:a.toString()}:"number"==typeof a?a={$type:"number",$enc:a+""}:void 0===a&&(a={$type:"undefined"}),a}var objects=[],paths=[],queuedObjects=[],returnCallback=callback,derezObj=derez(object,"$");checkForCompletion()},retrocycle:function retrocycle($){function dataURLToBlob(a){var b,c,d,e=";base64,";if(-1===a.indexOf(e))return c=a.split(","),b=c[0].split(":")[1],d=c[1],new Blob([d],{type:b});c=a.split(e),b=c[0].split(":")[1],d=window.atob(c[1]);for(var f=d.length,g=new Uint8Array(f),h=0;f>h;++h)g[h]=d.charCodeAt(h);return new Blob([g.buffer],{type:b})}function rez(value){var i,item,name,path;if(value&&"object"==typeof value)if("[object Array]"===Object.prototype.toString.apply(value))for(i=0;i<value.length;i+=1)item=value[i],item&&"object"==typeof item&&(path=item.$ref,"string"==typeof path&&px.test(path)?value[i]=eval(path):value[i]=rez(item));else if(void 0!==value.$type)switch(value.$type){case"Blob":case"File":value=dataURLToBlob(value.$enc);break;case"Boolean":value=Boolean("true"===value.$enc);break;case"Date":value=new Date(value.$enc);break;case"Number":value=Number(value.$enc);break;case"RegExp":value=eval(value.$enc);break;case"number":value=parseFloat(value.$enc);break;case"undefined":value=void 0}else for(name in value)"object"==typeof value[name]&&(item=value[name],item&&(path=item.$ref,"string"==typeof path&&px.test(path)?value[name]=eval(path):value[name]=rez(item)));return value}var px=/^\$(?:\[(?:\d+|\"(?:[^\\\"\u0000-\u001f]|\\([\\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\])*$/;return rez($)},encode:function(a,b){function c(a){b(JSON.stringify(a))}this.decycle(a,c)},decode:function(a){return this.retrocycle(JSON.parse(a))}}}();idbModules.Sca=Sca}(idbModules),function(idbModules){"use strict";function padBase32Exponent(a){return a=a.toString(32),1===a.length?"0"+a:a}function padBase32Mantissa(a){return(a+zeros(11)).slice(0,11)}function flipBase32(a){for(var b="",c=0;c<a.length;c++)b+=(31-parseInt(a[c],32)).toString(32);return b}function pow32(a,b){var c,d,e;return b=parseInt(b,32),0>b?roundToPrecision(parseInt(a,32)*Math.pow(32,b-10)):11>b?(c=a.slice(0,b),c=parseInt(c,32),d=a.slice(b),d=parseInt(d,32)*Math.pow(32,b-11),roundToPrecision(c+d)):(e=a+zeros(b-11),parseInt(e,32))}function roundToPrecision(a,b){return b=b||16,parseFloat(a.toPrecision(b))}function zeros(a){for(var b="";a--;)b+="0";return b}function negate(a){return"-"+a}function getType(a){return a instanceof Date?"date":a instanceof Array?"array":typeof a}function validate(a){var b=getType(a);if("array"===b)for(var c=0;c<a.length;c++)validate(a[c]);else if(!types[b]||"string"!==b&&isNaN(a))throw idbModules.util.createDOMException("DataError","Not a valid key")}function getValue(source,keyPath){try{if(keyPath instanceof Array){for(var arrayValue=[],i=0;i<keyPath.length;i++)arrayValue.push(eval("source."+keyPath[i]));return arrayValue}return eval("source."+keyPath)}catch(e){return void 0}}function setValue(a,b,c){for(var d=b.split("."),e=0;e<d.length-1;e++){var f=d[e];a=a[f]=a[f]||{}}a[d[d.length-1]]=c}function isMultiEntryMatch(a,b){var c=collations[b.substring(0,1)];return"array"===c?b.indexOf(a)>1:b===a}function isKeyInRange(a,b){var c=void 0===b.lower,d=void 0===b.upper,e=idbModules.Key.encode(a,!0);return void 0!==b.lower&&(b.lowerOpen&&e>b.__lower&&(c=!0),!b.lowerOpen&&e>=b.__lower&&(c=!0)),void 0!==b.upper&&(b.upperOpen&&e<b.__upper&&(d=!0),!b.upperOpen&&e<=b.__upper&&(d=!0)),c&&d}function findMultiEntryMatches(a,b){var c=[];if(a instanceof Array)for(var d=0;d<a.length;d++){var e=a[d];if(e instanceof Array){if(b.lower===b.upper)continue;if(1!==e.length){var f=findMultiEntryMatches(e,b);f.length>0&&c.push(e);continue}e=e[0]}isKeyInRange(e,b)&&c.push(e)}else isKeyInRange(a,b)&&c.push(a);return c}var collations=["undefined","number","date","string","array"],signValues=["negativeInfinity","bigNegative","smallNegative","smallPositive","bigPositive","positiveInfinity"],types={undefined:{encode:function(a){return collations.indexOf("undefined")+"-"},decode:function(a){return void 0}},date:{encode:function(a){return collations.indexOf("date")+"-"+a.toJSON()},decode:function(a){return new Date(a.substring(2))}},number:{encode:function(a){var b=Math.abs(a).toString(32),c=b.indexOf(".");b=-1!==c?b.replace(".",""):b;var d=b.search(/[^0]/);b=b.slice(d);var e,f=zeros(2),g=zeros(11);return isFinite(a)?0>a?a>-1?(e=signValues.indexOf("smallNegative"),f=padBase32Exponent(d),g=flipBase32(padBase32Mantissa(b))):(e=signValues.indexOf("bigNegative"),f=flipBase32(padBase32Exponent(-1!==c?c:b.length)),g=flipBase32(padBase32Mantissa(b))):1>a?(e=signValues.indexOf("smallPositive"),f=flipBase32(padBase32Exponent(d)),g=padBase32Mantissa(b)):(e=signValues.indexOf("bigPositive"),f=padBase32Exponent(-1!==c?c:b.length),g=padBase32Mantissa(b)):e=signValues.indexOf(a>0?"positiveInfinity":"negativeInfinity"),collations.indexOf("number")+"-"+e+f+g},decode:function(a){var b=+a.substr(2,1),c=a.substr(3,2),d=a.substr(5,11);switch(signValues[b]){case"negativeInfinity":return-(1/0);case"positiveInfinity":return 1/0;case"bigPositive":return pow32(d,c);case"smallPositive":return c=negate(flipBase32(c)),pow32(d,c);case"smallNegative":return c=negate(c),d=flipBase32(d),-pow32(d,c);case"bigNegative":return c=flipBase32(c),d=flipBase32(d),-pow32(d,c);default:throw new Error("Invalid number.")}}},string:{encode:function(a,b){return b&&(a=a.replace(/(.)/g,"-$1")+" "),collations.indexOf("string")+"-"+a},decode:function(a,b){return a=a.substring(2),b&&(a=a.substr(0,a.length-1).replace(/-(.)/g,"$1")),a}},array:{encode:function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c],e=idbModules.Key.encode(d,!0);b[c]=e}return b.push(collations.indexOf("undefined")+"-"),collations.indexOf("array")+"-"+JSON.stringify(b)},decode:function(a){var b=JSON.parse(a.substring(2));b.pop();for(var c=0;c<b.length;c++){var d=b[c],e=idbModules.Key.decode(d,!0);b[c]=e}return b}}};idbModules.Key={encode:function(a,b){return void 0===a?null:types[getType(a)].encode(a,b)},decode:function(a,b){return"string"!=typeof a?void 0:types[collations[a.substring(0,1)]].decode(a,b)},validate:validate,getValue:getValue,setValue:setValue,isMultiEntryMatch:isMultiEntryMatch,findMultiEntryMatches:findMultiEntryMatches}}(idbModules),function(a){"use strict";function b(a,b){var c=new Event(a);return c.debug=b,Object.defineProperty(c,"target",{writable:!0}),c}function c(a,b){this.type=a,this.debug=b,this.bubbles=!1,this.cancelable=!1,this.eventPhase=0,this.timeStamp=(new Date).valueOf()}var d=!1;try{var e=b("test type","test debug"),f={test:"test target"};e.target=f,e instanceof Event&&"test type"===e.type&&"test debug"===e.debug&&e.target===f&&(d=!0)}catch(g){}d?(a.Event=Event,a.IDBVersionChangeEvent=Event,a.util.createEvent=b):(a.Event=c,a.IDBVersionChangeEvent=c,a.util.createEvent=function(a,b){return new c(a,b)})}(idbModules),function(a){"use strict";function b(a,b){var c=new DOMException.prototype.constructor(0,b);return c.name=a||"DOMException",c.message=b,c}function c(a,b){a=a||"DOMError";var c=new DOMError(a,b);return c.name===a||(c.name=a),c.message===b||(c.message=b),c}function d(a,b){var c=new Error(b);return c.name=a||"DOMException",c.message=b,c}a.util.logError=function(b,c,d){if(a.DEBUG){d&&d.message&&(d=d.message);var e="function"==typeof console.error?"error":"log";console[e](b+": "+c+". "+(d||"")),console.trace&&console.trace()}},a.util.findError=function(a){var b;if(a){if(1===a.length)return a[0];for(var c=0;c<a.length;c++){var d=a[c];if(d instanceof Error||d instanceof DOMException)return d;d&&"string"==typeof d.message&&(b=d)}}return b};var e,f=!1,g=!1;try{e=b("test name","test message"),e instanceof DOMException&&"test name"===e.name&&"test message"===e.message&&(f=!0)}catch(h){}try{e=c("test name","test message"),e instanceof DOMError&&"test name"===e.name&&"test message"===e.message&&(g=!0)}catch(h){}f?(a.DOMException=DOMException,a.util.createDOMException=function(c,d,e){return a.util.logError(c,d,e),b(c,d)}):(a.DOMException=Error,a.util.createDOMException=function(b,c,e){return a.util.logError(b,c,e),d(b,c)}),g?(a.DOMError=DOMError,a.util.createDOMError=function(b,d,e){return a.util.logError(b,d,e),c(b,d)}):(a.DOMError=Error,a.util.createDOMError=function(b,c,e){return a.util.logError(b,c,e),d(b,c)})}(idbModules),function(a){"use strict";function b(){this.onsuccess=this.onerror=this.result=this.error=this.source=this.transaction=null,this.readyState="pending"}function c(){this.onblocked=this.onupgradeneeded=null}c.prototype=new b,c.prototype.constructor=c,a.IDBRequest=b,a.IDBOpenDBRequest=c}(idbModules),function(a,b){"use strict";function c(c,d,e,f){c!==b&&a.Key.validate(c),d!==b&&a.Key.validate(d),this.lower=c,this.upper=d,this.lowerOpen=!!e,this.upperOpen=!!f}c.only=function(a){return new c(a,a,!1,!1)},c.lowerBound=function(a,d){return new c(a,b,d,b)},c.upperBound=function(a,d){return new c(b,a,b,d)},c.bound=function(a,b,d,e){return new c(a,b,d,e)},a.IDBKeyRange=c}(idbModules),function(a,b){"use strict";function c(c,d,e,f,g,h,i){if(null===c&&(c=b),c===b||c instanceof a.IDBKeyRange||(c=new a.IDBKeyRange(c,c,!1,!1)),e.transaction.__assertActive(),d!==b&&-1===["next","prev","nextunique","prevunique"].indexOf(d))throw new TypeError(d+"is not a valid cursor direction");this.source=f,this.direction=d||"next",this.key=b,this.primaryKey=b,this.__store=e,this.__range=c,this.__req=new a.IDBRequest,this.__keyColumnName=g,this.__valueColumnName=h,this.__valueDecoder="value"===h?a.Sca:a.Key,this.__count=i,this.__offset=-1,this.__lastKeyContinued=b,this.__multiEntryIndex=f instanceof a.IDBIndex?f.multiEntry:!1,this.__unique=-1!==this.direction.indexOf("unique"),c!==b&&(c.__lower=c.lower!==b&&a.Key.encode(c.lower,this.__multiEntryIndex),c.__upper=c.upper!==b&&a.Key.encode(c.upper,this.__multiEntryIndex)),this["continue"]()}c.prototype.__find=function(){var a=Array.prototype.slice.call(arguments);this.__multiEntryIndex?this.__findMultiEntry.apply(this,a):this.__findBasic.apply(this,a)},c.prototype.__findBasic=function(c,d,e,f,g){g=g||1;var h=this,i=a.util.quote(h.__keyColumnName),j=["SELECT * FROM",a.util.quote(h.__store.name)],k=[];j.push("WHERE",i,"NOT NULL"),!h.__range||h.__range.lower===b&&h.__range.upper===b||(j.push("AND"),h.__range.lower!==b&&(j.push(i,h.__range.lowerOpen?">":">=","?"),k.push(h.__range.__lower)),h.__range.lower!==b&&h.__range.upper!==b&&j.push("AND"),h.__range.upper!==b&&(j.push(i,h.__range.upperOpen?"<":"<=","?"),k.push(h.__range.__upper))),"undefined"!=typeof c&&(h.__lastKeyContinued=c,h.__offset=0),h.__lastKeyContinued!==b&&(j.push("AND",i,">= ?"),a.Key.validate(h.__lastKeyContinued),k.push(a.Key.encode(h.__lastKeyContinued)));var l="prev"===h.direction||"prevunique"===h.direction?"DESC":"ASC";h.__count||(j.push("ORDER BY",i,l),j.push("LIMIT",g,"OFFSET",h.__offset)),j=j.join(" "),a.DEBUG&&console.log(j,k),h.__prefetchedData=null,h.__prefetchedIndex=0,d.executeSql(j,k,function(c,d){h.__count?e(b,d.rows.length,b):d.rows.length>1?(h.__prefetchedData=d.rows,h.__prefetchedIndex=0,a.DEBUG&&console.log("Preloaded "+h.__prefetchedData.length+" records for cursor"),h.__decode(d.rows.item(0),e)):1===d.rows.length?h.__decode(d.rows.item(0),e):(a.DEBUG&&console.log("Reached end of cursors"),e(b,b,b))},function(b,c){a.DEBUG&&console.log("Could not execute Cursor.continue",j,k),f(c)})},c.prototype.__findMultiEntry=function(c,d,e,f){var g=this;if(g.__prefetchedData&&g.__prefetchedData.length===g.__prefetchedIndex)return a.DEBUG&&console.log("Reached end of multiEntry cursor"),void e(b,b,b);var h=a.util.quote(g.__keyColumnName),i=["SELECT * FROM",a.util.quote(g.__store.name)],j=[];i.push("WHERE",h,"NOT NULL"),g.__range&&g.__range.lower!==b&&g.__range.upper!==b&&0===g.__range.upper.indexOf(g.__range.lower)&&(i.push("AND",h,"LIKE ?"),j.push("%"+g.__range.__lower.slice(0,-1)+"%")),"undefined"!=typeof c&&(g.__lastKeyContinued=c,g.__offset=0),g.__lastKeyContinued!==b&&(i.push("AND",h,">= ?"),a.Key.validate(g.__lastKeyContinued),j.push(a.Key.encode(g.__lastKeyContinued)));var k="prev"===g.direction||"prevunique"===g.direction?"DESC":"ASC";g.__count||i.push("ORDER BY key",k),i=i.join(" "),a.DEBUG&&console.log(i,j),g.__prefetchedData=null,g.__prefetchedIndex=0,d.executeSql(i,j,function(c,d){if(g.__multiEntryOffset=d.rows.length,d.rows.length>0){for(var f=[],h=0;h<d.rows.length;h++)for(var i=d.rows.item(h),j=a.Key.decode(i[g.__keyColumnName],!0),k=a.Key.findMultiEntryMatches(j,g.__range),l=0;l<k.length;l++){var m=k[l],n={matchingKey:a.Key.encode(m,!0),key:i.key};n[g.__keyColumnName]=i[g.__keyColumnName],n[g.__valueColumnName]=i[g.__valueColumnName],f.push(n)}var o=0===g.direction.indexOf("prev");f.sort(function(a,b){return a.matchingKey.replace("[","z")<b.matchingKey.replace("[","z")?o?1:-1:a.matchingKey.replace("[","z")>b.matchingKey.replace("[","z")?o?-1:1:a.key<b.key?"prev"===g.direction?1:-1:a.key>b.key?"prev"===g.direction?-1:1:0}),g.__prefetchedData={data:f,length:f.length,item:function(a){return this.data[a]}},g.__prefetchedIndex=0,g.__count?e(b,f.length,b):f.length>1?(a.DEBUG&&console.log("Preloaded "+g.__prefetchedData.length+" records for multiEntry cursor"),g.__decode(f[0],e)):1===f.length?(a.DEBUG&&console.log("Reached end of multiEntry cursor"),g.__decode(f[0],e)):(a.DEBUG&&console.log("Reached end of multiEntry cursor"),e(b,b,b))}else a.DEBUG&&console.log("Reached end of multiEntry cursor"),e(b,b,b)},function(b,c){a.DEBUG&&console.log("Could not execute Cursor.continue",i,j),f(c)})},c.prototype.__onsuccess=function(a){var c=this;return function(d,e,f){if(c.__count)a(e,c.__req);else{c.key=d===b?null:d,c.value=e===b?null:e,c.primaryKey=f===b?null:f;var g=d===b?null:c;a(g,c.__req)}}},c.prototype.__decode=function(c,d){if(this.__multiEntryIndex&&this.__unique){if(this.__matchedKeys||(this.__matchedKeys={}),this.__matchedKeys[c.matchingKey])return void d(b,b,b);this.__matchedKeys[c.matchingKey]=!0}var e=a.Key.decode(this.__multiEntryIndex?c.matchingKey:c[this.__keyColumnName],this.__multiEntryIndex),f=this.__valueDecoder.decode(c[this.__valueColumnName]),g=a.Key.decode(c.key);d(e,f,g)},c.prototype["continue"]=function(b){var c=a.cursorPreloadPackSize||100,d=this;this.__store.transaction.__pushToQueue(d.__req,function(a,e,f,g){return d.__offset++,d.__prefetchedData&&(d.__prefetchedIndex++,d.__prefetchedIndex<d.__prefetchedData.length)?void d.__decode(d.__prefetchedData.item(d.__prefetchedIndex),d.__onsuccess(f)):void d.__find(b,a,d.__onsuccess(f),g,c)})},c.prototype.advance=function(c){if(0>=c)throw a.util.createDOMException("Type Error","Count is invalid - 0 or negative",c);var d=this;this.__store.transaction.__pushToQueue(d.__req,function(a,e,f,g){d.__offset+=c,d.__find(b,a,d.__onsuccess(f),g)})},c.prototype.update=function(c){var d=this;return d.__store.transaction.__assertWritable(),d.__store.transaction.__addToTransactionQueue(function(e,f,g,h){a.Sca.encode(c,function(f){d.__find(b,e,function(b,i,j){var k=d.__store,l=[f],m=["UPDATE",a.util.quote(k.name),"SET value = ?"];a.Key.validate(j);for(var n=0;n<k.indexNames.length;n++){var o=k.__indexes[k.indexNames[n]],p=a.Key.getValue(c,o.keyPath);m.push(",",a.util.quote(o.name),"= ?"),l.push(a.Key.encode(p,o.multiEntry))}m.push("WHERE key = ?"),l.push(a.Key.encode(j)),a.DEBUG&&console.log(m.join(" "),f,b,j),e.executeSql(m.join(" "),l,function(a,c){d.__prefetchedData=null,d.__prefetchedIndex=0,1===c.rowsAffected?g(b):h("No rows with key found"+b)},function(a,b){h(b)})},h)})})},c.prototype["delete"]=function(){var c=this;return c.__store.transaction.__assertWritable(),this.__store.transaction.__addToTransactionQueue(function(d,e,f,g){c.__find(b,d,function(e,h,i){var j="DELETE FROM  "+a.util.quote(c.__store.name)+" WHERE key = ?";a.DEBUG&&console.log(j,e,i),a.Key.validate(i),d.executeSql(j,[a.Key.encode(i)],function(a,d){c.__prefetchedData=null,c.__prefetchedIndex=0,1===d.rowsAffected?(c.__offset--,f(b)):g("No rows with key found"+e)},function(a,b){g(b)})},g)})},a.IDBCursor=c}(idbModules),function(a,b){"use strict";function c(a,b){this.objectStore=a,this.name=b.columnName,this.keyPath=b.keyPath,this.multiEntry=b.optionalParams&&b.optionalParams.multiEntry,this.unique=b.optionalParams&&b.optionalParams.unique,this.__deleted=!!b.__deleted}c.__clone=function(a,b){return new c(b,{columnName:a.name,keyPath:a.keyPath,optionalParams:{multiEntry:a.multiEntry,unique:a.unique}})},c.__createIndex=function(b,d){var e=!!b.__indexes[d.name]&&b.__indexes[d.name].__deleted;b.__indexes[d.name]=d,b.indexNames.push(d.name);var f=b.transaction;f.__addToTransactionQueue(function(f,g,h,i){function j(b,c){i(a.util.createDOMException(0,'Could not create index "'+d.name+'"',c))}function k(e){c.__updateIndexList(b,e,function(){e.executeSql("SELECT * FROM "+a.util.quote(b.name),[],function(c,e){function f(g){if(g<e.rows.length)try{var i=a.Sca.decode(e.rows.item(g).value),k=a.Key.getValue(i,d.keyPath);k=a.Key.encode(k,d.multiEntry),c.executeSql("UPDATE "+a.util.quote(b.name)+" set "+a.util.quote(d.name)+" = ? where key = ?",[k,e.rows.item(g).key],function(a,b){f(g+1)},j)}catch(l){f(g+1)}else h(b)}a.DEBUG&&console.log("Adding existing "+b.name+" records to the "+d.name+" index"),f(0)},j)},j)}if(e)k(f);else{var l=["ALTER TABLE",a.util.quote(b.name),"ADD",a.util.quote(d.name),"BLOB"].join(" ");a.DEBUG&&console.log(l),f.executeSql(l,[],k,j)}})},c.__deleteIndex=function(b,d){b.__indexes[d.name].__deleted=!0,b.indexNames.splice(b.indexNames.indexOf(d.name),1);var e=b.transaction;e.__addToTransactionQueue(function(e,f,g,h){function i(b,c){h(a.util.createDOMException(0,'Could not delete index "'+d.name+'"',c))}c.__updateIndexList(b,e,g,i)})},c.__updateIndexList=function(b,c,d,e){for(var f={},g=0;g<b.indexNames.length;g++){var h=b.__indexes[b.indexNames[g]];f[h.name]={columnName:h.name,keyPath:h.keyPath,optionalParams:{unique:h.unique,multiEntry:h.multiEntry},deleted:!!h.deleted}}a.DEBUG&&console.log("Updating the index list for "+b.name,f),c.executeSql("UPDATE __sys__ set indexList = ? where name = ?",[JSON.stringify(f),b.name],function(){d(b)},e)},c.prototype.__fetchIndexData=function(c,d){var e,f,g=this;return 1===arguments.length?(d=c,e=!1):(a.Key.validate(c),f=a.Key.encode(c,g.multiEntry),e=!0),g.objectStore.transaction.__addToTransactionQueue(function(c,h,i,j){var k=["SELECT * FROM",a.util.quote(g.objectStore.name),"WHERE",a.util.quote(g.name),"NOT NULL"],l=[];e&&(g.multiEntry?(k.push("AND",a.util.quote(g.name),"LIKE ?"),l.push("%"+f+"%")):(k.push("AND",a.util.quote(g.name),"= ?"),l.push(f))),a.DEBUG&&console.log("Trying to fetch data for Index",k.join(" "),l),c.executeSql(k.join(" "),l,function(c,h){var j=0,k=null;if(g.multiEntry)for(var l=0;l<h.rows.length;l++){var m=h.rows.item(l),n=a.Key.decode(m[g.name]);e&&a.Key.isMultiEntryMatch(f,m[g.name])?(j++,k=k||m):e||n===b||(j+=n instanceof Array?n.length:1,k=k||m)}else j=h.rows.length,k=j&&h.rows.item(0);i("count"===d?j:0===j?b:"key"===d?a.Key.decode(k.key):a.Sca.decode(k.value))},j)})},c.prototype.openCursor=function(b,c){return new a.IDBCursor(b,c,this.objectStore,this,this.name,"value").__req},c.prototype.openKeyCursor=function(b,c){return new a.IDBCursor(b,c,this.objectStore,this,this.name,"key").__req},c.prototype.get=function(a){if(0===arguments.length)throw new TypeError("No key was specified");return this.__fetchIndexData(a,"value")},c.prototype.getKey=function(a){if(0===arguments.length)throw new TypeError("No key was specified");return this.__fetchIndexData(a,"key")},c.prototype.count=function(c){return c===b?this.__fetchIndexData("count"):c instanceof a.IDBKeyRange?new a.IDBCursor(c,"next",this.objectStore,this,this.name,"value",!0).__req:this.__fetchIndexData(c,"count")},a.IDBIndex=c}(idbModules),function(a){"use strict";function b(b,c){this.name=b.name,this.keyPath=JSON.parse(b.keyPath),this.transaction=c,this.autoIncrement="string"==typeof b.autoInc?"true"===b.autoInc:!!b.autoInc,this.__indexes={},this.indexNames=new a.util.StringList;var d=JSON.parse(b.indexList);for(var e in d)if(d.hasOwnProperty(e)){var f=new a.IDBIndex(this,d[e]);this.__indexes[f.name]=f,f.__deleted||this.indexNames.push(f.name)}}b.__clone=function(a,c){var d=new b({name:a.name,keyPath:JSON.stringify(a.keyPath),autoInc:JSON.stringify(a.autoIncrement),indexList:"{}"},c);return d.__indexes=a.__indexes,d.indexNames=a.indexNames,d},b.__createObjectStore=function(b,c){b.__objectStores[c.name]=c,b.objectStoreNames.push(c.name);var d=b.__versionTransaction;a.IDBTransaction.__assertVersionChange(d),d.__addToTransactionQueue(function(b,d,e,f){function g(b,d){throw a.util.createDOMException(0,'Could not create object store "'+c.name+'"',d)}var h=["CREATE TABLE",a.util.quote(c.name),"(key BLOB",c.autoIncrement?"UNIQUE, inc INTEGER PRIMARY KEY AUTOINCREMENT":"PRIMARY KEY",", value BLOB)"].join(" ");a.DEBUG&&console.log(h),b.executeSql(h,[],function(a,b){a.executeSql("INSERT INTO __sys__ VALUES (?,?,?,?)",[c.name,JSON.stringify(c.keyPath),c.autoIncrement,"{}"],function(){e(c)},g)},g)})},b.__deleteObjectStore=function(b,c){b.__objectStores[c.name]=void 0,b.objectStoreNames.splice(b.objectStoreNames.indexOf(c.name),1);var d=b.__versionTransaction;a.IDBTransaction.__assertVersionChange(d),d.__addToTransactionQueue(function(b,d,e,f){function g(b,c){f(a.util.createDOMException(0,"Could not delete ObjectStore",c))}b.executeSql("SELECT * FROM __sys__ where name = ?",[c.name],function(b,d){d.rows.length>0&&b.executeSql("DROP TABLE "+a.util.quote(c.name),[],function(){b.executeSql("DELETE FROM __sys__ WHERE name = ?",[c.name],function(){e()},g)},g)})})},b.prototype.__validateKey=function(b,c){if(this.keyPath){if("undefined"!=typeof c)throw a.util.createDOMException("DataError","The object store uses in-line keys and the key parameter was provided",this);if(!b||"object"!=typeof b)throw a.util.createDOMException("DataError","KeyPath was specified, but value was not an object");if(c=a.Key.getValue(b,this.keyPath),void 0===c){if(this.autoIncrement)return;throw a.util.createDOMException("DataError","Could not eval key from keyPath")}}else if("undefined"==typeof c){if(this.autoIncrement)return;throw a.util.createDOMException("DataError","The object store uses out-of-line keys and has no key generator and the key parameter was not provided. ",this)}a.Key.validate(c)},b.prototype.__deriveKey=function(b,c,d,e,f){function g(c){b.executeSql("SELECT * FROM sqlite_sequence where name like ?",[h.name],function(a,b){c(1!==b.rows.length?1:b.rows.item(0).seq+1)},function(b,c){f(a.util.createDOMException("DataError","Could not get the auto increment value for key",c))})}var h=this;if(h.keyPath){var i=a.Key.getValue(c,h.keyPath);void 0===i&&h.autoIncrement?g(function(b){try{a.Key.setValue(c,h.keyPath,b),e(b)}catch(d){f(a.util.createDOMException("DataError","Could not assign a generated value to the keyPath",d))}}):e(i)}else"undefined"==typeof d&&h.autoIncrement?g(e):e(d)},b.prototype.__insertData=function(b,c,d,e,f,g){try{var h={};"undefined"!=typeof e&&(a.Key.validate(e),h.key=a.Key.encode(e));for(var i=0;i<this.indexNames.length;i++){var j=this.__indexes[this.indexNames[i]];h[j.name]=a.Key.encode(a.Key.getValue(d,j.keyPath),j.multiEntry)}var k=["INSERT INTO ",a.util.quote(this.name),"("],l=[" VALUES ("],m=[];for(var n in h)k.push(a.util.quote(n)+","),l.push("?,"),m.push(h[n]);k.push("value )"),l.push("?)"),m.push(c);var o=k.join(" ")+l.join(" ");a.DEBUG&&console.log("SQL for adding",o,m),b.executeSql(o,m,function(b,c){a.Sca.encode(e,function(b){b=a.Sca.decode(b),f(b)})},function(b,c){g(a.util.createDOMError("ConstraintError",c.message,c))})}catch(p){g(p)}},b.prototype.add=function(b,c){var d=this;if(0===arguments.length)throw new TypeError("No value was specified");this.__validateKey(b,c),d.transaction.__assertWritable();var e=d.transaction.__createRequest();return d.transaction.__pushToQueue(e,function(e,f,g,h){d.__deriveKey(e,b,c,function(c){a.Sca.encode(b,function(a){d.__insertData(e,a,b,c,g,h)})},h)}),e},b.prototype.put=function(b,c){var d=this;if(0===arguments.length)throw new TypeError("No value was specified");this.__validateKey(b,c),d.transaction.__assertWritable();var e=d.transaction.__createRequest();return d.transaction.__pushToQueue(e,function(e,f,g,h){d.__deriveKey(e,b,c,function(c){
a.Sca.encode(b,function(f){a.Key.validate(c);var i="DELETE FROM "+a.util.quote(d.name)+" where key = ?";e.executeSql(i,[a.Key.encode(c)],function(e,i){a.DEBUG&&console.log("Did the row with the",c,"exist? ",i.rowsAffected),d.__insertData(e,f,b,c,g,h)},function(a,b){h(b)})})},h)}),e},b.prototype.get=function(b){var c=this;if(0===arguments.length)throw new TypeError("No key was specified");a.Key.validate(b);var d=a.Key.encode(b);return c.transaction.__addToTransactionQueue(function(b,e,f,g){a.DEBUG&&console.log("Fetching",c.name,d),b.executeSql("SELECT * FROM "+a.util.quote(c.name)+" where key = ?",[d],function(b,c){a.DEBUG&&console.log("Fetched data",c);var d;try{if(0===c.rows.length)return f();d=a.Sca.decode(c.rows.item(0).value)}catch(e){a.DEBUG&&console.log(e)}f(d)},function(a,b){g(b)})})},b.prototype["delete"]=function(b){var c=this;if(0===arguments.length)throw new TypeError("No key was specified");c.transaction.__assertWritable(),a.Key.validate(b);var d=a.Key.encode(b);return c.transaction.__addToTransactionQueue(function(b,e,f,g){a.DEBUG&&console.log("Fetching",c.name,d),b.executeSql("DELETE FROM "+a.util.quote(c.name)+" where key = ?",[d],function(b,c){a.DEBUG&&console.log("Deleted from database",c.rowsAffected),f()},function(a,b){g(b)})})},b.prototype.clear=function(){var b=this;return b.transaction.__assertWritable(),b.transaction.__addToTransactionQueue(function(c,d,e,f){c.executeSql("DELETE FROM "+a.util.quote(b.name),[],function(b,c){a.DEBUG&&console.log("Cleared all records from database",c.rowsAffected),e()},function(a,b){f(b)})})},b.prototype.count=function(b){if(b instanceof a.IDBKeyRange)return new a.IDBCursor(b,"next",this,this,"key","value",!0).__req;var c=this,d=!1;return void 0!==b&&(d=!0,a.Key.validate(b)),c.transaction.__addToTransactionQueue(function(e,f,g,h){var i="SELECT * FROM "+a.util.quote(c.name)+(d?" WHERE key = ?":""),j=[];d&&j.push(a.Key.encode(b)),e.executeSql(i,j,function(a,b){g(b.rows.length)},function(a,b){h(b)})})},b.prototype.openCursor=function(b,c){return new a.IDBCursor(b,c,this,this,"key","value").__req},b.prototype.index=function(b){if(0===arguments.length)throw new TypeError("No index name was specified");var c=this.__indexes[b];if(!c)throw a.util.createDOMException("NotFoundError",'Index "'+b+'" does not exist on '+this.name);return a.IDBIndex.__clone(c,this)},b.prototype.createIndex=function(b,c,d){if(0===arguments.length)throw new TypeError("No index name was specified");if(1===arguments.length)throw new TypeError("No key path was specified");if(c instanceof Array&&d&&d.multiEntry)throw a.util.createDOMException("InvalidAccessError","The keyPath argument was an array and the multiEntry option is true.");if(this.__indexes[b]&&!this.__indexes[b].__deleted)throw a.util.createDOMException("ConstraintError",'Index "'+b+'" already exists on '+this.name);this.transaction.__assertVersionChange(),d=d||{};var e={columnName:b,keyPath:c,optionalParams:{unique:!!d.unique,multiEntry:!!d.multiEntry}},f=new a.IDBIndex(this,e);return a.IDBIndex.__createIndex(this,f),f},b.prototype.deleteIndex=function(b){if(0===arguments.length)throw new TypeError("No index name was specified");var c=this.__indexes[b];if(!c)throw a.util.createDOMException("NotFoundError",'Index "'+b+'" does not exist on '+this.name);this.transaction.__assertVersionChange(),a.IDBIndex.__deleteIndex(this,c)},a.IDBObjectStore=b}(idbModules),function(a){"use strict";function b(a,b,d){this.__id=++c,this.__active=!0,this.__running=!1,this.__errored=!1,this.__requests=[],this.__storeNames=b,this.mode=d,this.db=a,this.error=null,this.onabort=this.onerror=this.oncomplete=null;var e=this;setTimeout(function(){e.__executeRequests()},0)}var c=0;b.prototype.__executeRequests=function(){function b(b){if(a.util.logError("Error","An error occurred in a transaction",b),!d.__errored){if(d.__errored=!0,!d.__active)throw b;try{d.error=b;var c=a.util.createEvent("error");a.util.callback("onerror",d,c),a.util.callback("onerror",d.db,c)}finally{d.abort()}}}function c(){a.DEBUG&&console.log("Transaction completed");var b=a.util.createEvent("complete");try{a.util.callback("oncomplete",d,b),a.util.callback("__oncomplete",d,b)}catch(c){throw d.__errored=!0,c}}if(this.__running)return void(a.DEBUG&&console.log("Looks like the request set is already running",this.mode));this.__running=!0;var d=this;d.db.__db.transaction(function(e){function f(b,c){c&&(i.req=c),i.req.readyState="done",i.req.result=b,delete i.req.error;var d=a.util.createEvent("success");a.util.callback("onsuccess",i.req,d),j++,h()}function g(c,d){d=a.util.findError(arguments);try{i.req.readyState="done",i.req.error=d||"DOMError",i.req.result=void 0;var e=a.util.createEvent("error",d);a.util.callback("onerror",i.req,e)}finally{b(d)}}function h(){if(j>=d.__requests.length)d.__requests=[],d.__active&&(d.__active=!1,c());else try{i=d.__requests[j],i.op(e,i.args,f,g)}catch(a){g(a)}}d.__tx=e;var i=null,j=0;h()},function(a){b(a)})},b.prototype.__createRequest=function(){var b=new a.IDBRequest;return b.source=this.db,b.transaction=this,b},b.prototype.__addToTransactionQueue=function(a,b){var c=this.__createRequest();return this.__pushToQueue(c,a,b),c},b.prototype.__pushToQueue=function(a,b,c){this.__assertActive(),this.__requests.push({op:b,args:c,req:a})},b.prototype.__assertActive=function(){if(!this.__active)throw a.util.createDOMException("TransactionInactiveError","A request was placed against a transaction which is currently not active, or which is finished")},b.prototype.__assertWritable=function(){if(this.mode===b.READ_ONLY)throw a.util.createDOMException("ReadOnlyError","The transaction is read only")},b.prototype.__assertVersionChange=function(){b.__assertVersionChange(this)},b.__assertVersionChange=function(c){if(!c||c.mode!==b.VERSION_CHANGE)throw a.util.createDOMException("InvalidStateError","Not a version transaction")},b.prototype.objectStore=function(c){if(0===arguments.length)throw new TypeError("No object store name was specified");if(!this.__active)throw a.util.createDOMException("InvalidStateError","A request was placed against a transaction which is currently not active, or which is finished");if(-1===this.__storeNames.indexOf(c)&&this.mode!==b.VERSION_CHANGE)throw a.util.createDOMException("NotFoundError",c+" is not participating in this transaction");var d=this.db.__objectStores[c];if(!d)throw a.util.createDOMException("NotFoundError",c+" does not exist in "+this.db.name);return a.IDBObjectStore.__clone(d,this)},b.prototype.abort=function(){var b=this;a.DEBUG&&console.log("The transaction was aborted",b),b.__active=!1;var c=a.util.createEvent("abort");setTimeout(function(){a.util.callback("onabort",b,c)},0)},b.READ_ONLY="readonly",b.READ_WRITE="readwrite",b.VERSION_CHANGE="versionchange",a.IDBTransaction=b}(idbModules),function(a){"use strict";function b(b,c,d,e){this.__db=b,this.__closed=!1,this.version=d,this.name=c,this.onabort=this.onerror=this.onversionchange=null,this.__objectStores={},this.objectStoreNames=new a.util.StringList;for(var f=0;f<e.rows.length;f++){var g=new a.IDBObjectStore(e.rows.item(f));this.__objectStores[g.name]=g,this.objectStoreNames.push(g.name)}}b.prototype.createObjectStore=function(b,c){if(0===arguments.length)throw new TypeError("No object store name was specified");if(this.__objectStores[b])throw a.util.createDOMException("ConstraintError",'Object store "'+b+'" already exists in '+this.name);this.__versionTransaction.__assertVersionChange(),c=c||{};var d={name:b,keyPath:JSON.stringify(c.keyPath||null),autoInc:JSON.stringify(c.autoIncrement),indexList:"{}"},e=new a.IDBObjectStore(d,this.__versionTransaction);return a.IDBObjectStore.__createObjectStore(this,e),e},b.prototype.deleteObjectStore=function(b){if(0===arguments.length)throw new TypeError("No object store name was specified");var c=this.__objectStores[b];if(!c)throw a.util.createDOMException("NotFoundError",'Object store "'+b+'" does not exist in '+this.name);this.__versionTransaction.__assertVersionChange(),a.IDBObjectStore.__deleteObjectStore(this,c)},b.prototype.close=function(){this.__closed=!0},b.prototype.transaction=function(b,c){if(this.__closed)throw a.util.createDOMException("InvalidStateError","An attempt was made to start a new transaction on a database connection that is not open");if("number"==typeof c?(c=1===c?IDBTransaction.READ_WRITE:IDBTransaction.READ_ONLY,a.DEBUG&&console.log("Mode should be a string, but was specified as ",c)):c=c||IDBTransaction.READ_ONLY,c!==IDBTransaction.READ_ONLY&&c!==IDBTransaction.READ_WRITE)throw new TypeError("Invalid transaction mode: "+c);if(b="string"==typeof b?[b]:b,0===b.length)throw a.util.createDOMException("InvalidAccessError","No object store names were specified");for(var d=0;d<b.length;d++)if(!this.objectStoreNames.contains(b[d]))throw a.util.createDOMException("NotFoundError",'The "'+b[d]+'" object store does not exist');var e=new a.IDBTransaction(this,b,c);return e},a.IDBDatabase=b}(idbModules),function(a){"use strict";function b(b,c){function f(b,d){d=a.util.findError(arguments),a.DEBUG&&console.log("Error in sysdb transaction - when creating dbVersions",d),c(d)}d?b():(d=window.openDatabase("__sysdb__",1,"System Database",e),d.transaction(function(a){a.executeSql("CREATE TABLE IF NOT EXISTS dbVersions (name VARCHAR(255), version INT);",[],b,f)},f))}function c(){this.modules=a}var d,e=4194304;c.prototype.open=function(c,f){function g(b,c){if(!j){c=a.util.findError(arguments),j=!0;var d=a.util.createEvent("error",arguments);i.readyState="done",i.error=c||"DOMError",a.util.callback("onerror",i,d)}}function h(b){var h=window.openDatabase(c,1,c,e);if(i.readyState="done","undefined"==typeof f&&(f=b||1),0>=f||b>f){var j=a.util.createDOMError("VersionError","An attempt was made to open a database using a lower version than the existing version.",f);return void g(j)}h.transaction(function(e){e.executeSql("CREATE TABLE IF NOT EXISTS __sys__ (name VARCHAR(255), keyPath VARCHAR(255), autoInc BOOLEAN, indexList BLOB)",[],function(){e.executeSql("SELECT * FROM __sys__",[],function(e,j){var k=a.util.createEvent("success");i.source=i.result=new a.IDBDatabase(h,c,f,j),f>b?d.transaction(function(d){d.executeSql("UPDATE dbVersions set version = ? where name = ?",[f,c],function(){var c=a.util.createEvent("upgradeneeded");c.oldVersion=b,c.newVersion=f,i.transaction=i.result.__versionTransaction=new a.IDBTransaction(i.source,[],a.IDBTransaction.VERSION_CHANGE),i.transaction.__addToTransactionQueue(function(b,d,e){a.util.callback("onupgradeneeded",i,c),e()}),i.transaction.__oncomplete=function(){i.transaction=null;var b=a.util.createEvent("success");a.util.callback("onsuccess",i,b)}},g)},g):a.util.callback("onsuccess",i,k)},g)},g)},g)}var i=new a.IDBOpenDBRequest,j=!1;if(0===arguments.length)throw new TypeError("Database name is required");if(2===arguments.length&&(f=parseFloat(f),isNaN(f)||!isFinite(f)||0>=f))throw new TypeError("Invalid database version: "+f);return c+="",b(function(){d.transaction(function(a){a.executeSql("SELECT * FROM dbVersions where name = ?",[c],function(a,b){0===b.rows.length?a.executeSql("INSERT INTO dbVersions VALUES (?,?)",[c,f||1],function(){h(0)},g):h(b.rows.item(0).version)},g)},g)},g),i},c.prototype.deleteDatabase=function(c){function f(b,c){if(!i){c=a.util.findError(arguments),h.readyState="done",h.error=c||"DOMError";var d=a.util.createEvent("error");d.debug=arguments,a.util.callback("onerror",h,d),i=!0}}function g(){d.transaction(function(b){b.executeSql("DELETE FROM dbVersions where name = ? ",[c],function(){h.result=void 0;var b=a.util.createEvent("success");b.newVersion=null,b.oldVersion=j,a.util.callback("onsuccess",h,b)},f)},f)}var h=new a.IDBOpenDBRequest,i=!1,j=null;if(0===arguments.length)throw new TypeError("Database name is required");return c+="",b(function(){d.transaction(function(b){b.executeSql("SELECT * FROM dbVersions where name = ?",[c],function(b,d){if(0===d.rows.length){h.result=void 0;var i=a.util.createEvent("success");return i.newVersion=null,i.oldVersion=j,void a.util.callback("onsuccess",h,i)}j=d.rows.item(0).version;var k=window.openDatabase(c,1,c,e);k.transaction(function(b){b.executeSql("SELECT * FROM __sys__",[],function(b,c){var d=c.rows;!function e(c){c>=d.length?b.executeSql("DROP TABLE IF EXISTS __sys__",[],function(){g()},f):b.executeSql("DROP TABLE "+a.util.quote(d.item(c).name),[],function(){e(c+1)},function(){e(c+1)})}(0)},function(a){g()})})},f)},f)},f),h},c.prototype.cmp=function(b,c){if(arguments.length<2)throw new TypeError("You must provide two keys to be compared");a.Key.validate(b),a.Key.validate(c);var d=a.Key.encode(b),e=a.Key.encode(c),f=d>e?1:d===e?0:-1;if(a.DEBUG){var g=a.Key.decode(d),h=a.Key.decode(e);"object"==typeof b&&(b=JSON.stringify(b),g=JSON.stringify(g)),"object"==typeof c&&(c=JSON.stringify(c),h=JSON.stringify(h)),g!==b&&console.warn(b+" was incorrectly encoded as "+g),h!==c&&console.warn(c+" was incorrectly encoded as "+h)}return f},a.shimIndexedDB=new c,a.IDBFactory=c}(idbModules),function(a,b){"use strict";function c(b,c){try{a[b]=c}catch(d){}if(a[b]!==c&&Object.defineProperty){try{Object.defineProperty(a,b,{value:c})}catch(d){}a[b]!==c&&a.console&&console.warn&&console.warn("Unable to shim "+b)}}c("shimIndexedDB",b.shimIndexedDB),a.shimIndexedDB&&(a.shimIndexedDB.__useShim=function(){"undefined"!=typeof a.openDatabase?(c("indexedDB",b.shimIndexedDB),c("IDBFactory",b.IDBFactory),c("IDBDatabase",b.IDBDatabase),c("IDBObjectStore",b.IDBObjectStore),c("IDBIndex",b.IDBIndex),c("IDBTransaction",b.IDBTransaction),c("IDBCursor",b.IDBCursor),c("IDBKeyRange",b.IDBKeyRange),c("IDBRequest",b.IDBRequest),c("IDBOpenDBRequest",b.IDBOpenDBRequest),c("IDBVersionChangeEvent",b.IDBVersionChangeEvent)):"object"==typeof a.indexedDB&&b.polyfill()},a.shimIndexedDB.__debug=function(a){b.DEBUG=a}),"indexedDB"in a||(a.indexedDB=a.indexedDB||a.webkitIndexedDB||a.mozIndexedDB||a.oIndexedDB||a.msIndexedDB);var d=!1;if((navigator.userAgent.match(/Android 2/)||navigator.userAgent.match(/Android 3/)||navigator.userAgent.match(/Android 4\.[0-3]/))&&(navigator.userAgent.match(/Chrome/)||(d=!0)),"undefined"!=typeof a.indexedDB&&a.indexedDB&&!d||"undefined"==typeof a.openDatabase){a.IDBDatabase=a.IDBDatabase||a.webkitIDBDatabase,a.IDBTransaction=a.IDBTransaction||a.webkitIDBTransaction,a.IDBCursor=a.IDBCursor||a.webkitIDBCursor,a.IDBKeyRange=a.IDBKeyRange||a.webkitIDBKeyRange,a.IDBTransaction||(a.IDBTransaction={});try{a.IDBTransaction.READ_ONLY=a.IDBTransaction.READ_ONLY||"readonly",a.IDBTransaction.READ_WRITE=a.IDBTransaction.READ_WRITE||"readwrite"}catch(e){}}else a.shimIndexedDB.__useShim()}(window,idbModules);

}
GlobalContext.setModule("component/indexedDBShim.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/inputTabGroup.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var InputTabGroup;

  InputTabGroup = (function() {
    function InputTabGroup(inputs) {
      this.handleKey = this.handleKey.bind(this);
      this.inputs = [];
      this.disableEnterSwitch = false;
      if (inputs) {
        this.setInputs(inputs);
      }
      this.activate();
    }

    InputTabGroup.prototype.setInputs = function(inputs) {
      var i, input, j, len, len1, ref, ref1, results;
      if (inputs == null) {
        inputs = [];
      }
      inputs = inputs.filter(function(item) {
        return item;
      });
      ref = this.inputs;
      for (i = 0, len = ref.length; i < len; i++) {
        input = ref[i];
        if (!input) {
          continue;
        }
        if (typeof input.stopListenBy === "function") {
          input.stopListenBy(this);
        } else {
          input.removeEventListener("keydown", this.handleKey, true);
        }
      }
      this.inputs = inputs;
      ref1 = this.inputs;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        input = ref1[j];
        if (!input) {
          continue;
        }
        results.push((function(_this) {
          return function(input) {
            if (typeof input.listenBy === "function") {
              return input.listenBy(_this, "keydown", function(e) {
                return _this.handleKey(e, input);
              });
            } else {
              return input.addEventListener("keydown", _this.handleKey, true);
            }
          };
        })(this)(input));
      }
      return results;
    };

    InputTabGroup.prototype.handleKey = function(e, input) {
      if (!this.isActive) {
        return false;
      }
      if (input == null) {
        input = e.srcElement || e.target;
      }
      if (e.which === Leaf.Key.tab || (!this.disableEnterSwitch && e.which === Leaf.Key.enter && input !== this.inputs[this.inputs.length - 1])) {
        if (e.shiftKey) {
          this.previous(input);
        } else {
          this.next(input);
        }
        e.preventDefault();
        return e.stopImmediatePropagation();
      }
    };

    InputTabGroup.prototype.next = function(input) {
      var i, index, item, len, ref, target;
      ref = this.inputs;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        if (item === input) {
          input.blur();
          target = this.inputs[index + 1] || this.inputs[0];
          if (target != null) {
            target.focus();
          }
          return true;
        }
      }
      return false;
    };

    InputTabGroup.prototype.previous = function(input) {
      var i, index, item, len, ref, target;
      ref = this.inputs;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        if (item === input) {
          input.blur();
          target = this.inputs[index - 1] || this.inputs[this.inputs.length - 1];
          if (target != null) {
            target.focus();
          }
          return true;
        }
      }
      return false;
    };

    InputTabGroup.prototype.activate = function() {
      return this.isActive = true;
    };

    InputTabGroup.prototype.deactivate = function() {
      return this.isActive = false;
    };

    return InputTabGroup;

  })();

  module.exports = InputTabGroup;

}).call(this);

}
GlobalContext.setModule("component/inputTabGroup.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/isElementVisible.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports.visibleInScroll = function(el, padding) {
    var parent, rect, ref;
    if (padding == null) {
      padding = 0;
    }
    parent = el.parentElement;
    if (!parent) {
      return false;
    }
    if (el.offsetTop > parent.scrollTop + parent.clientHeight + padding) {
      return false;
    } else if (el.offsetTop + el.offsetHeight + padding < parent.scrollTopxo) {
      return false;
    }
    rect = el.getBoundingClientRect();
    if ((rect != null ? rect.top : void 0) > ((ref = window.screen) != null ? ref.height : void 0)) {
      return false;
    }
    if ((rect != null ? rect.bottom : void 0) < 0) {
      return false;
    }
    return true;
  };

}).call(this);

}
GlobalContext.setModule("component/isElementVisible.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/longpress.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Longpress,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Longpress = (function(superClass) {
    extend(Longpress, superClass);

    function Longpress(node, option) {
      this.node = node;
      if (option == null) {
        option = {};
      }
      Longpress.__super__.constructor.call(this);
      this.delay = option.delay || 500;
      this.effectClass = option.effectClass || "longpress";
      this.touchStartListener = this.touchStartListener.bind(this);
      this.touchMoveListener = this.touchMoveListener.bind(this);
      this.touchEndListener = this.touchEndListener.bind(this);
      this.contextMenuPreventor = this.contextMenuPreventor.bind();
      this.attach();
    }

    Longpress.prototype.attach = function() {
      this.node.classList.add("no-select");
      this.node.addEventListener("touchstart", this.touchStartListener);
      this.node.addEventListener("touchmove", this.touchMoveListener);
      this.node.addEventListener("touchend", this.touchEndListener);
      this.node.addEventListener("touchcancel", this.touchEndListener);
      return this.node.addEventListener("contextmenu", this.contextMenuPreventor);
    };

    Longpress.prototype.detach = function() {
      this.node.classList.remove("no-select");
      this.node.removeEventListener("touchstart", this.touchStartListener);
      this.node.removeEventListener("touchmove", this.touchMoveListener);
      this.node.removeEventListener("touchend", this.touchEndListener);
      this.node.removeEventListener("touchcancel", this.touchEndListener);
      return this.node.removeEventListener("contextmenu", this.contextMenuPreventor);
    };

    Longpress.prototype.contextMenuPreventor = function(e) {
      e.preventDefault();
      return e.stopImmediatePropagation();
    };

    Longpress.prototype.touchStartListener = function(e) {
      if (e.touches.length > 1) {
        return;
      }
      this.startPoint = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      };
      clearTimeout(this.timer);
      this.node.classList.add(this.effectClass);
      return this.timer = setTimeout((function(_this) {
        return function() {
          return _this.trigger();
        };
      })(this), this.delay);
    };

    Longpress.prototype.touchMoveListener = function(e) {
      var cp, dx, dy;
      cp = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      };
      dx = cp.x - this.startPoint.x;
      dy = cp.y - this.startPoint.y;
      if (Math.sqrt(dx * dx + dy * dy) > 10) {
        return this.cancel();
      }
    };

    Longpress.prototype.touchEndListener = function(e) {
      return this.cancel();
    };

    Longpress.prototype.cancel = function() {
      clearTimeout(this.timer);
      this.timer = null;
      return this.node.classList.remove(this.effectClass);
    };

    Longpress.prototype.trigger = function() {
      clearTimeout(this.timer);
      this.timer = null;
      this.node.classList.remove(this.effectClass);
      return this.emit("longpress");
    };

    return Longpress;

  })(Leaf.EventEmitter);

  module.exports = Longpress;

}).call(this);

}
GlobalContext.setModule("component/longpress.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/markdown.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports.render = function(text) {
    var converter, html, showdown;
    showdown = require('./showdown');
    converter = new showdown.Converter();
    html = converter.makeHtml(text);
    return html;
  };

}).call(this);

}
GlobalContext.setModule("component/markdown.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/mathJaxAdapter.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var MathJaxAdapter, SharedCallbacks,
    slice = [].slice;

  SharedCallbacks = require("./sharedCallbacks");

  MathJaxAdapter = (function() {
    MathJaxAdapter.prototype.version = "2.6-latest";

    MathJaxAdapter.prototype.config = {
      config: ["MMLorHTML.js"],
      jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/HTML-CSS", "output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js", "mml2jax.js", "asciimath2jax.js", "MathMenu.js", "MathZoom.js", "fast-preview.js", "AssistiveMML.js"],
      TeX: {
        extensions: ["AMSmath.js", "AMSsymbols.js", "noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [["$", "$"]],
        preview: "none"
      },
      skipStartupTypeset: true,
      messageStyle: "none"
    };

    MathJaxAdapter.prototype.readyCallback = null;

    MathJaxAdapter.prototype.currentError = null;

    function MathJaxAdapter(config) {
      var prop, ref, value;
      if (config == null) {
        config = null;
      }
      if (window.MathJaxAdapterInstance) {
        return window.MathJaxAdapterInstance;
      }
      this.readyCallback = SharedCallbacks.create();
      window.MathJaxAdapterInstance = this;
      window.MathJax = {
        AuthorInit: function() {
          return window.MathJax.Hub.Register.StartupHook("End", function() {
            return window.MathJaxAdapterInstance._ready(window.MathJax);
          });
        }
      };
      if (config) {
        this.config = config;
      }
      ref = this.config;
      for (prop in ref) {
        value = ref[prop];
        window.MathJax[prop] = value;
      }
      return;
    }

    MathJaxAdapter.prototype.configString = "TeX-AMS-MML_HTMLorMML";

    MathJaxAdapter.prototype.configString = "TeX-MML-AM_HTMLorMML";

    MathJaxAdapter.prototype.configString = "TeX-AMS_CHTML";

    MathJaxAdapter.prototype.render = function(el, callback) {
      var done;
      done = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return callback(null);
      };
      return this.load((function(_this) {
        return function() {
          return _this.MathJax.Hub.Queue(["Typeset", _this.MathJax.Hub, el, done]);
        };
      })(this));
    };

    MathJaxAdapter.prototype.load = function(callback) {
      var script;
      if (callback == null) {
        callback = function() {};
      }
      if (this.MathJax) {
        callback(null, this.MathJax);
        return;
      }
      this.readyCallback.push(callback);
      if (this.isLoading) {
        return;
      }
      this.isLoading = true;
      script = document.createElement("script");
      script.type = "text/javascript";
      script.src = "//cdn.mathjax.org/mathjax/" + this.version + "/MathJax.js";
      return document.body.appendChild(script);
    };

    MathJaxAdapter.prototype._ready = function(MathJax) {
      return setTimeout((function(_this) {
        return function() {
          _this.isLoading = false;
          _this.MathJax = MathJax;
          return _this.readyCallback(null, MathJax);
        };
      })(this), 0);
    };

    MathJaxAdapter.prototype.setConfigOptions = function(option) {
      var prop, results, value;
      for (prop in option) {
        value = option[prop];
        this.config[prop] = value;
      }
      results = [];
      for (prop in option) {
        value = option[prop];
        results.push(window.MathJax[prop] = value);
      }
      return results;
    };

    return MathJaxAdapter;

  })();

  module.exports = MathJaxAdapter;

}).call(this);

}
GlobalContext.setModule("component/mathJaxAdapter.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/messageCenter.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var EventEmitter, MessageCenter, ReadableStream, WritableStream,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  EventEmitter = Leaf.EventEmitter;

  MessageCenter = (function(superClass) {
    extend(MessageCenter, superClass);

    MessageCenter.normalize = function(obj) {
      var _, item, prop;
      if (typeof obj !== "object") {
        return obj;
      }
      if (obj instanceof Array) {
        return (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = obj.length; i < len; i++) {
            item = obj[i];
            results.push(this.normalize(item));
          }
          return results;
        }).call(this);
      }
      if (obj === null) {
        return null;
      } else if (obj instanceof Buffer) {
        return {
          __mc_type: "buffer",
          value: obj.toString("base64")
        };
      } else if (obj instanceof Date) {
        return {
          __mc_type: "date",
          value: obj.getTime()
        };
      } else if (obj instanceof WritableStream) {
        return {
          __mc_type: "stream",
          id: obj.id
        };
      } else {
        _ = {};
        for (prop in obj) {
          _[prop] = this.normalize(obj[prop]);
        }
        return _;
      }
    };

    MessageCenter.denormalize = function(obj, option) {
      var _, item, prop;
      if (option == null) {
        option = {};
      }
      if (typeof obj !== "object") {
        return obj;
      }
      if (obj === null) {
        return null;
      }
      if (obj instanceof Array) {
        return (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = obj.length; i < len; i++) {
            item = obj[i];
            results.push(this.denormalize(item, option));
          }
          return results;
        }).call(this);
      } else if (obj.__mc_type === "buffer") {
        return new Buffer(obj.value, "base64");
      } else if (obj.__mc_type === "date") {
        return new Date(obj.value);
      } else if (obj.__mc_type === "stream") {
        return new ReadableStream(option.owner, obj.id);
      } else {
        _ = {};
        for (prop in obj) {
          _[prop] = this.denormalize(obj[prop], option);
        }
        return _;
      }
    };

    MessageCenter.parse = function(str, option) {
      var _, json;
      json = JSON.parse(str);
      _ = this.denormalize(json, option);
      return _;
    };

    function MessageCenter() {
      this.idPool = 1000;
      this.invokeWaiters = [];
      this.apis = [];
      this.timeout = 1000 * 60;
      this.streams = [];
      this.customType = {};
      MessageCenter.__super__.constructor.call(this);
    }

    MessageCenter.prototype.denormalize = function(obj, option) {
      var ClassObject, _, item, prop;
      if (option == null) {
        option = {};
      }
      if (typeof obj !== "object") {
        return obj;
      }
      if (obj === null) {
        return null;
      }
      if (obj instanceof Array) {
        return (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = obj.length; i < len; i++) {
            item = obj[i];
            results.push(this.denormalize(item, option));
          }
          return results;
        }).call(this);
      } else if (obj.__mc_type === "buffer") {
        return new Buffer(obj.value, "base64");
      } else if (obj.__mc_type === "date") {
        return new Date(obj.value);
      } else if (obj.__mc_type === "stream") {
        return new ReadableStream(option.owner, obj.id);
      } else if (ClassObject = this.getMatchingSerializableType(obj.__mc_type)) {
        return ClassObject.fromJSON(obj.serialized);
      } else {
        _ = {};
        for (prop in obj) {
          _[prop] = this.denormalize(obj[prop], option);
        }
        return _;
      }
    };

    MessageCenter.prototype.normalize = function(obj) {
      var ClassObject, _, item, prop;
      if (typeof obj !== "object") {
        return obj;
      }
      if (obj instanceof Array) {
        return (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = obj.length; i < len; i++) {
            item = obj[i];
            results.push(this.normalize(item));
          }
          return results;
        }).call(this);
      }
      if (obj === null) {
        return null;
      } else if (obj instanceof Buffer) {
        return {
          __mc_type: "buffer",
          value: obj.toString("base64")
        };
      } else if (obj instanceof Date) {
        return {
          __mc_type: "date",
          value: obj.getTime()
        };
      } else if (obj instanceof WritableStream) {
        return {
          __mc_type: "stream",
          id: obj.id
        };
      } else if (ClassObject = this.getMatchingSerializableType(obj)) {
        return {
          __mc_type: obj.__mc_type,
          serialized: obj.toJSON()
        };
      } else {
        _ = {};
        for (prop in obj) {
          _[prop] = this.normalize(obj[prop]);
        }
        return _;
      }
    };

    MessageCenter.prototype.getMatchingSerializableType = function(obj) {
      var ClassObject;
      if (typeof obj === "string") {
        return this.customTypes[obj];
      }
      ClassObject = this.customTypes[obj.__mc_type];
      if (obj instanceof ClassObject) {
        return ClassObject;
      }
      return null;
    };

    MessageCenter.prototype.registerSerializableType = function(name, ClassObject) {
      if (ClassObject.prototype.__mc_type !== name) {
        throw new Error("Serializable must be a constructor with prototype.__mc_type matching the registered name");
      }
      if (typeof ClassObject.fromJSON) {
        throw new Error("Serializable.fromJSON must be a function");
      }
      if (typeof ClassObject.prototype.toJSON) {
        throw new Error("Serializable.prototype.toJSON must be a function");
      }
      return this.customTypes[name] = ClassObject;
    };

    MessageCenter.prototype.parse = function(str, option) {
      var _, json;
      json = JSON.parse(str);
      _ = this.denormalize(json, option);
      return _;
    };

    MessageCenter.prototype.stringify = function(data) {
      return JSON.stringify(this.normalize(obj));
    };

    MessageCenter.prototype.getInvokeId = function() {
      return this.idPool++;
    };

    MessageCenter.prototype.registerApi = function(name, handler, overwrite) {
      var api, i, index, len, ref;
      name = name.trim();
      if (!handler) {
        throw new Error("need handler to work");
      }
      ref = this.apis;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        api = ref[index];
        if (api.name === name) {
          if (!overwrite) {
            throw new Error("duplicated api name " + name);
          } else {
            this.apis[index] = null;
          }
        }
      }
      this.apis = this.apis.filter(function(api) {
        return api;
      });
      return this.apis.push({
        name: name,
        handler: handler
      });
    };

    MessageCenter.prototype.setConnection = function(connection) {
      this.connection = connection;
      this._handler = (function(_this) {
        return function(message) {
          if (_this.connection !== connection) {
            return;
          }
          return _this.handleMessage(message);
        };
      })(this);
      return this.connection.on("message", this._handler);
    };

    MessageCenter.prototype.unsetConnection = function() {
      var i, len, ref, stream;
      if (this.connection) {
        this.connection.removeListener("message", this._handler);
      }
      this._handler = null;
      this.connection = null;
      ref = this.streams.slice();
      for (i = 0, len = ref.length; i < len; i++) {
        stream = ref[i];
        stream.close();
      }
      this.emit("unsetConnection");
      return this.clearAll();
    };

    MessageCenter.prototype.response = function(id, err, data) {
      var e, error1, message;
      message = this.stringify({
        id: id,
        type: "response",
        data: data,
        error: err
      });
      if (!this.connection) {
        return;
      }
      try {
        return this.connection.send(message);
      } catch (error1) {
        e = error1;
      }
    };

    MessageCenter.prototype.invoke = function(name, data, callback) {
      var controller, e, error1, message, req, waiter;
      callback = callback || function() {
        return true;
      };
      req = {
        type: "invoke",
        id: this.getInvokeId(),
        name: name,
        data: data
      };
      waiter = {
        request: req,
        id: req.id,
        callback: callback,
        date: new Date
      };
      this.invokeWaiters.push(waiter);
      message = this.stringify(req);
      controller = {
        _timer: null,
        waiter: waiter,
        timeout: function(value) {
          if (this._timer) {
            clearTimeout(this._timer);
          }
          return this._timer = setTimeout(controller.clear, value);
        },
        clear: (function(_this) {
          return function(error) {
            return _this.clearInvokeWaiter(waiter.id, error || new Error("timeout"));
          };
        })(this)
      };
      waiter.controller = controller;
      controller.timeout(this.timeout);
      if (this.connection) {
        try {
          this.connection.send(message);
        } catch (error1) {
          e = error1;
          controller.clear(e);
          return;
        }
      } else {
        controller.clear(new Error("connection not set"));
      }
      return controller;
    };

    MessageCenter.prototype.fireEvent = function() {
      var e, error1, message, name, params;
      name = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      message = this.stringify({
        type: "event",
        name: name,
        params: params
      });
      if (this.connection) {
        try {
          this.connection.send(message);
        } catch (error1) {
          e = error1;
          return message;
        }
      }
      return message;
    };

    MessageCenter.prototype.handleMessage = function(message) {
      var e, error1, info, ref;
      try {
        info = this.parse(message, {
          owner: this
        });
      } catch (error1) {
        e = error1;
        this.emit("error", new Error("invalid message " + message));
        return;
      }
      if (!info.type || ((ref = info.type) !== "invoke" && ref !== "event" && ref !== "response" && ref !== "stream")) {
        this.emit("error", new Error("invalid message " + message + " invalid info type"));
        return;
      }
      if (info.type === "stream") {
        return this.handleStreamData(info);
      } else if (info.type === "response") {
        return this.handleResponse(info);
      } else if (info.type === "invoke") {
        return this.handleInvoke(info);
      } else if (info.type === "event") {
        return this.handleEvent(info);
      } else {
        return this.emit("error", new Error("invalid message"));
      }
    };

    MessageCenter.prototype.handleEvent = function(info) {
      var args;
      if (!info.name) {
        this.emit("error", new Error("invalid message " + (JSON.stringify(info))));
      }
      args = ["event/" + info.name].concat(info.params || []);
      return this.emit.apply(this, args);
    };

    MessageCenter.prototype.handleResponse = function(info) {
      var found;
      if (!info.id) {
        this.emit("error", new Error("invalid message " + (JSON.stringify(info))));
      }
      found = this.invokeWaiters.some((function(_this) {
        return function(waiter, index) {
          if (waiter.id === info.id) {
            _this.clearInvokeWaiter(info.id, null);
            waiter.callback(info.error, info.data);
            return true;
          }
          return false;
        };
      })(this));
      return found;
    };

    MessageCenter.prototype.clearInvokeWaiter = function(id, error) {
      return this.invokeWaiters = this.invokeWaiters.filter(function(waiter) {
        if (waiter.id === id) {
          if (waiter.controller && waiter.controller._timer) {
            clearTimeout(waiter.controller._timer);
          }
          if (error) {
            waiter.callback(error);
          }
          return false;
        }
        return true;
      });
    };

    MessageCenter.prototype.handleInvoke = function(info) {
      var api, i, len, ref, target;
      if (!info.id || !info.name) {
        this.emit("error", new Error("invalid message " + (JSON.stringify(info))));
      }
      target = null;
      ref = this.apis;
      for (i = 0, len = ref.length; i < len; i++) {
        api = ref[i];
        if (api.name === info.name) {
          target = api;
          break;
        }
      }
      if (!target) {
        return this.response(info.id, {
          message: info.name + " api not found",
          code: "ERRNOTFOUND"
        });
      }
      return target.handler(info.data, (function(_this) {
        return function(err, data) {
          return _this.response(info.id, err, data);
        };
      })(this));
    };

    MessageCenter.prototype.clearAll = function() {
      var results, waiter;
      results = [];
      while (this.invokeWaiters[0]) {
        waiter = this.invokeWaiters[0];
        results.push(this.clearInvokeWaiter(waiter.id, new Error("abort")));
      }
      return results;
    };

    MessageCenter.prototype.createStream = function() {
      var stream;
      stream = new WritableStream(this);
      return stream;
    };

    MessageCenter.prototype.handleStreamData = function(info) {
      if (!info.id) {
        this.emit("error", new Error("invalid stream data " + (JSON.stringify(info))));
      }
      return this.streams.some(function(stream) {
        if (stream.id === info.id) {
          if (info.end) {
            stream.close();
          } else {
            stream.emit("data", info.data);
          }
          return true;
        }
      });
    };

    MessageCenter.prototype.transferStream = function(stream) {
      var data, e, error1, results;
      if (this.connection) {
        try {
          if (stream.isEnd) {
            return;
          }
          results = [];
          while (stream.buffers.length > 0) {
            data = stream.buffers.shift();
            results.push(this.connection.send(data));
          }
          return results;
        } catch (error1) {
          e = error1;
        }
      }
    };

    MessageCenter.prototype.endStream = function(stream) {
      var e, error1;
      this.transferStream(stream);
      if (this.connection) {
        try {
          this.connection.send(JSON.stringify({
            id: stream.id,
            end: true,
            type: "stream"
          }));
          return stream.isEnd = true;
        } catch (error1) {
          e = error1;
        }
      }
    };

    MessageCenter.prototype.addStream = function(stream) {
      if (indexOf.call(this.streams, stream) < 0) {
        return this.streams.push(stream);
      }
    };

    MessageCenter.prototype.removeStream = function(stream) {
      var index;
      index = this.streams.indexOf(stream);
      if (index < 0) {
        return;
      }
      return this.streams.splice(index, 1);
    };

    MessageCenter.isReadableStream = function(stream) {
      return stream instanceof ReadableStream;
    };

    MessageCenter.isWritableStream = function(stream) {
      return stream instanceof WritableStream;
    };

    return MessageCenter;

  })(EventEmitter);

  ReadableStream = (function(superClass) {
    extend(ReadableStream, superClass);

    function ReadableStream(messageCenter, id1) {
      this.messageCenter = messageCenter;
      this.id = id1;
      ReadableStream.__super__.constructor.call(this);
      this.messageCenter.addStream(this);
    }

    ReadableStream.prototype.close = function() {
      if (this.isClose) {
        return;
      }
      this.isClose = true;
      this.emit("end");
      return this.messageCenter.removeStream(this);
    };

    return ReadableStream;

  })(EventEmitter);

  WritableStream = (function(superClass) {
    extend(WritableStream, superClass);

    WritableStream.id = 1000;

    function WritableStream(messageCenter) {
      this.messageCenter = messageCenter;
      WritableStream.__super__.constructor.call(this);
      this.buffers = [];
      this.index = 0;
      this.id = WritableStream.id++;
      this.messageCenter.once("unsetConnection", (function(_this) {
        return function() {
          return _this.isEnd = true;
        };
      })(this));
    }

    WritableStream.prototype.write = function(data) {
      if (this.isEnd) {
        throw new Error("stream already end");
      }
      if (!data) {
        return;
      }
      this.buffers.push(this.messageCenter.stringify({
        id: this.id,
        index: this.index++,
        data: data,
        type: "stream"
      }));
      return this.messageCenter.transferStream(this);
    };

    WritableStream.prototype.end = function(data) {
      if (this.isEnd) {
        throw new Error("stream already end");
      }
      this.write(data);
      this.messageCenter.endStream(this);
      if (process && process.nextTick) {
        return process.nextTick((function(_this) {
          return function() {
            return _this.emit("finish");
          };
        })(this));
      } else {
        return setTimeout(((function(_this) {
          return function() {
            return _this.emit("finish");
          };
        })(this)), 0);
      }
    };

    return WritableStream;

  })(EventEmitter);

  module.exports = MessageCenter;

  module.exports.MessageCenter = MessageCenter;

}).call(this);

}
GlobalContext.setModule("component/messageCenter.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/path.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.8.0
(function() {
    (function(exports){
        var uriregexp = new RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?');
        exports.path = {};
        exports.url = {};
        exports.url.parse = function(url){
            var match = url.match(uriregexp) || {};
            var authority = match[4];
            var authReg = /((([\w]+)(:\w+)?)?@)?([\w.]+)(:(\d+))?/i;
            if(authority){
                var authMatch = authority.match(authReg) || [];
            }else{
                var authMatch = [];
            }
            return {
                protocol:match[1] || null
                ,pathname:match[5] || null
                ,path:match[5] && match[6] && match[5] + match[6] || match[5] || match[6] || null
                ,query:match[7] || null
                ,hash:match[8] || null
                ,port:authMatch[7] || null
                ,auth:authMatch[2] || null
                ,hostname:authMatch[5] || null
                ,host:(authMatch[5] || "") + (authMatch[6] || "") || null
                ,search:match[6] || null
                ,href:url
            }
        }
        exports.url.format = function(urlObject){
            var result = "";
            if(urlObject.protocol)result+=urlObject.protocol+"//";
            if(urlObject.auth)result+=urlObject.auth+"@";
            if(urlObject.host)result+=urlObject.host;
            if(urlObject.pathname){
                result+=urlObject.pathname
            }else{
                //nodejs will add a / if no pathname present
                result+="/"
            }

            if(urlObject.search)result+=urlObject.search;
            if(urlObject.hash)result+=urlObject.hash;
            return result;
        }
        exports.url.resolve = function(base,target){
            if(target == "")return base;
            var targetObject = exports.url.parse(target);
            if(targetObject.protocol)return target;
            var baseObject = exports.url.parse(base);
            // in RFC resolve with #hash will result in #hash
            // in nodejs it will change the base hash
            if(target[0] == "#"){
                baseObject.hash = targetObject.hash;
                return exports.url.format(baseObject)
            }
            targetObject.protocol = baseObject.protocol;

            if(!targetObject.auth){
                targetObject.auth = baseObject.auth || "";
            }
            if(!targetObject.host){
                targetObject.host = baseObject.host
                if(targetObject.pathname){
                    var targetSegments = targetObject.pathname.split("/");
                    if(targetObject.pathname[0]=="/"){
                        // so only depends on targetObject
                        baseObject.pathname = "";
                    }
                    var baseSegments = baseObject.pathname.split("/");
                    baseSegments.pop();
                    baseSegments = baseSegments.filter(function(seg){return seg != "."});
                    targetSegments.forEach(function(tseg,index){
                        if(tseg == ".."){
                            // resolve xxx://root/ with ../../../file result in xxx://root/file
                            // not xxx://root/../../../file
                            // but when no scheme/host available it behaves as RFC specs
                            // I will honour nodejs behavior.
                            if(targetSegments.host){
                                if(baseSegments.length >0 && baseSegments[baseSegments.length-1] != ".."){
                                    baseSegments.pop();
                                }else{
                                    baseSegments.push("..");
                                }
                            }else{
                                if(baseSegments.length >0){
                                    baseSegments.pop();
                                }
                            }
                        }else if(tseg != "."){
                            baseSegments.push(tseg);
                        }else if (tseg == "." && index == targetSegments.length-1){
                            baseSegments.push("")
                        }
                    })
                    var _baseSegments = []
                    var offset = 0;
                    var result = baseSegments.join("/");
                    // here also nodejs will prepend a / if it's empty
                    //
                    if((baseObject.pathname[0] == "/" || targetObject.pathname[0])&& result[0]!="/"){
                        result = "/"+result;
                    }
                    var last = targetSegments[targetSegments.length-1];
                    if(last == ".." && result[result.length-1]!="/"){
                        result += "/";
                    }
                    result = exports.path.normalize(result);
                    targetObject.pathname = result;
                }
                if(!targetObject.pathname){
                    targetObject.pathname = baseObject.pathname;
                }
            }
            return exports.url.format(targetObject);
        }
        var pathReg = /(.*\/)?([^\/]+?)(\.[^\/\.]+)?$/i
        exports.path.dirname = function(path){
            return exports.path.normalize(path.match(pathReg)[1])
        }
        exports.path.basename = function(path){
            var match = path.match(pathReg)
            return match[2]+match[3]
        }
        exports.path.extname = function(path){
            var match = path.match(pathReg)
            return match[3]
        }
        exports.path.normalize = function(path){
            var segs = path.split("/");
            var result = [];
            var offset = 0;
            segs.forEach(function(seg,index){
                if(seg == ".."){
                    if(result.length > offset){
                        result.pop();
                    }else{
                        result.push("..");
                    }
                }else if(seg == "."){
                    return
                }else if(seg){
                    result.push(seg)
                }else if(index < segs.length -1 && index != 0){
                    return
                }else{
                    result.push("");
                }
            })
            return result.join("/");
        }
        exports.path.join = function(){
            var args = [].slice.call(arguments,0)
            return exports.path.normalize(args.join("/"))
        }
        exports.path.resolve = exports.url.resolve;
    })(exports || window);


}).call(this);

}
GlobalContext.setModule("component/path.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/performance.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Performance;

  Performance = (function() {
    Performance.anonymouseIndex = 0;

    Performance.perf = function(name, fn) {
      var perf;
      perf = new Performance();
      perf.start(name);
      fn(perf);
      perf.end(name);
      return perf.reportAll();
    };

    function Performance() {
      this.cache = {};
    }

    Performance.prototype.silent = function(isSilent) {
      this.isSilent = isSilent;
    };

    Performance.prototype.time = function(name) {
      var ref;
      return ((ref = this.cache[name]) != null ? ref.total : void 0) || 0;
    };

    Performance.prototype.start = function(name) {
      var item;
      if (!(item = this.cache[name])) {
        item = this.cache[name] = {
          total: 0
        };
      }
      return this.cache[name].start = performance.now();
    };

    Performance.prototype.end = function(name) {
      var d, item;
      if (!(item = this.cache[name])) {
        return;
      }
      if (!item.start) {
        return;
      }
      d = performance.now() - item.start;
      item.start = null;
      return item.total += d;
    };

    Performance.prototype.clear = function(name) {
      delete this.cache[name];
      if (!name) {
        return this.cache = {};
      }
    };

    Performance.prototype.report = function(name) {
      var ref;
      if (this.isSilent) {
        return;
      }
      return Logger.debug(name + ":" + (((ref = this.cache[name]) != null ? ref.total : void 0) || "unset") + "ms");
    };

    Performance.prototype.reportAll = function() {
      var prop, results;
      if (this.isSilent) {
        return;
      }
      results = [];
      for (prop in this.cache) {
        results.push(this.report(prop));
      }
      return results;
    };

    return Performance;

  })();

  module.exports = Performance;

  window.Perf = Performance;

}).call(this);

}
GlobalContext.setModule("component/performance.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/pollyfill.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  if (typeof window.requestAnimationFrame !== "function") {
    if (window.webkitRequestAnimationFrame) {
      window.requestAnimationFrame = window.webkitRequestAnimationFrame;
    } else if (window.msRequestAnimationFrame) {
      window.requestAnimationFrame = window.msRequestAnimationFrame;
    } else {
      window.requestAnimationFrame = (function(_this) {
        return function(fn) {
          return setTimeout(function() {
            return fn();
          }, 0);
        };
      })(this);
    }
  }

  if (!window.MutationObserver) {
    if (window.webkitMutationObserver) {
      window.MutationObserver = window.webkitMutationObserver;
    }
  }

  
/*
 * DOMParser HTML extension
 * 2012-09-04
 *
 * By Eli Grey, http://eligrey.com
 * Public domain.
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 */

/*! @source https://gist.github.com/1129031 */
/*global document, DOMParser*/

(function(DOMParser) {
    "use strict";

    var
      proto = DOMParser.prototype
    , nativeParse = proto.parseFromString
    ;

    // Firefox/Opera/IE throw errors on unsupported types
    try {
        // WebKit returns null on unsupported types
        if ((new DOMParser()).parseFromString("", "text/html")) {
            // text/html parsing is natively supported
            return;
        }
    } catch (ex) {}

    proto.parseFromString = function(markup, type) {
        if (/^\s*text\/html\s*(?:;|$)/i.test(type)) {
            var
              doc = document.implementation.createHTMLDocument("")
            ;
                if (markup.toLowerCase().indexOf('<!doctype') > -1) {
                    doc.documentElement.innerHTML = markup;
                }
                else {
                    doc.body.innerHTML = markup;
                }
            return doc;
        } else {
            return nativeParse.apply(this, arguments);
        }
    };
}(DOMParser));
;

  module.exports = {};

}).call(this);

}
GlobalContext.setModule("component/pollyfill.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/properties.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Properties,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Properties = (function(superClass) {
    extend(Properties, superClass);

    function Properties(target) {
      Properties.__super__.constructor.call(this);
      this.props = {};
      if (target) {
        this.mixin(target);
      }
    }

    Properties.prototype.define = function() {
      var args, property;
      property = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    };

    Properties.prototype.debug = function(fn) {
      this.isDebug = true;
      if (this.log == null) {
        this.log = fn || Logger.debug.bind(console);
      }
      return this;
    };

    Properties.prototype._log = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.isDebug) {
        return this.log.apply(this, args);
      }
    };

    Properties.prototype.mixin = function(target1) {
      this.target = target1;
      if (!this.target.listenBy) {
        Leaf.EventEmitter.mixin(this.target);
      }
      this.target.get = this.get.bind(this);
      this.target.set = this.set.bind(this);
      this.target.define = this.define.bind(this);
      this.target.getWhenAvailable = this.getWhenAvailable.bind(this);
      this.target.getAndListenBy = this.getAndListenBy.bind(this);
      return this.target.forProperties = this.forProperties.bind(this);
    };

    Properties.prototype.toJSON = function() {
      return JSON.parse(JSON.stringify(this.props));
    };

    Properties.prototype.fromJSON = function(props) {
      var prop, results, value;
      results = [];
      for (prop in props) {
        value = props[prop];
        results.push(this.set(prop, value));
      }
      return results;
    };

    Properties.prototype.forProperties = function(callback) {
      var k, ref, results, v;
      if (callback == null) {
        callback = function() {};
      }
      ref = this.props;
      results = [];
      for (k in ref) {
        v = ref[k];
        results.push(callback(k, v));
      }
      return results;
    };

    Properties.prototype.set = function(key, value) {
      var oldValue;
      oldValue = this.props[key];
      this.props[key] = value;
      this.emit("change", key, value, oldValue);
      this.fire("property", key, value, oldValue);
      this.emit("change/" + key, value, oldValue);
      this.fire("property/" + key, value, oldValue);
      this._log("set prop", key, "from", oldValue, "to", value);
      return value;
    };

    Properties.prototype.fire = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.target).emit.apply(ref, args);
    };

    Properties.prototype.get = function(key) {
      return this.props[key];
    };

    Properties.prototype.getWhenAvailable = function(key, callback) {
      if (typeof this.props[key] !== "undefined") {
        callback(this.props[key]);
        return;
      }
      return this.target.once("property/" + key, function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return callback.apply(null, args);
      });
    };

    Properties.prototype.getAndListenBy = function(who, key, callback) {
      this.target.listenBy(who, "property/" + key, callback);
      if (typeof this.props[key] !== "undefined") {
        return callback.call(who, this.props[key]);
      }
    };

    Properties.prototype.clear = function() {
      var prop, results;
      for (prop in this.props) {
        this.set(prop);
      }
      results = [];
      for (prop in this.props) {
        results.push(delete this.props[prop]);
      }
      return results;
    };

    return Properties;

  })(Leaf.EventEmitter);

  module.exports = Properties;

}).call(this);

}
GlobalContext.setModule("component/properties.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/property.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Property,
    slice = [].slice;

  Property = (function() {
    Property.define = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Property, args, function(){});
    };

    function Property(target, name) {
      this.target = target;
      this.value = this.target[name];
      this.target.__defineGetter__(name, (function(_this) {
        return function() {
          if (_this.handleGet != null) {
            return _this.handleGet();
          }
          return _this.value;
        };
      })(this));
      this.target.__defineSetter__(name, (function(_this) {
        return function(value) {
          var oldValue;
          oldValue = _this.value;
          if (_this.handleBeforeSet) {
            value = _this.handleBeforeSet(value, oldValue);
          }
          _this.value = value;
          if (_this.handleAfterSet) {
            _this.handleAfterSet(value, oldValue);
          }
          return value;
        };
      })(this));
    }

    Property.prototype.get = function(handler) {
      return this.handleGet = handler;
    };

    Property.prototype.atGet = function(handler) {
      this.handleGet = handler;
      return this;
    };

    Property.prototype.beforeSet = function(handler) {
      this.handleBeforeSet = handler;
      return this;
    };

    Property.prototype.afterSet = function(handler) {
      this.handleAfterSet = handler;
      return this;
    };

    Property.prototype.define = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return Property.define.apply(Property, args);
    };

    return Property;

  })();

  module.exports = Property;

}).call(this);

}
GlobalContext.setModule("component/property.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/querystring.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var pathModule;

  pathModule = require("./path");

  module.exports = {
    parse: function(string) {
      var i, k, len, obj, part, parts, query, ref, result, v;
      if (string == null) {
        string = window.location.toString();
      }
      obj = pathModule.url.parse(string);
      query = obj.query;
      parts = query.split("&");
      result = {};
      for (i = 0, len = parts.length; i < len; i++) {
        part = parts[i];
        ref = part.split("="), k = ref[0], v = ref[1];
        if (k) {
          result[k] = v;
        }
      }
      return result;
    },
    decode: function(string) {
      return this.parse(string);
    }
  };

}).call(this);

}
GlobalContext.setModule("component/querystring.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/router.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Router, urlModule;

  urlModule = (require("./path")).url;

  module.exports = Router = (function() {
    function Router() {
      this.routes = [];
    }

    Router.prototype.parseQuery = function(query) {
      var kvs;
      if (query[0] === "?") {
        query = query.substring(1);
      }
      kvs = {};
      query.split("&").forEach(function(item) {
        var kv;
        if (!item) {
          return;
        }
        kv = item.split("=");
        return kvs[kv[0]] = kvs[kv[1]];
      });
      return kvs;
    };

    Router.prototype.parsePath = function(matcher, url) {
      var kv, match;
      match = url.match(matcher.reg);
      kv = {};
      if (!match) {
        return null;
      }
      matcher.keywords.forEach(function(key, index) {
        return kv[key] = match[index + 1];
      });
      return kv;
    };

    Router.prototype.genRouteMatcher = function(url) {
      var keywords, lastIndex, paramReg, regStr, result;
      paramReg = /(:[^\/]+)|(\*.+)/ig;
      lastIndex = 0;
      regStr = "^";
      keywords = [];
      while (true) {
        result = paramReg.exec(url);
        if (!result) {
          break;
        }
        regStr += url.substring(lastIndex, result.index);
        if (result[0][0] === ":") {
          regStr += "([^/]*)";
          keywords.push(result[0].replace(":", ""));
        } else if (result[0][0] === "*") {
          regStr += "(.*)";
          keywords.push(result[0].replace("*", ""));
        }
        lastIndex = result.index + result[0].length;
      }
      regStr += url.substring(lastIndex);
      if (regStr[regStr.length - 1] === "/") {
        regStr = regStr.substring(regStr, regStr.length - 1);
      }
      regStr += "/?";
      regStr += "$";
      return {
        reg: new RegExp(regStr),
        keywords: keywords,
        source: url
      };
    };

    Router.prototype.route = function(route, callback) {
      return this.routes.push({
        matcher: this.genRouteMatcher(route),
        callback: callback
      });
    };

    Router.prototype.handle = function(url) {
      var path, urlObject;
      urlObject = urlModule.parse(url);
      path = urlObject.pathname;
      return this.routes.some((function(_this) {
        return function(route) {
          var params;
          if (route.matcher.reg.test(path)) {
            params = _this.parsePath(route.matcher, path);
            route.callback(params);
            return true;
          }
        };
      })(this));
    };

    Router.prototype.getRouteParameter = function(url) {
      var path, result, urlObject;
      if (!url) {
        url = window.location.toString();
      }
      result = null;
      urlObject = urlModule.parse(url);
      path = urlObject.pathname;
      this.routes.some((function(_this) {
        return function(route) {
          var params;
          if (route.matcher.reg.test(path)) {
            params = _this.parsePath(route.matcher, path);
            result = params;
            return true;
          }
        };
      })(this));
      return result;
    };

    return Router;

  })();

  module.exports = Router;

}).call(this);

}
GlobalContext.setModule("component/router.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/scrollChecker.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var ScrollChecker,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ScrollChecker = (function(superClass) {
    extend(ScrollChecker, superClass);

    function ScrollChecker(node) {
      ScrollChecker.__super__.constructor.call(this);
      this.eventDriven = true;
      if (node) {
        this.attach(node);
      }
      this.fire = this.fire.bind(this);
      this.debounce = -1;
    }

    ScrollChecker.prototype.attach = function(node) {
      if (!node) {
        throw new Error("scroll check need to attach to HTMLElement");
      }
      if (this.node) {
        this.detach(this.node);
      }
      this.node = node;
      this.node.classList.add("scroller");
      this.lastValue = this.node.scrollTop;
      if (this.eventDriven) {
        this.node.addEventListener("scroll", this.check.bind(this), true);
      } else {
        return this.timer = setInterval(this.check.bind(this), 100);
      }
    };

    ScrollChecker.prototype.fire = function() {
      return setTimeout((function(_this) {
        return function() {
          return _this.emit("scroll");
        };
      })(this));
    };

    ScrollChecker.prototype.detach = function(node) {
      if (this.node === node || !node) {
        clearTimeout(this.timer);
        this.node.removeEventListener("scroll", this.fire);
        this.node.classList.remove("scroller");
        this.node = null;
      }
      return this.lastValue = null;
    };

    ScrollChecker.prototype.check = function() {
      clearTimeout(this.timer);
      if (this.debounce > 0) {
        return this.timer = setTimeout((function(_this) {
          return function() {
            return _this._check();
          };
        })(this), this.debounce);
      } else {
        return this._check();
      }
    };

    ScrollChecker.prototype._check = function() {
      var lastValue, value;
      if (!this.node) {
        return;
      }
      value = this.node.scrollTop;
      lastValue = this.lastValue;
      this.lastValue = value;
      if (this.lastValue !== null) {
        if (value !== lastValue) {
          if (value > lastValue) {
            this.emit("scrollDown");
          } else if (value < lastValue) {
            this.emit("scrollUp");
          }
          this.emit("scroll");
          if (this.node.offsetHeight + this.node.scrollTop >= this.node.scrollHeight) {
            this.emit("scrollBottom");
          }
          if (this.node.scrollTop === 0) {
            return this.emit("scrollTop");
          }
        }
      }
    };

    return ScrollChecker;

  })(Leaf.EventEmitter);

  module.exports = ScrollChecker;

}).call(this);

}
GlobalContext.setModule("component/scrollChecker.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/scrollVisibility.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var ScrollVisibility;

  ScrollVisibility = (function() {
    function ScrollVisibility(node) {
      this.node = node;
      this.node$ = $(this.node);
    }

    ScrollVisibility.prototype.ensureVisible = function(el) {
      var height, size, top;
      if (!this.node.contains(el)) {
        return false;
      }
      top = this.node.scrollTop;
      height = this.node$.height();
      size = $(el).height();
      if (top > el.offsetTop) {
        this.node.scrollTop = el.offsetTop - size;
      } else if (top + height < el.offsetTop + size) {
        this.node.scrollTop = el.offsetTop + size - height;
      }
      return true;
    };

    return ScrollVisibility;

  })();

  module.exports = ScrollVisibility;

}).call(this);

}
GlobalContext.setModule("component/scrollVisibility.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/sequenceAnimation.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var AnimationFrame, SequenceAnimation, async,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  async = require("async");

  AnimationFrame = require("animationFrame");

  SequenceAnimation = (function(superClass) {
    extend(SequenceAnimation, superClass);

    function SequenceAnimation(node, option) {
      this.node = node;
      this.option = option != null ? option : {};
      SequenceAnimation.__super__.constructor.call(this);
      this.effectClass = this.option.effectClass || "on";
      this.targetClass = this.option.targetClass || "sequence";
      this.interval = this.option.interval || 40;
      this.delay = this.option.delay || 0;
      this.setState("wait");
    }

    SequenceAnimation.prototype.invoke = function() {
      if (this.state !== "wait") {
        return;
      }
      return this.setState("turnOn");
    };

    SequenceAnimation.prototype.revoke = function() {
      if (this.state !== "wait") {
        return;
      }
      return this.setState("turnOff");
    };

    SequenceAnimation.prototype.atWait = function() {};

    SequenceAnimation.prototype.atTurnOn = function(stale) {
      this.data.sequence = this.node.querySelectorAll("." + this.targetClass);
      this.data.index = 0;
      this.data.action = "on";
      this.data.reverse = false;
      this.data.instant = false;
      if (this.delay > 0) {
        return setTimeout((function(_this) {
          return function() {
            return AnimationFrame.nextFrame(function() {
              if (stale()) {
                return;
              }
              return _this.setState("next");
            });
          };
        })(this), this.delay);
      } else {
        return this.setState("next");
      }
    };

    SequenceAnimation.prototype.atTurnOff = function(stale) {
      this.data.sequence = this.node.querySelectorAll("." + this.targetClass);
      this.data.index = this.data.sequence.length - 1;
      this.data.action = "off";
      this.data.reverse = true;
      this.data.instant = true;
      this.setState("next");
      if (this.delay > 0) {
        return setTimeout((function(_this) {
          return function() {
            return AnimationFrame.nextFrame(function() {
              if (stale()) {
                return;
              }
              return _this.setState("next");
            });
          };
        })(this), this.delay);
      } else {
        return this.setState("next");
      }
    };

    SequenceAnimation.prototype.atNext = function(stale) {
      var ref;
      if (!((ref = this.data.sequence) != null ? ref[this.data.index] : void 0)) {
        this.setState("wait");
        return;
      }
      if (this.data.action === "on") {
        this.data.sequence[this.data.index].classList.add(this.effectClass);
      } else {
        this.data.sequence[this.data.index].classList.remove(this.effectClass);
      }
      if (this.data.reverse) {
        this.data.index -= 1;
      } else {
        this.data.index += 1;
      }
      if (this.data.instant) {
        return this.setState("next");
      } else {
        return setTimeout((function(_this) {
          return function() {
            return AnimationFrame.nextFrame(function() {
              if (stale()) {
                return;
              }
              return _this.setState("next");
            });
          };
        })(this), this.interval);
      }
    };

    return SequenceAnimation;

  })(Leaf.States);

  module.exports = SequenceAnimation;

}).call(this);

}
GlobalContext.setModule("component/sequenceAnimation.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/sequenceDiagram.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    //  \\
//  Raphal 2.1.4 - JavaScript Vector Library                           \\
//  \\
//  Copyright  2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)     \\
//  Copyright  2008-2012 Sencha Labs (http://sencha.com)               \\
//  \\
//  Licensed under the MIT (http://raphaeljs.com/license.html) license. \\
//  \\
!function(a){var b,c,d="0.4.2",e="hasOwnProperty",f=/[\.\/]/,g="*",h=function(){},i=function(a,b){return a-b},j={n:{}},k=function(a,d){a=String(a);var e,f=c,g=Array.prototype.slice.call(arguments,2),h=k.listeners(a),j=0,l=[],m={},n=[],o=b;b=a,c=0;for(var p=0,q=h.length;q>p;p++)"zIndex"in h[p]&&(l.push(h[p].zIndex),h[p].zIndex<0&&(m[h[p].zIndex]=h[p]));for(l.sort(i);l[j]<0;)if(e=m[l[j++]],n.push(e.apply(d,g)),c)return c=f,n;for(p=0;q>p;p++)if(e=h[p],"zIndex"in e)if(e.zIndex==l[j]){if(n.push(e.apply(d,g)),c)break;do if(j++,e=m[l[j]],e&&n.push(e.apply(d,g)),c)break;while(e)}else m[e.zIndex]=e;else if(n.push(e.apply(d,g)),c)break;return c=f,b=o,n.length?n:null};k._events=j,k.listeners=function(a){var b,c,d,e,h,i,k,l,m=a.split(f),n=j,o=[n],p=[];for(e=0,h=m.length;h>e;e++){for(l=[],i=0,k=o.length;k>i;i++)for(n=o[i].n,c=[n[m[e]],n[g]],d=2;d--;)b=c[d],b&&(l.push(b),p=p.concat(b.f||[]));o=l}return p},k.on=function(a,b){if(a=String(a),"function"!=typeof b)return function(){};for(var c=a.split(f),d=j,e=0,g=c.length;g>e;e++)d=d.n,d=d.hasOwnProperty(c[e])&&d[c[e]]||(d[c[e]]={n:{}});for(d.f=d.f||[],e=0,g=d.f.length;g>e;e++)if(d.f[e]==b)return h;return d.f.push(b),function(a){+a==+a&&(b.zIndex=+a)}},k.f=function(a){var b=[].slice.call(arguments,1);return function(){k.apply(null,[a,null].concat(b).concat([].slice.call(arguments,0)))}},k.stop=function(){c=1},k.nt=function(a){return a?new RegExp("(?:\\.|\\/|^)"+a+"(?:\\.|\\/|$)").test(b):b},k.nts=function(){return b.split(f)},k.off=k.unbind=function(a,b){if(!a)return void(k._events=j={n:{}});var c,d,h,i,l,m,n,o=a.split(f),p=[j];for(i=0,l=o.length;l>i;i++)for(m=0;m<p.length;m+=h.length-2){if(h=[m,1],c=p[m].n,o[i]!=g)c[o[i]]&&h.push(c[o[i]]);else for(d in c)c[e](d)&&h.push(c[d]);p.splice.apply(p,h)}for(i=0,l=p.length;l>i;i++)for(c=p[i];c.n;){if(b){if(c.f){for(m=0,n=c.f.length;n>m;m++)if(c.f[m]==b){c.f.splice(m,1);break}!c.f.length&&delete c.f}for(d in c.n)if(c.n[e](d)&&c.n[d].f){var q=c.n[d].f;for(m=0,n=q.length;n>m;m++)if(q[m]==b){q.splice(m,1);break}!q.length&&delete c.n[d].f}}else{delete c.f;for(d in c.n)c.n[e](d)&&c.n[d].f&&delete c.n[d].f}c=c.n}},k.once=function(a,b){var c=function(){return k.unbind(a,c),b.apply(this,arguments)};return k.on(a,c)},k.version=d,k.toString=function(){return"You are running Eve "+d},"undefined"!=typeof module&&module.exports?module.exports=k:"undefined"!=typeof define?define("eve",[],function(){return k}):a.eve=k}(window||this),function(a,b){"function"==typeof define&&define.amd?define(["eve"],function(c){return b(a,c)}):b(a,a.eve||"function"==typeof require&&require("eve"))}(this,function(a,b){function c(a){if(c.is(a,"function"))return u?a():b.on("raphael.DOMload",a);if(c.is(a,V))return c._engine.create[D](c,a.splice(0,3+c.is(a[0],T))).add(a);var d=Array.prototype.slice.call(arguments,0);if(c.is(d[d.length-1],"function")){var e=d.pop();return u?e.call(c._engine.create[D](c,d)):b.on("raphael.DOMload",function(){e.call(c._engine.create[D](c,d))})}return c._engine.create[D](c,arguments)}function d(a){if("function"==typeof a||Object(a)!==a)return a;var b=new a.constructor;for(var c in a)a[z](c)&&(b[c]=d(a[c]));return b}function e(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return a.push(a.splice(c,1)[0])}function f(a,b,c){function d(){var f=Array.prototype.slice.call(arguments,0),g=f.join(""),h=d.cache=d.cache||{},i=d.count=d.count||[];return h[z](g)?(e(i,g),c?c(h[g]):h[g]):(i.length>=1e3&&delete h[i.shift()],i.push(g),h[g]=a[D](b,f),c?c(h[g]):h[g])}return d}function g(){return this.hex}function h(a,b){for(var c=[],d=0,e=a.length;e-2*!b>d;d+=2){var f=[{x:+a[d-2],y:+a[d-1]},{x:+a[d],y:+a[d+1]},{x:+a[d+2],y:+a[d+3]},{x:+a[d+4],y:+a[d+5]}];b?d?e-4==d?f[3]={x:+a[0],y:+a[1]}:e-2==d&&(f[2]={x:+a[0],y:+a[1]},f[3]={x:+a[2],y:+a[3]}):f[0]={x:+a[e-2],y:+a[e-1]}:e-4==d?f[3]=f[2]:d||(f[0]={x:+a[d],y:+a[d+1]}),c.push(["C",(-f[0].x+6*f[1].x+f[2].x)/6,(-f[0].y+6*f[1].y+f[2].y)/6,(f[1].x+6*f[2].x-f[3].x)/6,(f[1].y+6*f[2].y-f[3].y)/6,f[2].x,f[2].y])}return c}function i(a,b,c,d,e){var f=-3*b+9*c-9*d+3*e,g=a*f+6*b-12*c+6*d;return a*g-3*b+3*c}function j(a,b,c,d,e,f,g,h,j){null==j&&(j=1),j=j>1?1:0>j?0:j;for(var k=j/2,l=12,m=[-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],n=[.2491,.2491,.2335,.2335,.2032,.2032,.1601,.1601,.1069,.1069,.0472,.0472],o=0,p=0;l>p;p++){var q=k*m[p]+k,r=i(q,a,c,e,g),s=i(q,b,d,f,h),t=r*r+s*s;o+=n[p]*N.sqrt(t)}return k*o}function k(a,b,c,d,e,f,g,h,i){if(!(0>i||j(a,b,c,d,e,f,g,h)<i)){var k,l=1,m=l/2,n=l-m,o=.01;for(k=j(a,b,c,d,e,f,g,h,n);Q(k-i)>o;)m/=2,n+=(i>k?1:-1)*m,k=j(a,b,c,d,e,f,g,h,n);return n}}function l(a,b,c,d,e,f,g,h){if(!(O(a,c)<P(e,g)||P(a,c)>O(e,g)||O(b,d)<P(f,h)||P(b,d)>O(f,h))){var i=(a*d-b*c)*(e-g)-(a-c)*(e*h-f*g),j=(a*d-b*c)*(f-h)-(b-d)*(e*h-f*g),k=(a-c)*(f-h)-(b-d)*(e-g);if(k){var l=i/k,m=j/k,n=+l.toFixed(2),o=+m.toFixed(2);if(!(n<+P(a,c).toFixed(2)||n>+O(a,c).toFixed(2)||n<+P(e,g).toFixed(2)||n>+O(e,g).toFixed(2)||o<+P(b,d).toFixed(2)||o>+O(b,d).toFixed(2)||o<+P(f,h).toFixed(2)||o>+O(f,h).toFixed(2)))return{x:l,y:m}}}}function m(a,b,d){var e=c.bezierBBox(a),f=c.bezierBBox(b);if(!c.isBBoxIntersect(e,f))return d?0:[];for(var g=j.apply(0,a),h=j.apply(0,b),i=O(~~(g/5),1),k=O(~~(h/5),1),m=[],n=[],o={},p=d?0:[],q=0;i+1>q;q++){var r=c.findDotsAtSegment.apply(c,a.concat(q/i));m.push({x:r.x,y:r.y,t:q/i})}for(q=0;k+1>q;q++)r=c.findDotsAtSegment.apply(c,b.concat(q/k)),n.push({x:r.x,y:r.y,t:q/k});for(q=0;i>q;q++)for(var s=0;k>s;s++){var t=m[q],u=m[q+1],v=n[s],w=n[s+1],x=Q(u.x-t.x)<.001?"y":"x",y=Q(w.x-v.x)<.001?"y":"x",z=l(t.x,t.y,u.x,u.y,v.x,v.y,w.x,w.y);if(z){if(o[z.x.toFixed(4)]==z.y.toFixed(4))continue;o[z.x.toFixed(4)]=z.y.toFixed(4);var A=t.t+Q((z[x]-t[x])/(u[x]-t[x]))*(u.t-t.t),B=v.t+Q((z[y]-v[y])/(w[y]-v[y]))*(w.t-v.t);A>=0&&1.001>=A&&B>=0&&1.001>=B&&(d?p++:p.push({x:z.x,y:z.y,t1:P(A,1),t2:P(B,1)}))}}return p}function n(a,b,d){a=c._path2curve(a),b=c._path2curve(b);for(var e,f,g,h,i,j,k,l,n,o,p=d?0:[],q=0,r=a.length;r>q;q++){var s=a[q];if("M"==s[0])e=i=s[1],f=j=s[2];else{"C"==s[0]?(n=[e,f].concat(s.slice(1)),e=n[6],f=n[7]):(n=[e,f,e,f,i,j,i,j],e=i,f=j);for(var t=0,u=b.length;u>t;t++){var v=b[t];if("M"==v[0])g=k=v[1],h=l=v[2];else{"C"==v[0]?(o=[g,h].concat(v.slice(1)),g=o[6],h=o[7]):(o=[g,h,g,h,k,l,k,l],g=k,h=l);var w=m(n,o,d);if(d)p+=w;else{for(var x=0,y=w.length;y>x;x++)w[x].segment1=q,w[x].segment2=t,w[x].bez1=n,w[x].bez2=o;p=p.concat(w)}}}}}return p}function o(a,b,c,d,e,f){null!=a?(this.a=+a,this.b=+b,this.c=+c,this.d=+d,this.e=+e,this.f=+f):(this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0)}function p(){return this.x+H+this.y+H+this.width+"  "+this.height}function q(a,b,c,d,e,f){function g(a){return((l*a+k)*a+j)*a}function h(a,b){var c=i(a,b);return((o*c+n)*c+m)*c}function i(a,b){var c,d,e,f,h,i;for(e=a,i=0;8>i;i++){if(f=g(e)-a,Q(f)<b)return e;if(h=(3*l*e+2*k)*e+j,Q(h)<1e-6)break;e-=f/h}if(c=0,d=1,e=a,c>e)return c;if(e>d)return d;for(;d>c;){if(f=g(e),Q(f-a)<b)return e;a>f?c=e:d=e,e=(d-c)/2+c}return e}var j=3*b,k=3*(d-b)-j,l=1-j-k,m=3*c,n=3*(e-c)-m,o=1-m-n;return h(a,1/(200*f))}function r(a,b){var c=[],d={};if(this.ms=b,this.times=1,a){for(var e in a)a[z](e)&&(d[_(e)]=a[e],c.push(_(e)));c.sort(lb)}this.anim=d,this.top=c[c.length-1],this.percents=c}function s(a,d,e,f,g,h){e=_(e);var i,j,k,l,m,n,p=a.ms,r={},s={},t={};if(f)for(v=0,x=ic.length;x>v;v++){var u=ic[v];if(u.el.id==d.id&&u.anim==a){u.percent!=e?(ic.splice(v,1),k=1):j=u,d.attr(u.totalOrigin);break}}else f=+s;for(var v=0,x=a.percents.length;x>v;v++){if(a.percents[v]==e||a.percents[v]>f*a.top){e=a.percents[v],m=a.percents[v-1]||0,p=p/a.top*(e-m),l=a.percents[v+1],i=a.anim[e];break}f&&d.attr(a.anim[a.percents[v]])}if(i){if(j)j.initstatus=f,j.start=new Date-j.ms*f;else{for(var y in i)if(i[z](y)&&(db[z](y)||d.paper.customAttributes[z](y)))switch(r[y]=d.attr(y),null==r[y]&&(r[y]=cb[y]),s[y]=i[y],db[y]){case T:t[y]=(s[y]-r[y])/p;break;case"colour":r[y]=c.getRGB(r[y]);var A=c.getRGB(s[y]);t[y]={r:(A.r-r[y].r)/p,g:(A.g-r[y].g)/p,b:(A.b-r[y].b)/p};break;case"path":var B=Kb(r[y],s[y]),C=B[1];for(r[y]=B[0],t[y]=[],v=0,x=r[y].length;x>v;v++){t[y][v]=[0];for(var D=1,F=r[y][v].length;F>D;D++)t[y][v][D]=(C[v][D]-r[y][v][D])/p}break;case"transform":var G=d._,H=Pb(G[y],s[y]);if(H)for(r[y]=H.from,s[y]=H.to,t[y]=[],t[y].real=!0,v=0,x=r[y].length;x>v;v++)for(t[y][v]=[r[y][v][0]],D=1,F=r[y][v].length;F>D;D++)t[y][v][D]=(s[y][v][D]-r[y][v][D])/p;else{var K=d.matrix||new o,L={_:{transform:G.transform},getBBox:function(){return d.getBBox(1)}};r[y]=[K.a,K.b,K.c,K.d,K.e,K.f],Nb(L,s[y]),s[y]=L._.transform,t[y]=[(L.matrix.a-K.a)/p,(L.matrix.b-K.b)/p,(L.matrix.c-K.c)/p,(L.matrix.d-K.d)/p,(L.matrix.e-K.e)/p,(L.matrix.f-K.f)/p]}break;case"csv":var M=I(i[y])[J](w),N=I(r[y])[J](w);if("clip-rect"==y)for(r[y]=N,t[y]=[],v=N.length;v--;)t[y][v]=(M[v]-r[y][v])/p;s[y]=M;break;default:for(M=[][E](i[y]),N=[][E](r[y]),t[y]=[],v=d.paper.customAttributes[y].length;v--;)t[y][v]=((M[v]||0)-(N[v]||0))/p}var O=i.easing,P=c.easing_formulas[O];if(!P)if(P=I(O).match(Z),P&&5==P.length){var Q=P;P=function(a){return q(a,+Q[1],+Q[2],+Q[3],+Q[4],p)}}else P=nb;if(n=i.start||a.start||+new Date,u={anim:a,percent:e,timestamp:n,start:n+(a.del||0),status:0,initstatus:f||0,stop:!1,ms:p,easing:P,from:r,diff:t,to:s,el:d,callback:i.callback,prev:m,next:l,repeat:h||a.times,origin:d.attr(),totalOrigin:g},ic.push(u),f&&!j&&!k&&(u.stop=!0,u.start=new Date-p*f,1==ic.length))return kc();k&&(u.start=new Date-u.ms*f),1==ic.length&&jc(kc)}b("raphael.anim.start."+d.id,d,a)}}function t(a){for(var b=0;b<ic.length;b++)ic[b].el.paper==a&&ic.splice(b--,1)}c.version="2.1.2",c.eve=b;var u,v,w=/[, ]+/,x={circle:1,rect:1,path:1,ellipse:1,text:1,image:1},y=/\{(\d+)\}/g,z="hasOwnProperty",A={doc:document,win:a},B={was:Object.prototype[z].call(A.win,"Raphael"),is:A.win.Raphael},C=function(){this.ca=this.customAttributes={}},D="apply",E="concat",F="ontouchstart"in A.win||A.win.DocumentTouch&&A.doc instanceof DocumentTouch,G="",H=" ",I=String,J="split",K="click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[J](H),L={mousedown:"touchstart",mousemove:"touchmove",mouseup:"touchend"},M=I.prototype.toLowerCase,N=Math,O=N.max,P=N.min,Q=N.abs,R=N.pow,S=N.PI,T="number",U="string",V="array",W=Object.prototype.toString,X=(c._ISURL=/^url\(['"]?(.+?)['"]?\)$/i,/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i),Y={NaN:1,Infinity:1,"-Infinity":1},Z=/^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,$=N.round,_=parseFloat,ab=parseInt,bb=I.prototype.toUpperCase,cb=c._availableAttrs={"arrow-end":"none","arrow-start":"none",blur:0,"clip-rect":"0 0 1e9 1e9",cursor:"default",cx:0,cy:0,fill:"#fff","fill-opacity":1,font:'10px "Arial"',"font-family":'"Arial"',"font-size":"10","font-style":"normal","font-weight":400,gradient:0,height:0,href:"http://raphaeljs.com/","letter-spacing":0,opacity:1,path:"M0,0",r:0,rx:0,ry:0,src:"",stroke:"#000","stroke-dasharray":"","stroke-linecap":"butt","stroke-linejoin":"butt","stroke-miterlimit":0,"stroke-opacity":1,"stroke-width":1,target:"_blank","text-anchor":"middle",title:"Raphael",transform:"",width:0,x:0,y:0},db=c._availableAnimAttrs={blur:T,"clip-rect":"csv",cx:T,cy:T,fill:"colour","fill-opacity":T,"font-size":T,height:T,opacity:T,path:"path",r:T,rx:T,ry:T,stroke:"colour","stroke-opacity":T,"stroke-width":T,transform:"transform",width:T,x:T,y:T},eb=/[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,fb={hs:1,rg:1},gb=/,?([achlmqrstvxz]),?/gi,hb=/([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi,ib=/([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi,jb=/(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/gi,kb=(c._radial_gradient=/^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,{}),lb=function(a,b){return _(a)-_(b)},mb=function(){},nb=function(a){return a},ob=c._rectPath=function(a,b,c,d,e){return e?[["M",a+e,b],["l",c-2*e,0],["a",e,e,0,0,1,e,e],["l",0,d-2*e],["a",e,e,0,0,1,-e,e],["l",2*e-c,0],["a",e,e,0,0,1,-e,-e],["l",0,2*e-d],["a",e,e,0,0,1,e,-e],["z"]]:[["M",a,b],["l",c,0],["l",0,d],["l",-c,0],["z"]]},pb=function(a,b,c,d){return null==d&&(d=c),[["M",a,b],["m",0,-d],["a",c,d,0,1,1,0,2*d],["a",c,d,0,1,1,0,-2*d],["z"]]},qb=c._getPath={path:function(a){return a.attr("path")},circle:function(a){var b=a.attrs;return pb(b.cx,b.cy,b.r)},ellipse:function(a){var b=a.attrs;return pb(b.cx,b.cy,b.rx,b.ry)},rect:function(a){var b=a.attrs;return ob(b.x,b.y,b.width,b.height,b.r)},image:function(a){var b=a.attrs;return ob(b.x,b.y,b.width,b.height)},text:function(a){var b=a._getBBox();return ob(b.x,b.y,b.width,b.height)},set:function(a){var b=a._getBBox();return ob(b.x,b.y,b.width,b.height)}},rb=c.mapPath=function(a,b){if(!b)return a;var c,d,e,f,g,h,i;for(a=Kb(a),e=0,g=a.length;g>e;e++)for(i=a[e],f=1,h=i.length;h>f;f+=2)c=b.x(i[f],i[f+1]),d=b.y(i[f],i[f+1]),i[f]=c,i[f+1]=d;return a};if(c._g=A,c.type=A.win.SVGAngle||A.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")?"SVG":"VML","VML"==c.type){var sb,tb=A.doc.createElement("div");if(tb.innerHTML='<v:shape adj="1"/>',sb=tb.firstChild,sb.style.behavior="url(#default#VML)",!sb||"object"!=typeof sb.adj)return c.type=G;tb=null}c.svg=!(c.vml="VML"==c.type),c._Paper=C,c.fn=v=C.prototype=c.prototype,c._id=0,c._oid=0,c.is=function(a,b){return b=M.call(b),"finite"==b?!Y[z](+a):"array"==b?a instanceof Array:"null"==b&&null===a||b==typeof a&&null!==a||"object"==b&&a===Object(a)||"array"==b&&Array.isArray&&Array.isArray(a)||W.call(a).slice(8,-1).toLowerCase()==b},c.angle=function(a,b,d,e,f,g){if(null==f){var h=a-d,i=b-e;return h||i?(180+180*N.atan2(-i,-h)/S+360)%360:0}return c.angle(a,b,f,g)-c.angle(d,e,f,g)},c.rad=function(a){return a%360*S/180},c.deg=function(a){return Math.round(180*a/S%360*1e3)/1e3},c.snapTo=function(a,b,d){if(d=c.is(d,"finite")?d:10,c.is(a,V)){for(var e=a.length;e--;)if(Q(a[e]-b)<=d)return a[e]}else{a=+a;var f=b%a;if(d>f)return b-f;if(f>a-d)return b-f+a}return b};c.createUUID=function(a,b){return function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(a,b).toUpperCase()}}(/[xy]/g,function(a){var b=16*N.random()|0,c="x"==a?b:3&b|8;return c.toString(16)});c.setWindow=function(a){b("raphael.setWindow",c,A.win,a),A.win=a,A.doc=A.win.document,c._engine.initWin&&c._engine.initWin(A.win)};var ub=function(a){if(c.vml){var b,d=/^\s+|\s+$/g;try{var e=new ActiveXObject("htmlfile");e.write("<body>"),e.close(),b=e.body}catch(g){b=createPopup().document.body}var h=b.createTextRange();ub=f(function(a){try{b.style.color=I(a).replace(d,G);var c=h.queryCommandValue("ForeColor");return c=(255&c)<<16|65280&c|(16711680&c)>>>16,"#"+("000000"+c.toString(16)).slice(-6)}catch(e){return"none"}})}else{var i=A.doc.createElement("i");i.title="Raphal Colour Picker",i.style.display="none",A.doc.body.appendChild(i),ub=f(function(a){return i.style.color=a,A.doc.defaultView.getComputedStyle(i,G).getPropertyValue("color")})}return ub(a)},vb=function(){return"hsb("+[this.h,this.s,this.b]+")"},wb=function(){return"hsl("+[this.h,this.s,this.l]+")"},xb=function(){return this.hex},yb=function(a,b,d){if(null==b&&c.is(a,"object")&&"r"in a&&"g"in a&&"b"in a&&(d=a.b,b=a.g,a=a.r),null==b&&c.is(a,U)){var e=c.getRGB(a);a=e.r,b=e.g,d=e.b}return(a>1||b>1||d>1)&&(a/=255,b/=255,d/=255),[a,b,d]},zb=function(a,b,d,e){a*=255,b*=255,d*=255;var f={r:a,g:b,b:d,hex:c.rgb(a,b,d),toString:xb};return c.is(e,"finite")&&(f.opacity=e),f};c.color=function(a){var b;return c.is(a,"object")&&"h"in a&&"s"in a&&"b"in a?(b=c.hsb2rgb(a),a.r=b.r,a.g=b.g,a.b=b.b,a.hex=b.hex):c.is(a,"object")&&"h"in a&&"s"in a&&"l"in a?(b=c.hsl2rgb(a),a.r=b.r,a.g=b.g,a.b=b.b,a.hex=b.hex):(c.is(a,"string")&&(a=c.getRGB(a)),c.is(a,"object")&&"r"in a&&"g"in a&&"b"in a?(b=c.rgb2hsl(a),a.h=b.h,a.s=b.s,a.l=b.l,b=c.rgb2hsb(a),a.v=b.b):(a={hex:"none"},a.r=a.g=a.b=a.h=a.s=a.v=a.l=-1)),a.toString=xb,a},c.hsb2rgb=function(a,b,c,d){this.is(a,"object")&&"h"in a&&"s"in a&&"b"in a&&(c=a.b,b=a.s,d=a.o,a=a.h),a*=360;var e,f,g,h,i;return a=a%360/60,i=c*b,h=i*(1-Q(a%2-1)),e=f=g=c-i,a=~~a,e+=[i,h,0,0,h,i][a],f+=[h,i,i,h,0,0][a],g+=[0,0,h,i,i,h][a],zb(e,f,g,d)},c.hsl2rgb=function(a,b,c,d){this.is(a,"object")&&"h"in a&&"s"in a&&"l"in a&&(c=a.l,b=a.s,a=a.h),(a>1||b>1||c>1)&&(a/=360,b/=100,c/=100),a*=360;var e,f,g,h,i;return a=a%360/60,i=2*b*(.5>c?c:1-c),h=i*(1-Q(a%2-1)),e=f=g=c-i/2,a=~~a,e+=[i,h,0,0,h,i][a],f+=[h,i,i,h,0,0][a],g+=[0,0,h,i,i,h][a],zb(e,f,g,d)},c.rgb2hsb=function(a,b,c){c=yb(a,b,c),a=c[0],b=c[1],c=c[2];var d,e,f,g;return f=O(a,b,c),g=f-P(a,b,c),d=0==g?null:f==a?(b-c)/g:f==b?(c-a)/g+2:(a-b)/g+4,d=(d+360)%6*60/360,e=0==g?0:g/f,{h:d,s:e,b:f,toString:vb}},c.rgb2hsl=function(a,b,c){c=yb(a,b,c),a=c[0],b=c[1],c=c[2];var d,e,f,g,h,i;return g=O(a,b,c),h=P(a,b,c),i=g-h,d=0==i?null:g==a?(b-c)/i:g==b?(c-a)/i+2:(a-b)/i+4,d=(d+360)%6*60/360,f=(g+h)/2,e=0==i?0:.5>f?i/(2*f):i/(2-2*f),{h:d,s:e,l:f,toString:wb}},c._path2string=function(){return this.join(",").replace(gb,"$1")};c._preload=function(a,b){var c=A.doc.createElement("img");c.style.cssText="position:absolute;left:-9999em;top:-9999em",c.onload=function(){b.call(this),this.onload=null,A.doc.body.removeChild(this)},c.onerror=function(){A.doc.body.removeChild(this)},A.doc.body.appendChild(c),c.src=a};c.getRGB=f(function(a){if(!a||(a=I(a)).indexOf("-")+1)return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:g};if("none"==a)return{r:-1,g:-1,b:-1,hex:"none",toString:g};!(fb[z](a.toLowerCase().substring(0,2))||"#"==a.charAt())&&(a=ub(a));var b,d,e,f,h,i,j=a.match(X);return j?(j[2]&&(e=ab(j[2].substring(5),16),d=ab(j[2].substring(3,5),16),b=ab(j[2].substring(1,3),16)),j[3]&&(e=ab((h=j[3].charAt(3))+h,16),d=ab((h=j[3].charAt(2))+h,16),b=ab((h=j[3].charAt(1))+h,16)),j[4]&&(i=j[4][J](eb),b=_(i[0]),"%"==i[0].slice(-1)&&(b*=2.55),d=_(i[1]),"%"==i[1].slice(-1)&&(d*=2.55),e=_(i[2]),"%"==i[2].slice(-1)&&(e*=2.55),"rgba"==j[1].toLowerCase().slice(0,4)&&(f=_(i[3])),i[3]&&"%"==i[3].slice(-1)&&(f/=100)),j[5]?(i=j[5][J](eb),b=_(i[0]),"%"==i[0].slice(-1)&&(b*=2.55),d=_(i[1]),"%"==i[1].slice(-1)&&(d*=2.55),e=_(i[2]),"%"==i[2].slice(-1)&&(e*=2.55),("deg"==i[0].slice(-3)||""==i[0].slice(-1))&&(b/=360),"hsba"==j[1].toLowerCase().slice(0,4)&&(f=_(i[3])),i[3]&&"%"==i[3].slice(-1)&&(f/=100),c.hsb2rgb(b,d,e,f)):j[6]?(i=j[6][J](eb),b=_(i[0]),"%"==i[0].slice(-1)&&(b*=2.55),d=_(i[1]),"%"==i[1].slice(-1)&&(d*=2.55),e=_(i[2]),"%"==i[2].slice(-1)&&(e*=2.55),("deg"==i[0].slice(-3)||""==i[0].slice(-1))&&(b/=360),"hsla"==j[1].toLowerCase().slice(0,4)&&(f=_(i[3])),i[3]&&"%"==i[3].slice(-1)&&(f/=100),c.hsl2rgb(b,d,e,f)):(j={r:b,g:d,b:e,toString:g},j.hex="#"+(16777216|e|d<<8|b<<16).toString(16).slice(1),c.is(f,"finite")&&(j.opacity=f),j)):{r:-1,g:-1,b:-1,hex:"none",error:1,toString:g}},c),c.hsb=f(function(a,b,d){return c.hsb2rgb(a,b,d).hex}),c.hsl=f(function(a,b,d){return c.hsl2rgb(a,b,d).hex}),c.rgb=f(function(a,b,c){return"#"+(16777216|c|b<<8|a<<16).toString(16).slice(1)}),c.getColor=function(a){var b=this.getColor.start=this.getColor.start||{h:0,s:1,b:a||.75},c=this.hsb2rgb(b.h,b.s,b.b);return b.h+=.075,b.h>1&&(b.h=0,b.s-=.2,b.s<=0&&(this.getColor.start={h:0,s:1,b:b.b})),c.hex},c.getColor.reset=function(){delete this.start},c.parsePathString=function(a){if(!a)return null;var b=Ab(a);if(b.arr)return Cb(b.arr);var d={a:7,c:6,h:1,l:2,m:2,r:4,q:4,s:4,t:2,v:1,z:0},e=[];return c.is(a,V)&&c.is(a[0],V)&&(e=Cb(a)),e.length||I(a).replace(hb,function(a,b,c){var f=[],g=b.toLowerCase();if(c.replace(jb,function(a,b){b&&f.push(+b)}),"m"==g&&f.length>2&&(e.push([b][E](f.splice(0,2))),g="l",b="m"==b?"l":"L"),"r"==g)e.push([b][E](f));else for(;f.length>=d[g]&&(e.push([b][E](f.splice(0,d[g]))),d[g]););}),e.toString=c._path2string,b.arr=Cb(e),e},c.parseTransformString=f(function(a){if(!a)return null;var b=[];return c.is(a,V)&&c.is(a[0],V)&&(b=Cb(a)),b.length||I(a).replace(ib,function(a,c,d){{var e=[];M.call(c)}d.replace(jb,function(a,b){b&&e.push(+b)}),b.push([c][E](e))}),b.toString=c._path2string,b});var Ab=function(a){var b=Ab.ps=Ab.ps||{};return b[a]?b[a].sleep=100:b[a]={sleep:100},setTimeout(function(){for(var c in b)b[z](c)&&c!=a&&(b[c].sleep--,!b[c].sleep&&delete b[c])}),b[a]};c.findDotsAtSegment=function(a,b,c,d,e,f,g,h,i){var j=1-i,k=R(j,3),l=R(j,2),m=i*i,n=m*i,o=k*a+3*l*i*c+3*j*i*i*e+n*g,p=k*b+3*l*i*d+3*j*i*i*f+n*h,q=a+2*i*(c-a)+m*(e-2*c+a),r=b+2*i*(d-b)+m*(f-2*d+b),s=c+2*i*(e-c)+m*(g-2*e+c),t=d+2*i*(f-d)+m*(h-2*f+d),u=j*a+i*c,v=j*b+i*d,w=j*e+i*g,x=j*f+i*h,y=90-180*N.atan2(q-s,r-t)/S;return(q>s||t>r)&&(y+=180),{x:o,y:p,m:{x:q,y:r},n:{x:s,y:t},start:{x:u,y:v},end:{x:w,y:x},alpha:y}},c.bezierBBox=function(a,b,d,e,f,g,h,i){c.is(a,"array")||(a=[a,b,d,e,f,g,h,i]);var j=Jb.apply(null,a);return{x:j.min.x,y:j.min.y,x2:j.max.x,y2:j.max.y,width:j.max.x-j.min.x,height:j.max.y-j.min.y}},c.isPointInsideBBox=function(a,b,c){return b>=a.x&&b<=a.x2&&c>=a.y&&c<=a.y2},c.isBBoxIntersect=function(a,b){var d=c.isPointInsideBBox;return d(b,a.x,a.y)||d(b,a.x2,a.y)||d(b,a.x,a.y2)||d(b,a.x2,a.y2)||d(a,b.x,b.y)||d(a,b.x2,b.y)||d(a,b.x,b.y2)||d(a,b.x2,b.y2)||(a.x<b.x2&&a.x>b.x||b.x<a.x2&&b.x>a.x)&&(a.y<b.y2&&a.y>b.y||b.y<a.y2&&b.y>a.y)},c.pathIntersection=function(a,b){return n(a,b)},c.pathIntersectionNumber=function(a,b){return n(a,b,1)},c.isPointInsidePath=function(a,b,d){var e=c.pathBBox(a);return c.isPointInsideBBox(e,b,d)&&n(a,[["M",b,d],["H",e.x2+10]],1)%2==1},c._removedFactory=function(a){return function(){b("raphael.log",null,"Raphal: you are calling to method "+a+" of removed object",a)}};var Bb=c.pathBBox=function(a){var b=Ab(a);if(b.bbox)return d(b.bbox);if(!a)return{x:0,y:0,width:0,height:0,x2:0,y2:0};a=Kb(a);for(var c,e=0,f=0,g=[],h=[],i=0,j=a.length;j>i;i++)if(c=a[i],"M"==c[0])e=c[1],f=c[2],g.push(e),h.push(f);else{var k=Jb(e,f,c[1],c[2],c[3],c[4],c[5],c[6]);g=g[E](k.min.x,k.max.x),h=h[E](k.min.y,k.max.y),e=c[5],f=c[6]}var l=P[D](0,g),m=P[D](0,h),n=O[D](0,g),o=O[D](0,h),p=n-l,q=o-m,r={x:l,y:m,x2:n,y2:o,width:p,height:q,cx:l+p/2,cy:m+q/2};return b.bbox=d(r),r},Cb=function(a){var b=d(a);return b.toString=c._path2string,b},Db=c._pathToRelative=function(a){var b=Ab(a);if(b.rel)return Cb(b.rel);c.is(a,V)&&c.is(a&&a[0],V)||(a=c.parsePathString(a));var d=[],e=0,f=0,g=0,h=0,i=0;"M"==a[0][0]&&(e=a[0][1],f=a[0][2],g=e,h=f,i++,d.push(["M",e,f]));for(var j=i,k=a.length;k>j;j++){var l=d[j]=[],m=a[j];if(m[0]!=M.call(m[0]))switch(l[0]=M.call(m[0]),l[0]){case"a":l[1]=m[1],l[2]=m[2],l[3]=m[3],l[4]=m[4],l[5]=m[5],l[6]=+(m[6]-e).toFixed(3),l[7]=+(m[7]-f).toFixed(3);break;case"v":l[1]=+(m[1]-f).toFixed(3);break;case"m":g=m[1],h=m[2];default:for(var n=1,o=m.length;o>n;n++)l[n]=+(m[n]-(n%2?e:f)).toFixed(3)}else{l=d[j]=[],"m"==m[0]&&(g=m[1]+e,h=m[2]+f);for(var p=0,q=m.length;q>p;p++)d[j][p]=m[p]}var r=d[j].length;switch(d[j][0]){case"z":e=g,f=h;break;case"h":e+=+d[j][r-1];break;case"v":f+=+d[j][r-1];break;default:e+=+d[j][r-2],f+=+d[j][r-1]}}return d.toString=c._path2string,b.rel=Cb(d),d},Eb=c._pathToAbsolute=function(a){var b=Ab(a);if(b.abs)return Cb(b.abs);if(c.is(a,V)&&c.is(a&&a[0],V)||(a=c.parsePathString(a)),!a||!a.length)return[["M",0,0]];var d=[],e=0,f=0,g=0,i=0,j=0;"M"==a[0][0]&&(e=+a[0][1],f=+a[0][2],g=e,i=f,j++,d[0]=["M",e,f]);for(var k,l,m=3==a.length&&"M"==a[0][0]&&"R"==a[1][0].toUpperCase()&&"Z"==a[2][0].toUpperCase(),n=j,o=a.length;o>n;n++){if(d.push(k=[]),l=a[n],l[0]!=bb.call(l[0]))switch(k[0]=bb.call(l[0]),k[0]){case"A":k[1]=l[1],k[2]=l[2],k[3]=l[3],k[4]=l[4],k[5]=l[5],k[6]=+(l[6]+e),k[7]=+(l[7]+f);break;case"V":k[1]=+l[1]+f;break;case"H":k[1]=+l[1]+e;break;case"R":for(var p=[e,f][E](l.slice(1)),q=2,r=p.length;r>q;q++)p[q]=+p[q]+e,p[++q]=+p[q]+f;d.pop(),d=d[E](h(p,m));break;case"M":g=+l[1]+e,i=+l[2]+f;default:for(q=1,r=l.length;r>q;q++)k[q]=+l[q]+(q%2?e:f)}else if("R"==l[0])p=[e,f][E](l.slice(1)),d.pop(),d=d[E](h(p,m)),k=["R"][E](l.slice(-2));else for(var s=0,t=l.length;t>s;s++)k[s]=l[s];switch(k[0]){case"Z":e=g,f=i;break;case"H":e=k[1];break;case"V":f=k[1];break;case"M":g=k[k.length-2],i=k[k.length-1];default:e=k[k.length-2],f=k[k.length-1]}}return d.toString=c._path2string,b.abs=Cb(d),d},Fb=function(a,b,c,d){return[a,b,c,d,c,d]},Gb=function(a,b,c,d,e,f){var g=1/3,h=2/3;return[g*a+h*c,g*b+h*d,g*e+h*c,g*f+h*d,e,f]},Hb=function(a,b,c,d,e,g,h,i,j,k){var l,m=120*S/180,n=S/180*(+e||0),o=[],p=f(function(a,b,c){var d=a*N.cos(c)-b*N.sin(c),e=a*N.sin(c)+b*N.cos(c);return{x:d,y:e}});if(k)y=k[0],z=k[1],w=k[2],x=k[3];else{l=p(a,b,-n),a=l.x,b=l.y,l=p(i,j,-n),i=l.x,j=l.y;var q=(N.cos(S/180*e),N.sin(S/180*e),(a-i)/2),r=(b-j)/2,s=q*q/(c*c)+r*r/(d*d);s>1&&(s=N.sqrt(s),c=s*c,d=s*d);var t=c*c,u=d*d,v=(g==h?-1:1)*N.sqrt(Q((t*u-t*r*r-u*q*q)/(t*r*r+u*q*q))),w=v*c*r/d+(a+i)/2,x=v*-d*q/c+(b+j)/2,y=N.asin(((b-x)/d).toFixed(9)),z=N.asin(((j-x)/d).toFixed(9));y=w>a?S-y:y,z=w>i?S-z:z,0>y&&(y=2*S+y),0>z&&(z=2*S+z),h&&y>z&&(y-=2*S),!h&&z>y&&(z-=2*S)}var A=z-y;if(Q(A)>m){var B=z,C=i,D=j;z=y+m*(h&&z>y?1:-1),i=w+c*N.cos(z),j=x+d*N.sin(z),o=Hb(i,j,c,d,e,0,h,C,D,[z,B,w,x])}A=z-y;var F=N.cos(y),G=N.sin(y),H=N.cos(z),I=N.sin(z),K=N.tan(A/4),L=4/3*c*K,M=4/3*d*K,O=[a,b],P=[a+L*G,b-M*F],R=[i+L*I,j-M*H],T=[i,j];if(P[0]=2*O[0]-P[0],P[1]=2*O[1]-P[1],k)return[P,R,T][E](o);o=[P,R,T][E](o).join()[J](",");for(var U=[],V=0,W=o.length;W>V;V++)U[V]=V%2?p(o[V-1],o[V],n).y:p(o[V],o[V+1],n).x;return U},Ib=function(a,b,c,d,e,f,g,h,i){var j=1-i;return{x:R(j,3)*a+3*R(j,2)*i*c+3*j*i*i*e+R(i,3)*g,y:R(j,3)*b+3*R(j,2)*i*d+3*j*i*i*f+R(i,3)*h}},Jb=f(function(a,b,c,d,e,f,g,h){var i,j=e-2*c+a-(g-2*e+c),k=2*(c-a)-2*(e-c),l=a-c,m=(-k+N.sqrt(k*k-4*j*l))/2/j,n=(-k-N.sqrt(k*k-4*j*l))/2/j,o=[b,h],p=[a,g];return Q(m)>"1e12"&&(m=.5),Q(n)>"1e12"&&(n=.5),m>0&&1>m&&(i=Ib(a,b,c,d,e,f,g,h,m),p.push(i.x),o.push(i.y)),n>0&&1>n&&(i=Ib(a,b,c,d,e,f,g,h,n),p.push(i.x),o.push(i.y)),j=f-2*d+b-(h-2*f+d),k=2*(d-b)-2*(f-d),l=b-d,m=(-k+N.sqrt(k*k-4*j*l))/2/j,n=(-k-N.sqrt(k*k-4*j*l))/2/j,Q(m)>"1e12"&&(m=.5),Q(n)>"1e12"&&(n=.5),m>0&&1>m&&(i=Ib(a,b,c,d,e,f,g,h,m),p.push(i.x),o.push(i.y)),n>0&&1>n&&(i=Ib(a,b,c,d,e,f,g,h,n),p.push(i.x),o.push(i.y)),{min:{x:P[D](0,p),y:P[D](0,o)},max:{x:O[D](0,p),y:O[D](0,o)}}}),Kb=c._path2curve=f(function(a,b){var c=!b&&Ab(a);if(!b&&c.curve)return Cb(c.curve);for(var d=Eb(a),e=b&&Eb(b),f={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},g={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},h=(function(a,b,c){var d,e,f={T:1,Q:1};if(!a)return["C",b.x,b.y,b.x,b.y,b.x,b.y];switch(!(a[0]in f)&&(b.qx=b.qy=null),a[0]){case"M":b.X=a[1],b.Y=a[2];break;case"A":a=["C"][E](Hb[D](0,[b.x,b.y][E](a.slice(1))));break;case"S":"C"==c||"S"==c?(d=2*b.x-b.bx,e=2*b.y-b.by):(d=b.x,e=b.y),a=["C",d,e][E](a.slice(1));break;case"T":"Q"==c||"T"==c?(b.qx=2*b.x-b.qx,b.qy=2*b.y-b.qy):(b.qx=b.x,b.qy=b.y),a=["C"][E](Gb(b.x,b.y,b.qx,b.qy,a[1],a[2]));break;case"Q":b.qx=a[1],b.qy=a[2],a=["C"][E](Gb(b.x,b.y,a[1],a[2],a[3],a[4]));break;case"L":a=["C"][E](Fb(b.x,b.y,a[1],a[2]));break;case"H":a=["C"][E](Fb(b.x,b.y,a[1],b.y));break;case"V":a=["C"][E](Fb(b.x,b.y,b.x,a[1]));break;case"Z":a=["C"][E](Fb(b.x,b.y,b.X,b.Y))}return a}),i=function(a,b){if(a[b].length>7){a[b].shift();for(var c=a[b];c.length;)k[b]="A",e&&(l[b]="A"),a.splice(b++,0,["C"][E](c.splice(0,6)));a.splice(b,1),p=O(d.length,e&&e.length||0)}},j=function(a,b,c,f,g){a&&b&&"M"==a[g][0]&&"M"!=b[g][0]&&(b.splice(g,0,["M",f.x,f.y]),c.bx=0,c.by=0,c.x=a[g][1],c.y=a[g][2],p=O(d.length,e&&e.length||0))},k=[],l=[],m="",n="",o=0,p=O(d.length,e&&e.length||0);p>o;o++){d[o]&&(m=d[o][0]),"C"!=m&&(k[o]=m,o&&(n=k[o-1])),d[o]=h(d[o],f,n),"A"!=k[o]&&"C"==m&&(k[o]="C"),i(d,o),e&&(e[o]&&(m=e[o][0]),"C"!=m&&(l[o]=m,o&&(n=l[o-1])),e[o]=h(e[o],g,n),"A"!=l[o]&&"C"==m&&(l[o]="C"),i(e,o)),j(d,e,f,g,o),j(e,d,g,f,o);var q=d[o],r=e&&e[o],s=q.length,t=e&&r.length;f.x=q[s-2],f.y=q[s-1],f.bx=_(q[s-4])||f.x,f.by=_(q[s-3])||f.y,g.bx=e&&(_(r[t-4])||g.x),g.by=e&&(_(r[t-3])||g.y),g.x=e&&r[t-2],g.y=e&&r[t-1]}return e||(c.curve=Cb(d)),e?[d,e]:d},null,Cb),Lb=(c._parseDots=f(function(a){for(var b=[],d=0,e=a.length;e>d;d++){var f={},g=a[d].match(/^([^:]*):?([\d\.]*)/);if(f.color=c.getRGB(g[1]),f.color.error)return null;f.color=f.color.hex,g[2]&&(f.offset=g[2]+"%"),b.push(f)}for(d=1,e=b.length-1;e>d;d++)if(!b[d].offset){for(var h=_(b[d-1].offset||0),i=0,j=d+1;e>j;j++)if(b[j].offset){i=b[j].offset;break}i||(i=100,j=e),i=_(i);for(var k=(i-h)/(j-d+1);j>d;d++)h+=k,b[d].offset=h+"%"}return b}),c._tear=function(a,b){a==b.top&&(b.top=a.prev),a==b.bottom&&(b.bottom=a.next),a.next&&(a.next.prev=a.prev),a.prev&&(a.prev.next=a.next)}),Mb=(c._tofront=function(a,b){b.top!==a&&(Lb(a,b),a.next=null,a.prev=b.top,b.top.next=a,b.top=a)},c._toback=function(a,b){b.bottom!==a&&(Lb(a,b),a.next=b.bottom,a.prev=null,b.bottom.prev=a,b.bottom=a)},c._insertafter=function(a,b,c){Lb(a,c),b==c.top&&(c.top=a),b.next&&(b.next.prev=a),a.next=b.next,a.prev=b,b.next=a},c._insertbefore=function(a,b,c){Lb(a,c),b==c.bottom&&(c.bottom=a),b.prev&&(b.prev.next=a),a.prev=b.prev,b.prev=a,a.next=b},c.toMatrix=function(a,b){var c=Bb(a),d={_:{transform:G},getBBox:function(){return c}};return Nb(d,b),d.matrix}),Nb=(c.transformPath=function(a,b){return rb(a,Mb(a,b))},c._extractTransform=function(a,b){if(null==b)return a._.transform;b=I(b).replace(/\.{3}|\u2026/g,a._.transform||G);var d=c.parseTransformString(b),e=0,f=0,g=0,h=1,i=1,j=a._,k=new o;if(j.transform=d||[],d)for(var l=0,m=d.length;m>l;l++){var n,p,q,r,s,t=d[l],u=t.length,v=I(t[0]).toLowerCase(),w=t[0]!=v,x=w?k.invert():0;"t"==v&&3==u?w?(n=x.x(0,0),p=x.y(0,0),q=x.x(t[1],t[2]),r=x.y(t[1],t[2]),k.translate(q-n,r-p)):k.translate(t[1],t[2]):"r"==v?2==u?(s=s||a.getBBox(1),k.rotate(t[1],s.x+s.width/2,s.y+s.height/2),e+=t[1]):4==u&&(w?(q=x.x(t[2],t[3]),r=x.y(t[2],t[3]),k.rotate(t[1],q,r)):k.rotate(t[1],t[2],t[3]),e+=t[1]):"s"==v?2==u||3==u?(s=s||a.getBBox(1),k.scale(t[1],t[u-1],s.x+s.width/2,s.y+s.height/2),h*=t[1],i*=t[u-1]):5==u&&(w?(q=x.x(t[3],t[4]),r=x.y(t[3],t[4]),k.scale(t[1],t[2],q,r)):k.scale(t[1],t[2],t[3],t[4]),h*=t[1],i*=t[2]):"m"==v&&7==u&&k.add(t[1],t[2],t[3],t[4],t[5],t[6]),j.dirtyT=1,a.matrix=k}a.matrix=k,j.sx=h,j.sy=i,j.deg=e,j.dx=f=k.e,j.dy=g=k.f,1==h&&1==i&&!e&&j.bbox?(j.bbox.x+=+f,j.bbox.y+=+g):j.dirtyT=1}),Ob=function(a){var b=a[0];switch(b.toLowerCase()){case"t":return[b,0,0];case"m":return[b,1,0,0,1,0,0];case"r":return 4==a.length?[b,0,a[2],a[3]]:[b,0];case"s":return 5==a.length?[b,1,1,a[3],a[4]]:3==a.length?[b,1,1]:[b,1]}},Pb=c._equaliseTransform=function(a,b){b=I(b).replace(/\.{3}|\u2026/g,a),a=c.parseTransformString(a)||[],b=c.parseTransformString(b)||[];
for(var d,e,f,g,h=O(a.length,b.length),i=[],j=[],k=0;h>k;k++){if(f=a[k]||Ob(b[k]),g=b[k]||Ob(f),f[0]!=g[0]||"r"==f[0].toLowerCase()&&(f[2]!=g[2]||f[3]!=g[3])||"s"==f[0].toLowerCase()&&(f[3]!=g[3]||f[4]!=g[4]))return;for(i[k]=[],j[k]=[],d=0,e=O(f.length,g.length);e>d;d++)d in f&&(i[k][d]=f[d]),d in g&&(j[k][d]=g[d])}return{from:i,to:j}};c._getContainer=function(a,b,d,e){var f;return f=null!=e||c.is(a,"object")?a:A.doc.getElementById(a),null!=f?f.tagName?null==b?{container:f,width:f.style.pixelWidth||f.offsetWidth,height:f.style.pixelHeight||f.offsetHeight}:{container:f,width:b,height:d}:{container:1,x:a,y:b,width:d,height:e}:void 0},c.pathToRelative=Db,c._engine={},c.path2curve=Kb,c.matrix=function(a,b,c,d,e,f){return new o(a,b,c,d,e,f)},function(a){function b(a){return a[0]*a[0]+a[1]*a[1]}function d(a){var c=N.sqrt(b(a));a[0]&&(a[0]/=c),a[1]&&(a[1]/=c)}a.add=function(a,b,c,d,e,f){var g,h,i,j,k=[[],[],[]],l=[[this.a,this.c,this.e],[this.b,this.d,this.f],[0,0,1]],m=[[a,c,e],[b,d,f],[0,0,1]];for(a&&a instanceof o&&(m=[[a.a,a.c,a.e],[a.b,a.d,a.f],[0,0,1]]),g=0;3>g;g++)for(h=0;3>h;h++){for(j=0,i=0;3>i;i++)j+=l[g][i]*m[i][h];k[g][h]=j}this.a=k[0][0],this.b=k[1][0],this.c=k[0][1],this.d=k[1][1],this.e=k[0][2],this.f=k[1][2]},a.invert=function(){var a=this,b=a.a*a.d-a.b*a.c;return new o(a.d/b,-a.b/b,-a.c/b,a.a/b,(a.c*a.f-a.d*a.e)/b,(a.b*a.e-a.a*a.f)/b)},a.clone=function(){return new o(this.a,this.b,this.c,this.d,this.e,this.f)},a.translate=function(a,b){this.add(1,0,0,1,a,b)},a.scale=function(a,b,c,d){null==b&&(b=a),(c||d)&&this.add(1,0,0,1,c,d),this.add(a,0,0,b,0,0),(c||d)&&this.add(1,0,0,1,-c,-d)},a.rotate=function(a,b,d){a=c.rad(a),b=b||0,d=d||0;var e=+N.cos(a).toFixed(9),f=+N.sin(a).toFixed(9);this.add(e,f,-f,e,b,d),this.add(1,0,0,1,-b,-d)},a.x=function(a,b){return a*this.a+b*this.c+this.e},a.y=function(a,b){return a*this.b+b*this.d+this.f},a.get=function(a){return+this[I.fromCharCode(97+a)].toFixed(4)},a.toString=function(){return c.svg?"matrix("+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)].join()+")":[this.get(0),this.get(2),this.get(1),this.get(3),0,0].join()},a.toFilter=function(){return"progid:DXImageTransform.Microsoft.Matrix(M11="+this.get(0)+", M12="+this.get(2)+", M21="+this.get(1)+", M22="+this.get(3)+", Dx="+this.get(4)+", Dy="+this.get(5)+", sizingmethod='auto expand')"},a.offset=function(){return[this.e.toFixed(4),this.f.toFixed(4)]},a.split=function(){var a={};a.dx=this.e,a.dy=this.f;var e=[[this.a,this.c],[this.b,this.d]];a.scalex=N.sqrt(b(e[0])),d(e[0]),a.shear=e[0][0]*e[1][0]+e[0][1]*e[1][1],e[1]=[e[1][0]-e[0][0]*a.shear,e[1][1]-e[0][1]*a.shear],a.scaley=N.sqrt(b(e[1])),d(e[1]),a.shear/=a.scaley;var f=-e[0][1],g=e[1][1];return 0>g?(a.rotate=c.deg(N.acos(g)),0>f&&(a.rotate=360-a.rotate)):a.rotate=c.deg(N.asin(f)),a.isSimple=!(+a.shear.toFixed(9)||a.scalex.toFixed(9)!=a.scaley.toFixed(9)&&a.rotate),a.isSuperSimple=!+a.shear.toFixed(9)&&a.scalex.toFixed(9)==a.scaley.toFixed(9)&&!a.rotate,a.noRotation=!+a.shear.toFixed(9)&&!a.rotate,a},a.toTransformString=function(a){var b=a||this[J]();return b.isSimple?(b.scalex=+b.scalex.toFixed(4),b.scaley=+b.scaley.toFixed(4),b.rotate=+b.rotate.toFixed(4),(b.dx||b.dy?"t"+[b.dx,b.dy]:G)+(1!=b.scalex||1!=b.scaley?"s"+[b.scalex,b.scaley,0,0]:G)+(b.rotate?"r"+[b.rotate,0,0]:G)):"m"+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)]}}(o.prototype);var Qb=navigator.userAgent.match(/Version\/(.*?)\s/)||navigator.userAgent.match(/Chrome\/(\d+)/);v.safari="Apple Computer, Inc."==navigator.vendor&&(Qb&&Qb[1]<4||"iP"==navigator.platform.slice(0,2))||"Google Inc."==navigator.vendor&&Qb&&Qb[1]<8?function(){var a=this.rect(-99,-99,this.width+99,this.height+99).attr({stroke:"none"});setTimeout(function(){a.remove()})}:mb;for(var Rb=function(){this.returnValue=!1},Sb=function(){return this.originalEvent.preventDefault()},Tb=function(){this.cancelBubble=!0},Ub=function(){return this.originalEvent.stopPropagation()},Vb=function(a){var b=A.doc.documentElement.scrollTop||A.doc.body.scrollTop,c=A.doc.documentElement.scrollLeft||A.doc.body.scrollLeft;return{x:a.clientX+c,y:a.clientY+b}},Wb=function(){return A.doc.addEventListener?function(a,b,c,d){var e=function(a){var b=Vb(a);return c.call(d,a,b.x,b.y)};if(a.addEventListener(b,e,!1),F&&L[b]){var f=function(b){for(var e=Vb(b),f=b,g=0,h=b.targetTouches&&b.targetTouches.length;h>g;g++)if(b.targetTouches[g].target==a){b=b.targetTouches[g],b.originalEvent=f,b.preventDefault=Sb,b.stopPropagation=Ub;break}return c.call(d,b,e.x,e.y)};a.addEventListener(L[b],f,!1)}return function(){return a.removeEventListener(b,e,!1),F&&L[b]&&a.removeEventListener(L[b],f,!1),!0}}:A.doc.attachEvent?function(a,b,c,d){var e=function(a){a=a||A.win.event;var b=A.doc.documentElement.scrollTop||A.doc.body.scrollTop,e=A.doc.documentElement.scrollLeft||A.doc.body.scrollLeft,f=a.clientX+e,g=a.clientY+b;return a.preventDefault=a.preventDefault||Rb,a.stopPropagation=a.stopPropagation||Tb,c.call(d,a,f,g)};a.attachEvent("on"+b,e);var f=function(){return a.detachEvent("on"+b,e),!0};return f}:void 0}(),Xb=[],Yb=function(a){for(var c,d=a.clientX,e=a.clientY,f=A.doc.documentElement.scrollTop||A.doc.body.scrollTop,g=A.doc.documentElement.scrollLeft||A.doc.body.scrollLeft,h=Xb.length;h--;){if(c=Xb[h],F&&a.touches){for(var i,j=a.touches.length;j--;)if(i=a.touches[j],i.identifier==c.el._drag.id){d=i.clientX,e=i.clientY,(a.originalEvent?a.originalEvent:a).preventDefault();break}}else a.preventDefault();var k,l=c.el.node,m=l.nextSibling,n=l.parentNode,o=l.style.display;A.win.opera&&n.removeChild(l),l.style.display="none",k=c.el.paper.getElementByPoint(d,e),l.style.display=o,A.win.opera&&(m?n.insertBefore(l,m):n.appendChild(l)),k&&b("raphael.drag.over."+c.el.id,c.el,k),d+=g,e+=f,b("raphael.drag.move."+c.el.id,c.move_scope||c.el,d-c.el._drag.x,e-c.el._drag.y,d,e,a)}},Zb=function(a){c.unmousemove(Yb).unmouseup(Zb);for(var d,e=Xb.length;e--;)d=Xb[e],d.el._drag={},b("raphael.drag.end."+d.el.id,d.end_scope||d.start_scope||d.move_scope||d.el,a);Xb=[]},$b=c.el={},_b=K.length;_b--;)!function(a){c[a]=$b[a]=function(b,d){return c.is(b,"function")&&(this.events=this.events||[],this.events.push({name:a,f:b,unbind:Wb(this.shape||this.node||A.doc,a,b,d||this)})),this},c["un"+a]=$b["un"+a]=function(b){for(var d=this.events||[],e=d.length;e--;)d[e].name!=a||!c.is(b,"undefined")&&d[e].f!=b||(d[e].unbind(),d.splice(e,1),!d.length&&delete this.events);return this}}(K[_b]);$b.data=function(a,d){var e=kb[this.id]=kb[this.id]||{};if(0==arguments.length)return e;if(1==arguments.length){if(c.is(a,"object")){for(var f in a)a[z](f)&&this.data(f,a[f]);return this}return b("raphael.data.get."+this.id,this,e[a],a),e[a]}return e[a]=d,b("raphael.data.set."+this.id,this,d,a),this},$b.removeData=function(a){return null==a?kb[this.id]={}:kb[this.id]&&delete kb[this.id][a],this},$b.getData=function(){return d(kb[this.id]||{})},$b.hover=function(a,b,c,d){return this.mouseover(a,c).mouseout(b,d||c)},$b.unhover=function(a,b){return this.unmouseover(a).unmouseout(b)};var ac=[];$b.drag=function(a,d,e,f,g,h){function i(i){(i.originalEvent||i).preventDefault();var j=i.clientX,k=i.clientY,l=A.doc.documentElement.scrollTop||A.doc.body.scrollTop,m=A.doc.documentElement.scrollLeft||A.doc.body.scrollLeft;if(this._drag.id=i.identifier,F&&i.touches)for(var n,o=i.touches.length;o--;)if(n=i.touches[o],this._drag.id=n.identifier,n.identifier==this._drag.id){j=n.clientX,k=n.clientY;break}this._drag.x=j+m,this._drag.y=k+l,!Xb.length&&c.mousemove(Yb).mouseup(Zb),Xb.push({el:this,move_scope:f,start_scope:g,end_scope:h}),d&&b.on("raphael.drag.start."+this.id,d),a&&b.on("raphael.drag.move."+this.id,a),e&&b.on("raphael.drag.end."+this.id,e),b("raphael.drag.start."+this.id,g||f||this,i.clientX+m,i.clientY+l,i)}return this._drag={},ac.push({el:this,start:i}),this.mousedown(i),this},$b.onDragOver=function(a){a?b.on("raphael.drag.over."+this.id,a):b.unbind("raphael.drag.over."+this.id)},$b.undrag=function(){for(var a=ac.length;a--;)ac[a].el==this&&(this.unmousedown(ac[a].start),ac.splice(a,1),b.unbind("raphael.drag.*."+this.id));!ac.length&&c.unmousemove(Yb).unmouseup(Zb),Xb=[]},v.circle=function(a,b,d){var e=c._engine.circle(this,a||0,b||0,d||0);return this.__set__&&this.__set__.push(e),e},v.rect=function(a,b,d,e,f){var g=c._engine.rect(this,a||0,b||0,d||0,e||0,f||0);return this.__set__&&this.__set__.push(g),g},v.ellipse=function(a,b,d,e){var f=c._engine.ellipse(this,a||0,b||0,d||0,e||0);return this.__set__&&this.__set__.push(f),f},v.path=function(a){a&&!c.is(a,U)&&!c.is(a[0],V)&&(a+=G);var b=c._engine.path(c.format[D](c,arguments),this);return this.__set__&&this.__set__.push(b),b},v.image=function(a,b,d,e,f){var g=c._engine.image(this,a||"about:blank",b||0,d||0,e||0,f||0);return this.__set__&&this.__set__.push(g),g},v.text=function(a,b,d){var e=c._engine.text(this,a||0,b||0,I(d));return this.__set__&&this.__set__.push(e),e},v.set=function(a){!c.is(a,"array")&&(a=Array.prototype.splice.call(arguments,0,arguments.length));var b=new mc(a);return this.__set__&&this.__set__.push(b),b.paper=this,b.type="set",b},v.setStart=function(a){this.__set__=a||this.set()},v.setFinish=function(){var a=this.__set__;return delete this.__set__,a},v.getSize=function(){var a=this.canvas.parentNode;return{width:a.offsetWidth,height:a.offsetHeight}},v.setSize=function(a,b){return c._engine.setSize.call(this,a,b)},v.setViewBox=function(a,b,d,e,f){return c._engine.setViewBox.call(this,a,b,d,e,f)},v.top=v.bottom=null,v.raphael=c;var bc=function(a){var b=a.getBoundingClientRect(),c=a.ownerDocument,d=c.body,e=c.documentElement,f=e.clientTop||d.clientTop||0,g=e.clientLeft||d.clientLeft||0,h=b.top+(A.win.pageYOffset||e.scrollTop||d.scrollTop)-f,i=b.left+(A.win.pageXOffset||e.scrollLeft||d.scrollLeft)-g;return{y:h,x:i}};v.getElementByPoint=function(a,b){var c=this,d=c.canvas,e=A.doc.elementFromPoint(a,b);if(A.win.opera&&"svg"==e.tagName){var f=bc(d),g=d.createSVGRect();g.x=a-f.x,g.y=b-f.y,g.width=g.height=1;var h=d.getIntersectionList(g,null);h.length&&(e=h[h.length-1])}if(!e)return null;for(;e.parentNode&&e!=d.parentNode&&!e.raphael;)e=e.parentNode;return e==c.canvas.parentNode&&(e=d),e=e&&e.raphael?c.getById(e.raphaelid):null},v.getElementsByBBox=function(a){var b=this.set();return this.forEach(function(d){c.isBBoxIntersect(d.getBBox(),a)&&b.push(d)}),b},v.getById=function(a){for(var b=this.bottom;b;){if(b.id==a)return b;b=b.next}return null},v.forEach=function(a,b){for(var c=this.bottom;c;){if(a.call(b,c)===!1)return this;c=c.next}return this},v.getElementsByPoint=function(a,b){var c=this.set();return this.forEach(function(d){d.isPointInside(a,b)&&c.push(d)}),c},$b.isPointInside=function(a,b){var d=this.realPath=qb[this.type](this);return this.attr("transform")&&this.attr("transform").length&&(d=c.transformPath(d,this.attr("transform"))),c.isPointInsidePath(d,a,b)},$b.getBBox=function(a){if(this.removed)return{};var b=this._;return a?((b.dirty||!b.bboxwt)&&(this.realPath=qb[this.type](this),b.bboxwt=Bb(this.realPath),b.bboxwt.toString=p,b.dirty=0),b.bboxwt):((b.dirty||b.dirtyT||!b.bbox)&&((b.dirty||!this.realPath)&&(b.bboxwt=0,this.realPath=qb[this.type](this)),b.bbox=Bb(rb(this.realPath,this.matrix)),b.bbox.toString=p,b.dirty=b.dirtyT=0),b.bbox)},$b.clone=function(){if(this.removed)return null;var a=this.paper[this.type]().attr(this.attr());return this.__set__&&this.__set__.push(a),a},$b.glow=function(a){if("text"==this.type)return null;a=a||{};var b={width:(a.width||10)+(+this.attr("stroke-width")||1),fill:a.fill||!1,opacity:a.opacity||.5,offsetx:a.offsetx||0,offsety:a.offsety||0,color:a.color||"#000"},c=b.width/2,d=this.paper,e=d.set(),f=this.realPath||qb[this.type](this);f=this.matrix?rb(f,this.matrix):f;for(var g=1;c+1>g;g++)e.push(d.path(f).attr({stroke:b.color,fill:b.fill?b.color:"none","stroke-linejoin":"round","stroke-linecap":"round","stroke-width":+(b.width/c*g).toFixed(3),opacity:+(b.opacity/c).toFixed(3)}));return e.insertBefore(this).translate(b.offsetx,b.offsety)};var cc=function(a,b,d,e,f,g,h,i,l){return null==l?j(a,b,d,e,f,g,h,i):c.findDotsAtSegment(a,b,d,e,f,g,h,i,k(a,b,d,e,f,g,h,i,l))},dc=function(a,b){return function(d,e,f){d=Kb(d);for(var g,h,i,j,k,l="",m={},n=0,o=0,p=d.length;p>o;o++){if(i=d[o],"M"==i[0])g=+i[1],h=+i[2];else{if(j=cc(g,h,i[1],i[2],i[3],i[4],i[5],i[6]),n+j>e){if(b&&!m.start){if(k=cc(g,h,i[1],i[2],i[3],i[4],i[5],i[6],e-n),l+=["C"+k.start.x,k.start.y,k.m.x,k.m.y,k.x,k.y],f)return l;m.start=l,l=["M"+k.x,k.y+"C"+k.n.x,k.n.y,k.end.x,k.end.y,i[5],i[6]].join(),n+=j,g=+i[5],h=+i[6];continue}if(!a&&!b)return k=cc(g,h,i[1],i[2],i[3],i[4],i[5],i[6],e-n),{x:k.x,y:k.y,alpha:k.alpha}}n+=j,g=+i[5],h=+i[6]}l+=i.shift()+i}return m.end=l,k=a?n:b?m:c.findDotsAtSegment(g,h,i[0],i[1],i[2],i[3],i[4],i[5],1),k.alpha&&(k={x:k.x,y:k.y,alpha:k.alpha}),k}},ec=dc(1),fc=dc(),gc=dc(0,1);c.getTotalLength=ec,c.getPointAtLength=fc,c.getSubpath=function(a,b,c){if(this.getTotalLength(a)-c<1e-6)return gc(a,b).end;var d=gc(a,c,1);return b?gc(d,b).end:d},$b.getTotalLength=function(){var a=this.getPath();if(a)return this.node.getTotalLength?this.node.getTotalLength():ec(a)},$b.getPointAtLength=function(a){var b=this.getPath();if(b)return fc(b,a)},$b.getPath=function(){var a,b=c._getPath[this.type];if("text"!=this.type&&"set"!=this.type)return b&&(a=b(this)),a},$b.getSubpath=function(a,b){var d=this.getPath();if(d)return c.getSubpath(d,a,b)};var hc=c.easing_formulas={linear:function(a){return a},"<":function(a){return R(a,1.7)},">":function(a){return R(a,.48)},"<>":function(a){var b=.48-a/1.04,c=N.sqrt(.1734+b*b),d=c-b,e=R(Q(d),1/3)*(0>d?-1:1),f=-c-b,g=R(Q(f),1/3)*(0>f?-1:1),h=e+g+.5;return 3*(1-h)*h*h+h*h*h},backIn:function(a){var b=1.70158;return a*a*((b+1)*a-b)},backOut:function(a){a-=1;var b=1.70158;return a*a*((b+1)*a+b)+1},elastic:function(a){return a==!!a?a:R(2,-10*a)*N.sin(2*(a-.075)*S/.3)+1},bounce:function(a){var b,c=7.5625,d=2.75;return 1/d>a?b=c*a*a:2/d>a?(a-=1.5/d,b=c*a*a+.75):2.5/d>a?(a-=2.25/d,b=c*a*a+.9375):(a-=2.625/d,b=c*a*a+.984375),b}};hc.easeIn=hc["ease-in"]=hc["<"],hc.easeOut=hc["ease-out"]=hc[">"],hc.easeInOut=hc["ease-in-out"]=hc["<>"],hc["back-in"]=hc.backIn,hc["back-out"]=hc.backOut;var ic=[],jc=a.requestAnimationFrame||a.webkitRequestAnimationFrame||a.mozRequestAnimationFrame||a.oRequestAnimationFrame||a.msRequestAnimationFrame||function(a){setTimeout(a,16)},kc=function(){for(var a=+new Date,d=0;d<ic.length;d++){var e=ic[d];if(!e.el.removed&&!e.paused){var f,g,h=a-e.start,i=e.ms,j=e.easing,k=e.from,l=e.diff,m=e.to,n=(e.t,e.el),o={},p={};if(e.initstatus?(h=(e.initstatus*e.anim.top-e.prev)/(e.percent-e.prev)*i,e.status=e.initstatus,delete e.initstatus,e.stop&&ic.splice(d--,1)):e.status=(e.prev+(e.percent-e.prev)*(h/i))/e.anim.top,!(0>h))if(i>h){var q=j(h/i);for(var r in k)if(k[z](r)){switch(db[r]){case T:f=+k[r]+q*i*l[r];break;case"colour":f="rgb("+[lc($(k[r].r+q*i*l[r].r)),lc($(k[r].g+q*i*l[r].g)),lc($(k[r].b+q*i*l[r].b))].join(",")+")";break;case"path":f=[];for(var t=0,u=k[r].length;u>t;t++){f[t]=[k[r][t][0]];for(var v=1,w=k[r][t].length;w>v;v++)f[t][v]=+k[r][t][v]+q*i*l[r][t][v];f[t]=f[t].join(H)}f=f.join(H);break;case"transform":if(l[r].real)for(f=[],t=0,u=k[r].length;u>t;t++)for(f[t]=[k[r][t][0]],v=1,w=k[r][t].length;w>v;v++)f[t][v]=k[r][t][v]+q*i*l[r][t][v];else{var x=function(a){return+k[r][a]+q*i*l[r][a]};f=[["m",x(0),x(1),x(2),x(3),x(4),x(5)]]}break;case"csv":if("clip-rect"==r)for(f=[],t=4;t--;)f[t]=+k[r][t]+q*i*l[r][t];break;default:var y=[][E](k[r]);for(f=[],t=n.paper.customAttributes[r].length;t--;)f[t]=+y[t]+q*i*l[r][t]}o[r]=f}n.attr(o),function(a,c,d){setTimeout(function(){b("raphael.anim.frame."+a,c,d)})}(n.id,n,e.anim)}else{if(function(a,d,e){setTimeout(function(){b("raphael.anim.frame."+d.id,d,e),b("raphael.anim.finish."+d.id,d,e),c.is(a,"function")&&a.call(d)})}(e.callback,n,e.anim),n.attr(m),ic.splice(d--,1),e.repeat>1&&!e.next){for(g in m)m[z](g)&&(p[g]=e.totalOrigin[g]);e.el.attr(p),s(e.anim,e.el,e.anim.percents[0],null,e.totalOrigin,e.repeat-1)}e.next&&!e.stop&&s(e.anim,e.el,e.next,null,e.totalOrigin,e.repeat)}}}c.svg&&n&&n.paper&&n.paper.safari(),ic.length&&jc(kc)},lc=function(a){return a>255?255:0>a?0:a};$b.animateWith=function(a,b,d,e,f,g){var h=this;if(h.removed)return g&&g.call(h),h;var i=d instanceof r?d:c.animation(d,e,f,g);s(i,h,i.percents[0],null,h.attr());for(var j=0,k=ic.length;k>j;j++)if(ic[j].anim==b&&ic[j].el==a){ic[k-1].start=ic[j].start;break}return h},$b.onAnimation=function(a){return a?b.on("raphael.anim.frame."+this.id,a):b.unbind("raphael.anim.frame."+this.id),this},r.prototype.delay=function(a){var b=new r(this.anim,this.ms);return b.times=this.times,b.del=+a||0,b},r.prototype.repeat=function(a){var b=new r(this.anim,this.ms);return b.del=this.del,b.times=N.floor(O(a,0))||1,b},c.animation=function(a,b,d,e){if(a instanceof r)return a;(c.is(d,"function")||!d)&&(e=e||d||null,d=null),a=Object(a),b=+b||0;var f,g,h={};for(g in a)a[z](g)&&_(g)!=g&&_(g)+"%"!=g&&(f=!0,h[g]=a[g]);if(f)return d&&(h.easing=d),e&&(h.callback=e),new r({100:h},b);if(e){var i=0;for(var j in a){var k=ab(j);a[z](j)&&k>i&&(i=k)}i+="%",!a[i].callback&&(a[i].callback=e)}return new r(a,b)},$b.animate=function(a,b,d,e){var f=this;if(f.removed)return e&&e.call(f),f;var g=a instanceof r?a:c.animation(a,b,d,e);return s(g,f,g.percents[0],null,f.attr()),f},$b.setTime=function(a,b){return a&&null!=b&&this.status(a,P(b,a.ms)/a.ms),this},$b.status=function(a,b){var c,d,e=[],f=0;if(null!=b)return s(a,this,-1,P(b,1)),this;for(c=ic.length;c>f;f++)if(d=ic[f],d.el.id==this.id&&(!a||d.anim==a)){if(a)return d.status;e.push({anim:d.anim,status:d.status})}return a?0:e},$b.pause=function(a){for(var c=0;c<ic.length;c++)ic[c].el.id!=this.id||a&&ic[c].anim!=a||b("raphael.anim.pause."+this.id,this,ic[c].anim)!==!1&&(ic[c].paused=!0);return this},$b.resume=function(a){for(var c=0;c<ic.length;c++)if(ic[c].el.id==this.id&&(!a||ic[c].anim==a)){var d=ic[c];b("raphael.anim.resume."+this.id,this,d.anim)!==!1&&(delete d.paused,this.status(d.anim,d.status))}return this},$b.stop=function(a){for(var c=0;c<ic.length;c++)ic[c].el.id!=this.id||a&&ic[c].anim!=a||b("raphael.anim.stop."+this.id,this,ic[c].anim)!==!1&&ic.splice(c--,1);return this},b.on("raphael.remove",t),b.on("raphael.clear",t),$b.toString=function(){return"Raphals object"};var mc=function(a){if(this.items=[],this.length=0,this.type="set",a)for(var b=0,c=a.length;c>b;b++)!a[b]||a[b].constructor!=$b.constructor&&a[b].constructor!=mc||(this[this.items.length]=this.items[this.items.length]=a[b],this.length++)},nc=mc.prototype;nc.push=function(){for(var a,b,c=0,d=arguments.length;d>c;c++)a=arguments[c],!a||a.constructor!=$b.constructor&&a.constructor!=mc||(b=this.items.length,this[b]=this.items[b]=a,this.length++);return this},nc.pop=function(){return this.length&&delete this[this.length--],this.items.pop()},nc.forEach=function(a,b){for(var c=0,d=this.items.length;d>c;c++)if(a.call(b,this.items[c],c)===!1)return this;return this};for(var oc in $b)$b[z](oc)&&(nc[oc]=function(a){return function(){var b=arguments;return this.forEach(function(c){c[a][D](c,b)})}}(oc));return nc.attr=function(a,b){if(a&&c.is(a,V)&&c.is(a[0],"object"))for(var d=0,e=a.length;e>d;d++)this.items[d].attr(a[d]);else for(var f=0,g=this.items.length;g>f;f++)this.items[f].attr(a,b);return this},nc.clear=function(){for(;this.length;)this.pop()},nc.splice=function(a,b){a=0>a?O(this.length+a,0):a,b=O(0,P(this.length-a,b));var c,d=[],e=[],f=[];for(c=2;c<arguments.length;c++)f.push(arguments[c]);for(c=0;b>c;c++)e.push(this[a+c]);for(;c<this.length-a;c++)d.push(this[a+c]);var g=f.length;for(c=0;c<g+d.length;c++)this.items[a+c]=this[a+c]=g>c?f[c]:d[c-g];for(c=this.items.length=this.length-=b-g;this[c];)delete this[c++];return new mc(e)},nc.exclude=function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]==a)return this.splice(b,1),!0},nc.animate=function(a,b,d,e){(c.is(d,"function")||!d)&&(e=d||null);var f,g,h=this.items.length,i=h,j=this;if(!h)return this;e&&(g=function(){!--h&&e.call(j)}),d=c.is(d,U)?d:g;var k=c.animation(a,b,d,g);for(f=this.items[--i].animate(k);i--;)this.items[i]&&!this.items[i].removed&&this.items[i].animateWith(f,k,k),this.items[i]&&!this.items[i].removed||h--;return this},nc.insertAfter=function(a){for(var b=this.items.length;b--;)this.items[b].insertAfter(a);return this},nc.getBBox=function(){for(var a=[],b=[],c=[],d=[],e=this.items.length;e--;)if(!this.items[e].removed){var f=this.items[e].getBBox();a.push(f.x),b.push(f.y),c.push(f.x+f.width),d.push(f.y+f.height)}return a=P[D](0,a),b=P[D](0,b),c=O[D](0,c),d=O[D](0,d),{x:a,y:b,x2:c,y2:d,width:c-a,height:d-b}},nc.clone=function(a){a=this.paper.set();for(var b=0,c=this.items.length;c>b;b++)a.push(this.items[b].clone());return a},nc.toString=function(){return"Raphals set"},nc.glow=function(a){var b=this.paper.set();return this.forEach(function(c){var d=c.glow(a);null!=d&&d.forEach(function(a){b.push(a)})}),b},nc.isPointInside=function(a,b){var c=!1;return this.forEach(function(d){return d.isPointInside(a,b)?(c=!0,!1):void 0}),c},c.registerFont=function(a){if(!a.face)return a;this.fonts=this.fonts||{};var b={w:a.w,face:{},glyphs:{}},c=a.face["font-family"];for(var d in a.face)a.face[z](d)&&(b.face[d]=a.face[d]);if(this.fonts[c]?this.fonts[c].push(b):this.fonts[c]=[b],!a.svg){b.face["units-per-em"]=ab(a.face["units-per-em"],10);for(var e in a.glyphs)if(a.glyphs[z](e)){var f=a.glyphs[e];if(b.glyphs[e]={w:f.w,k:{},d:f.d&&"M"+f.d.replace(/[mlcxtrv]/g,function(a){return{l:"L",c:"C",x:"z",t:"m",r:"l",v:"c"}[a]||"M"})+"z"},f.k)for(var g in f.k)f[z](g)&&(b.glyphs[e].k[g]=f.k[g])}}return a},v.getFont=function(a,b,d,e){if(e=e||"normal",d=d||"normal",b=+b||{normal:400,bold:700,lighter:300,bolder:800}[b]||400,c.fonts){var f=c.fonts[a];if(!f){var g=new RegExp("(^|\\s)"+a.replace(/[^\w\d\s+!~.:_-]/g,G)+"(\\s|$)","i");for(var h in c.fonts)if(c.fonts[z](h)&&g.test(h)){f=c.fonts[h];break}}var i;if(f)for(var j=0,k=f.length;k>j&&(i=f[j],i.face["font-weight"]!=b||i.face["font-style"]!=d&&i.face["font-style"]||i.face["font-stretch"]!=e);j++);return i}},v.print=function(a,b,d,e,f,g,h,i){g=g||"middle",h=O(P(h||0,1),-1),i=O(P(i||1,3),1);var j,k=I(d)[J](G),l=0,m=0,n=G;if(c.is(e,"string")&&(e=this.getFont(e)),e){j=(f||16)/e.face["units-per-em"];for(var o=e.face.bbox[J](w),p=+o[0],q=o[3]-o[1],r=0,s=+o[1]+("baseline"==g?q+ +e.face.descent:q/2),t=0,u=k.length;u>t;t++){if("\n"==k[t])l=0,x=0,m=0,r+=q*i;else{var v=m&&e.glyphs[k[t-1]]||{},x=e.glyphs[k[t]];l+=m?(v.w||e.w)+(v.k&&v.k[k[t]]||0)+e.w*h:0,m=1}x&&x.d&&(n+=c.transformPath(x.d,["t",l*j,r*j,"s",j,j,p,s,"t",(a-p)/j,(b-s)/j]))}}return this.path(n).attr({fill:"#000",stroke:"none"})},v.add=function(a){if(c.is(a,"array"))for(var b,d=this.set(),e=0,f=a.length;f>e;e++)b=a[e]||{},x[z](b.type)&&d.push(this[b.type]().attr(b));return d},c.format=function(a,b){var d=c.is(b,V)?[0][E](b):arguments;return a&&c.is(a,U)&&d.length-1&&(a=a.replace(y,function(a,b){return null==d[++b]?G:d[b]})),a||G},c.fullfill=function(){var a=/\{([^\}]+)\}/g,b=/(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,c=function(a,c,d){var e=d;return c.replace(b,function(a,b,c,d,f){b=b||d,e&&(b in e&&(e=e[b]),"function"==typeof e&&f&&(e=e()))}),e=(null==e||e==d?a:e)+""};return function(b,d){return String(b).replace(a,function(a,b){return c(a,b,d)})}}(),c.ninja=function(){return B.was?A.win.Raphael=B.is:delete Raphael,c},c.st=nc,b.on("raphael.DOMload",function(){u=!0}),function(a,b,d){function e(){/in/.test(a.readyState)?setTimeout(e,9):c.eve("raphael.DOMload")}null==a.readyState&&a.addEventListener&&(a.addEventListener(b,d=function(){a.removeEventListener(b,d,!1),a.readyState="complete"},!1),a.readyState="loading"),e()}(document,"DOMContentLoaded"),function(){if(c.svg){var a="hasOwnProperty",b=String,d=parseFloat,e=parseInt,f=Math,g=f.max,h=f.abs,i=f.pow,j=/[, ]+/,k=c.eve,l="",m=" ",n="http://www.w3.org/1999/xlink",o={block:"M5,0 0,2.5 5,5z",classic:"M5,0 0,2.5 5,5 3.5,3 3.5,2z",diamond:"M2.5,0 5,2.5 2.5,5 0,2.5z",open:"M6,1 1,3.5 6,6",oval:"M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"},p={};c.toString=function(){return"Your browser supports SVG.\nYou are running Raphal "+this.version};var q=function(d,e){if(e){"string"==typeof d&&(d=q(d));for(var f in e)e[a](f)&&("xlink:"==f.substring(0,6)?d.setAttributeNS(n,f.substring(6),b(e[f])):d.setAttribute(f,b(e[f])))}else d=c._g.doc.createElementNS("http://www.w3.org/2000/svg",d),d.style&&(d.style.webkitTapHighlightColor="rgba(0,0,0,0)");return d},r=function(a,e){var j="linear",k=a.id+e,m=.5,n=.5,o=a.node,p=a.paper,r=o.style,s=c._g.doc.getElementById(k);if(!s){if(e=b(e).replace(c._radial_gradient,function(a,b,c){if(j="radial",b&&c){m=d(b),n=d(c);var e=2*(n>.5)-1;i(m-.5,2)+i(n-.5,2)>.25&&(n=f.sqrt(.25-i(m-.5,2))*e+.5)&&.5!=n&&(n=n.toFixed(5)-1e-5*e)}return l}),e=e.split(/\s*\-\s*/),"linear"==j){var t=e.shift();if(t=-d(t),isNaN(t))return null;var u=[0,0,f.cos(c.rad(t)),f.sin(c.rad(t))],v=1/(g(h(u[2]),h(u[3]))||1);u[2]*=v,u[3]*=v,u[2]<0&&(u[0]=-u[2],u[2]=0),u[3]<0&&(u[1]=-u[3],u[3]=0)}var w=c._parseDots(e);if(!w)return null;if(k=k.replace(/[\(\)\s,\xb0#]/g,"_"),a.gradient&&k!=a.gradient.id&&(p.defs.removeChild(a.gradient),delete a.gradient),!a.gradient){s=q(j+"Gradient",{id:k}),a.gradient=s,q(s,"radial"==j?{fx:m,fy:n}:{x1:u[0],y1:u[1],x2:u[2],y2:u[3],gradientTransform:a.matrix.invert()}),p.defs.appendChild(s);for(var x=0,y=w.length;y>x;x++)s.appendChild(q("stop",{offset:w[x].offset?w[x].offset:x?"100%":"0%","stop-color":w[x].color||"#fff"}))}}return q(o,{fill:"url('"+document.location+"#"+k+"')",opacity:1,"fill-opacity":1}),r.fill=l,r.opacity=1,r.fillOpacity=1,1},s=function(a){var b=a.getBBox(1);q(a.pattern,{patternTransform:a.matrix.invert()+" translate("+b.x+","+b.y+")"})},t=function(d,e,f){if("path"==d.type){for(var g,h,i,j,k,m=b(e).toLowerCase().split("-"),n=d.paper,r=f?"end":"start",s=d.node,t=d.attrs,u=t["stroke-width"],v=m.length,w="classic",x=3,y=3,z=5;v--;)switch(m[v]){case"block":case"classic":case"oval":case"diamond":case"open":case"none":w=m[v];break;case"wide":y=5;break;case"narrow":y=2;break;case"long":x=5;break;case"short":x=2}if("open"==w?(x+=2,y+=2,z+=2,i=1,j=f?4:1,k={fill:"none",stroke:t.stroke}):(j=i=x/2,k={fill:t.stroke,stroke:"none"}),d._.arrows?f?(d._.arrows.endPath&&p[d._.arrows.endPath]--,d._.arrows.endMarker&&p[d._.arrows.endMarker]--):(d._.arrows.startPath&&p[d._.arrows.startPath]--,d._.arrows.startMarker&&p[d._.arrows.startMarker]--):d._.arrows={},"none"!=w){var A="raphael-marker-"+w,B="raphael-marker-"+r+w+x+y+"-obj"+d.id;c._g.doc.getElementById(A)?p[A]++:(n.defs.appendChild(q(q("path"),{"stroke-linecap":"round",d:o[w],id:A})),p[A]=1);var C,D=c._g.doc.getElementById(B);D?(p[B]++,C=D.getElementsByTagName("use")[0]):(D=q(q("marker"),{id:B,markerHeight:y,markerWidth:x,orient:"auto",refX:j,refY:y/2}),C=q(q("use"),{"xlink:href":"#"+A,transform:(f?"rotate(180 "+x/2+" "+y/2+") ":l)+"scale("+x/z+","+y/z+")","stroke-width":(1/((x/z+y/z)/2)).toFixed(4)}),D.appendChild(C),n.defs.appendChild(D),p[B]=1),q(C,k);var E=i*("diamond"!=w&&"oval"!=w);f?(g=d._.arrows.startdx*u||0,h=c.getTotalLength(t.path)-E*u):(g=E*u,h=c.getTotalLength(t.path)-(d._.arrows.enddx*u||0)),k={},k["marker-"+r]="url(#"+B+")",(h||g)&&(k.d=c.getSubpath(t.path,g,h)),q(s,k),d._.arrows[r+"Path"]=A,d._.arrows[r+"Marker"]=B,d._.arrows[r+"dx"]=E,d._.arrows[r+"Type"]=w,d._.arrows[r+"String"]=e}else f?(g=d._.arrows.startdx*u||0,h=c.getTotalLength(t.path)-g):(g=0,h=c.getTotalLength(t.path)-(d._.arrows.enddx*u||0)),d._.arrows[r+"Path"]&&q(s,{d:c.getSubpath(t.path,g,h)}),delete d._.arrows[r+"Path"],delete d._.arrows[r+"Marker"],delete d._.arrows[r+"dx"],delete d._.arrows[r+"Type"],delete d._.arrows[r+"String"];for(k in p)if(p[a](k)&&!p[k]){var F=c._g.doc.getElementById(k);F&&F.parentNode.removeChild(F)}}},u={"":[0],none:[0],"-":[3,1],".":[1,1],"-.":[3,1,1,1],"-..":[3,1,1,1,1,1],". ":[1,3],"- ":[4,3],"--":[8,3],"- .":[4,3,1,3],"--.":[8,3,1,3],"--..":[8,3,1,3,1,3]},v=function(a,c,d){if(c=u[b(c).toLowerCase()]){for(var e=a.attrs["stroke-width"]||"1",f={round:e,square:e,butt:0}[a.attrs["stroke-linecap"]||d["stroke-linecap"]]||0,g=[],h=c.length;h--;)g[h]=c[h]*e+(h%2?1:-1)*f;q(a.node,{"stroke-dasharray":g.join(",")})}},w=function(d,f){var i=d.node,k=d.attrs,m=i.style.visibility;i.style.visibility="hidden";for(var o in f)if(f[a](o)){if(!c._availableAttrs[a](o))continue;var p=f[o];switch(k[o]=p,o){case"blur":d.blur(p);break;case"title":var u=i.getElementsByTagName("title");if(u.length&&(u=u[0]))u.firstChild.nodeValue=p;else{u=q("title");var w=c._g.doc.createTextNode(p);u.appendChild(w),i.appendChild(u)}break;case"href":case"target":var x=i.parentNode;if("a"!=x.tagName.toLowerCase()){var z=q("a");x.insertBefore(z,i),z.appendChild(i),x=z}"target"==o?x.setAttributeNS(n,"show","blank"==p?"new":p):x.setAttributeNS(n,o,p);break;case"cursor":i.style.cursor=p;break;case"transform":d.transform(p);break;case"arrow-start":t(d,p);break;case"arrow-end":t(d,p,1);break;case"clip-rect":var A=b(p).split(j);if(4==A.length){d.clip&&d.clip.parentNode.parentNode.removeChild(d.clip.parentNode);var B=q("clipPath"),C=q("rect");B.id=c.createUUID(),q(C,{x:A[0],y:A[1],width:A[2],height:A[3]}),B.appendChild(C),d.paper.defs.appendChild(B),q(i,{"clip-path":"url(#"+B.id+")"}),d.clip=C}if(!p){var D=i.getAttribute("clip-path");if(D){var E=c._g.doc.getElementById(D.replace(/(^url\(#|\)$)/g,l));E&&E.parentNode.removeChild(E),q(i,{"clip-path":l}),delete d.clip}}break;case"path":"path"==d.type&&(q(i,{d:p?k.path=c._pathToAbsolute(p):"M0,0"}),d._.dirty=1,d._.arrows&&("startString"in d._.arrows&&t(d,d._.arrows.startString),"endString"in d._.arrows&&t(d,d._.arrows.endString,1)));break;case"width":if(i.setAttribute(o,p),d._.dirty=1,!k.fx)break;o="x",p=k.x;case"x":k.fx&&(p=-k.x-(k.width||0));case"rx":if("rx"==o&&"rect"==d.type)break;case"cx":i.setAttribute(o,p),d.pattern&&s(d),d._.dirty=1;break;case"height":if(i.setAttribute(o,p),d._.dirty=1,!k.fy)break;o="y",p=k.y;case"y":k.fy&&(p=-k.y-(k.height||0));case"ry":if("ry"==o&&"rect"==d.type)break;case"cy":i.setAttribute(o,p),d.pattern&&s(d),d._.dirty=1;break;case"r":"rect"==d.type?q(i,{rx:p,ry:p}):i.setAttribute(o,p),d._.dirty=1;break;case"src":"image"==d.type&&i.setAttributeNS(n,"href",p);break;case"stroke-width":(1!=d._.sx||1!=d._.sy)&&(p/=g(h(d._.sx),h(d._.sy))||1),i.setAttribute(o,p),k["stroke-dasharray"]&&v(d,k["stroke-dasharray"],f),d._.arrows&&("startString"in d._.arrows&&t(d,d._.arrows.startString),"endString"in d._.arrows&&t(d,d._.arrows.endString,1));break;case"stroke-dasharray":v(d,p,f);break;case"fill":var F=b(p).match(c._ISURL);if(F){B=q("pattern");var G=q("image");B.id=c.createUUID(),q(B,{x:0,y:0,patternUnits:"userSpaceOnUse",height:1,width:1}),q(G,{x:0,y:0,"xlink:href":F[1]}),B.appendChild(G),function(a){c._preload(F[1],function(){var b=this.offsetWidth,c=this.offsetHeight;q(a,{width:b,height:c}),q(G,{width:b,height:c}),d.paper.safari()})}(B),d.paper.defs.appendChild(B),q(i,{fill:"url(#"+B.id+")"}),d.pattern=B,d.pattern&&s(d);break}var H=c.getRGB(p);if(H.error){if(("circle"==d.type||"ellipse"==d.type||"r"!=b(p).charAt())&&r(d,p)){if("opacity"in k||"fill-opacity"in k){var I=c._g.doc.getElementById(i.getAttribute("fill").replace(/^url\(#|\)$/g,l));if(I){var J=I.getElementsByTagName("stop");q(J[J.length-1],{"stop-opacity":("opacity"in k?k.opacity:1)*("fill-opacity"in k?k["fill-opacity"]:1)})}}k.gradient=p,k.fill="none";break}}else delete f.gradient,delete k.gradient,!c.is(k.opacity,"undefined")&&c.is(f.opacity,"undefined")&&q(i,{opacity:k.opacity}),!c.is(k["fill-opacity"],"undefined")&&c.is(f["fill-opacity"],"undefined")&&q(i,{"fill-opacity":k["fill-opacity"]});H[a]("opacity")&&q(i,{"fill-opacity":H.opacity>1?H.opacity/100:H.opacity});case"stroke":H=c.getRGB(p),i.setAttribute(o,H.hex),"stroke"==o&&H[a]("opacity")&&q(i,{"stroke-opacity":H.opacity>1?H.opacity/100:H.opacity}),"stroke"==o&&d._.arrows&&("startString"in d._.arrows&&t(d,d._.arrows.startString),"endString"in d._.arrows&&t(d,d._.arrows.endString,1));break;case"gradient":("circle"==d.type||"ellipse"==d.type||"r"!=b(p).charAt())&&r(d,p);break;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               case"opacity":k.gradient&&!k[a]("stroke-opacity")&&q(i,{"stroke-opacity":p>1?p/100:p});case"fill-opacity":if(k.gradient){I=c._g.doc.getElementById(i.getAttribute("fill").replace(/^url\(#|\)$/g,l)),I&&(J=I.getElementsByTagName("stop"),q(J[J.length-1],{"stop-opacity":p}));break}default:"font-size"==o&&(p=e(p,10)+"px");var K=o.replace(/(\-.)/g,function(a){return a.substring(1).toUpperCase()});i.style[K]=p,d._.dirty=1,i.setAttribute(o,p)}}y(d,f),i.style.visibility=m},x=1.2,y=function(d,f){if("text"==d.type&&(f[a]("text")||f[a]("font")||f[a]("font-size")||f[a]("x")||f[a]("y"))){var g=d.attrs,h=d.node,i=h.firstChild?e(c._g.doc.defaultView.getComputedStyle(h.firstChild,l).getPropertyValue("font-size"),10):10;if(f[a]("text")){for(g.text=f.text;h.firstChild;)h.removeChild(h.firstChild);for(var j,k=b(f.text).split("\n"),m=[],n=0,o=k.length;o>n;n++)j=q("tspan"),n&&q(j,{dy:i*x,x:g.x}),j.appendChild(c._g.doc.createTextNode(k[n])),h.appendChild(j),m[n]=j}else for(m=h.getElementsByTagName("tspan"),n=0,o=m.length;o>n;n++)n?q(m[n],{dy:i*x,x:g.x}):q(m[0],{dy:0});q(h,{x:g.x,y:g.y}),d._.dirty=1;var p=d._getBBox(),r=g.y-(p.y+p.height/2);r&&c.is(r,"finite")&&q(m[0],{dy:r})}},z=function(a){return a.parentNode&&"a"===a.parentNode.tagName.toLowerCase()?a.parentNode:a},A=function(a,b){this[0]=this.node=a,a.raphael=!0,this.id=c._oid++,a.raphaelid=this.id,this.matrix=c.matrix(),this.realPath=null,this.paper=b,this.attrs=this.attrs||{},this._={transform:[],sx:1,sy:1,deg:0,dx:0,dy:0,dirty:1},!b.bottom&&(b.bottom=this),this.prev=b.top,b.top&&(b.top.next=this),b.top=this,this.next=null},B=c.el;A.prototype=B,B.constructor=A,c._engine.path=function(a,b){var c=q("path");b.canvas&&b.canvas.appendChild(c);var d=new A(c,b);return d.type="path",w(d,{fill:"none",stroke:"#000",path:a}),d},B.rotate=function(a,c,e){if(this.removed)return this;if(a=b(a).split(j),a.length-1&&(c=d(a[1]),e=d(a[2])),a=d(a[0]),null==e&&(c=e),null==c||null==e){var f=this.getBBox(1);c=f.x+f.width/2,e=f.y+f.height/2}return this.transform(this._.transform.concat([["r",a,c,e]])),this},B.scale=function(a,c,e,f){if(this.removed)return this;if(a=b(a).split(j),a.length-1&&(c=d(a[1]),e=d(a[2]),f=d(a[3])),a=d(a[0]),null==c&&(c=a),null==f&&(e=f),null==e||null==f)var g=this.getBBox(1);return e=null==e?g.x+g.width/2:e,f=null==f?g.y+g.height/2:f,this.transform(this._.transform.concat([["s",a,c,e,f]])),this},B.translate=function(a,c){return this.removed?this:(a=b(a).split(j),a.length-1&&(c=d(a[1])),a=d(a[0])||0,c=+c||0,this.transform(this._.transform.concat([["t",a,c]])),this)},B.transform=function(b){var d=this._;if(null==b)return d.transform;if(c._extractTransform(this,b),this.clip&&q(this.clip,{transform:this.matrix.invert()}),this.pattern&&s(this),this.node&&q(this.node,{transform:this.matrix}),1!=d.sx||1!=d.sy){var e=this.attrs[a]("stroke-width")?this.attrs["stroke-width"]:1;this.attr({"stroke-width":e})}return this},B.hide=function(){return!this.removed&&this.paper.safari(this.node.style.display="none"),this},B.show=function(){return!this.removed&&this.paper.safari(this.node.style.display=""),this},B.remove=function(){var a=z(this.node);if(!this.removed&&a.parentNode){var b=this.paper;b.__set__&&b.__set__.exclude(this),k.unbind("raphael.*.*."+this.id),this.gradient&&b.defs.removeChild(this.gradient),c._tear(this,b),a.parentNode.removeChild(a),this.removeData();for(var d in this)this[d]="function"==typeof this[d]?c._removedFactory(d):null;this.removed=!0}},B._getBBox=function(){if("none"==this.node.style.display){this.show();var a=!0}var b,c=!1;this.paper.canvas.parentElement?b=this.paper.canvas.parentElement.style:this.paper.canvas.parentNode&&(b=this.paper.canvas.parentNode.style),b&&"none"==b.display&&(c=!0,b.display="");var d={};try{d=this.node.getBBox()}catch(e){d={x:this.node.clientLeft,y:this.node.clientTop,width:this.node.clientWidth,height:this.node.clientHeight}}finally{d=d||{},c&&(b.display="none")}return a&&this.hide(),d},B.attr=function(b,d){if(this.removed)return this;if(null==b){var e={};for(var f in this.attrs)this.attrs[a](f)&&(e[f]=this.attrs[f]);return e.gradient&&"none"==e.fill&&(e.fill=e.gradient)&&delete e.gradient,e.transform=this._.transform,e}if(null==d&&c.is(b,"string")){if("fill"==b&&"none"==this.attrs.fill&&this.attrs.gradient)return this.attrs.gradient;if("transform"==b)return this._.transform;for(var g=b.split(j),h={},i=0,l=g.length;l>i;i++)b=g[i],h[b]=b in this.attrs?this.attrs[b]:c.is(this.paper.customAttributes[b],"function")?this.paper.customAttributes[b].def:c._availableAttrs[b];return l-1?h:h[g[0]]}if(null==d&&c.is(b,"array")){for(h={},i=0,l=b.length;l>i;i++)h[b[i]]=this.attr(b[i]);return h}if(null!=d){var m={};m[b]=d}else null!=b&&c.is(b,"object")&&(m=b);for(var n in m)k("raphael.attr."+n+"."+this.id,this,m[n]);for(n in this.paper.customAttributes)if(this.paper.customAttributes[a](n)&&m[a](n)&&c.is(this.paper.customAttributes[n],"function")){var o=this.paper.customAttributes[n].apply(this,[].concat(m[n]));this.attrs[n]=m[n];for(var p in o)o[a](p)&&(m[p]=o[p])}return w(this,m),this},B.toFront=function(){if(this.removed)return this;var a=z(this.node);a.parentNode.appendChild(a);var b=this.paper;return b.top!=this&&c._tofront(this,b),this},B.toBack=function(){if(this.removed)return this;var a=z(this.node),b=a.parentNode;b.insertBefore(a,b.firstChild),c._toback(this,this.paper);this.paper;return this},B.insertAfter=function(a){if(this.removed||!a)return this;var b=z(this.node),d=z(a.node||a[a.length-1].node);return d.nextSibling?d.parentNode.insertBefore(b,d.nextSibling):d.parentNode.appendChild(b),c._insertafter(this,a,this.paper),this},B.insertBefore=function(a){if(this.removed||!a)return this;var b=z(this.node),d=z(a.node||a[0].node);return d.parentNode.insertBefore(b,d),c._insertbefore(this,a,this.paper),this},B.blur=function(a){var b=this;if(0!==+a){var d=q("filter"),e=q("feGaussianBlur");b.attrs.blur=a,d.id=c.createUUID(),q(e,{stdDeviation:+a||1.5}),d.appendChild(e),b.paper.defs.appendChild(d),b._blur=d,q(b.node,{filter:"url(#"+d.id+")"})}else b._blur&&(b._blur.parentNode.removeChild(b._blur),delete b._blur,delete b.attrs.blur),b.node.removeAttribute("filter");return b},c._engine.circle=function(a,b,c,d){var e=q("circle");a.canvas&&a.canvas.appendChild(e);var f=new A(e,a);return f.attrs={cx:b,cy:c,r:d,fill:"none",stroke:"#000"},f.type="circle",q(e,f.attrs),f},c._engine.rect=function(a,b,c,d,e,f){var g=q("rect");a.canvas&&a.canvas.appendChild(g);var h=new A(g,a);return h.attrs={x:b,y:c,width:d,height:e,rx:f||0,ry:f||0,fill:"none",stroke:"#000"},h.type="rect",q(g,h.attrs),h},c._engine.ellipse=function(a,b,c,d,e){var f=q("ellipse");a.canvas&&a.canvas.appendChild(f);var g=new A(f,a);return g.attrs={cx:b,cy:c,rx:d,ry:e,fill:"none",stroke:"#000"},g.type="ellipse",q(f,g.attrs),g},c._engine.image=function(a,b,c,d,e,f){var g=q("image");q(g,{x:c,y:d,width:e,height:f,preserveAspectRatio:"none"}),g.setAttributeNS(n,"href",b),a.canvas&&a.canvas.appendChild(g);var h=new A(g,a);return h.attrs={x:c,y:d,width:e,height:f,src:b},h.type="image",h},c._engine.text=function(a,b,d,e){var f=q("text");a.canvas&&a.canvas.appendChild(f);var g=new A(f,a);return g.attrs={x:b,y:d,"text-anchor":"middle",text:e,"font-family":c._availableAttrs["font-family"],"font-size":c._availableAttrs["font-size"],stroke:"none",fill:"#000"},g.type="text",w(g,g.attrs),g},c._engine.setSize=function(a,b){return this.width=a||this.width,this.height=b||this.height,this.canvas.setAttribute("width",this.width),this.canvas.setAttribute("height",this.height),this._viewBox&&this.setViewBox.apply(this,this._viewBox),this},c._engine.create=function(){var a=c._getContainer.apply(0,arguments),b=a&&a.container,d=a.x,e=a.y,f=a.width,g=a.height;if(!b)throw new Error("SVG container not found.");var h,i=q("svg"),j="overflow:hidden;";return d=d||0,e=e||0,f=f||512,g=g||342,q(i,{height:g,version:1.1,width:f,xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink"}),1==b?(i.style.cssText=j+"position:absolute;left:"+d+"px;top:"+e+"px",c._g.doc.body.appendChild(i),h=1):(i.style.cssText=j+"position:relative",b.firstChild?b.insertBefore(i,b.firstChild):b.appendChild(i)),b=new c._Paper,b.width=f,b.height=g,b.canvas=i,b.clear(),b._left=b._top=0,h&&(b.renderfix=function(){}),b.renderfix(),b},c._engine.setViewBox=function(a,b,c,d,e){k("raphael.setViewBox",this,this._viewBox,[a,b,c,d,e]);var f,h,i=this.getSize(),j=g(c/i.width,d/i.height),l=this.top,n=e?"xMidYMid meet":"xMinYMin";for(null==a?(this._vbSize&&(j=1),delete this._vbSize,f="0 0 "+this.width+m+this.height):(this._vbSize=j,f=a+m+b+m+c+m+d),q(this.canvas,{viewBox:f,preserveAspectRatio:n});j&&l;)h="stroke-width"in l.attrs?l.attrs["stroke-width"]:1,l.attr({"stroke-width":h}),l._.dirty=1,l._.dirtyT=1,l=l.prev;return this._viewBox=[a,b,c,d,!!e],this},c.prototype.renderfix=function(){var a,b=this.canvas,c=b.style;try{a=b.getScreenCTM()||b.createSVGMatrix()}catch(d){a=b.createSVGMatrix()}var e=-a.e%1,f=-a.f%1;(e||f)&&(e&&(this._left=(this._left+e)%1,c.left=this._left+"px"),f&&(this._top=(this._top+f)%1,c.top=this._top+"px"))},c.prototype.clear=function(){c.eve("raphael.clear",this);for(var a=this.canvas;a.firstChild;)a.removeChild(a.firstChild);this.bottom=this.top=null,(this.desc=q("desc")).appendChild(c._g.doc.createTextNode("Created with Raphal "+c.version)),a.appendChild(this.desc),a.appendChild(this.defs=q("defs"))},c.prototype.remove=function(){k("raphael.remove",this),this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas);for(var a in this)this[a]="function"==typeof this[a]?c._removedFactory(a):null};var C=c.st;for(var D in B)B[a](D)&&!C[a](D)&&(C[D]=function(a){return function(){var b=arguments;return this.forEach(function(c){c[a].apply(c,b)})}}(D))}}(),function(){if(c.vml){var a="hasOwnProperty",b=String,d=parseFloat,e=Math,f=e.round,g=e.max,h=e.min,i=e.abs,j="fill",k=/[, ]+/,l=c.eve,m=" progid:DXImageTransform.Microsoft",n=" ",o="",p={M:"m",L:"l",C:"c",Z:"x",m:"t",l:"r",c:"v",z:"x"},q=/([clmz]),?([^clmz]*)/gi,r=/ progid:\S+Blur\([^\)]+\)/g,s=/-?[^,\s-]+/g,t="position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)",u=21600,v={path:1,rect:1,image:1},w={circle:1,ellipse:1},x=function(a){var d=/[ahqstv]/gi,e=c._pathToAbsolute;if(b(a).match(d)&&(e=c._path2curve),d=/[clmz]/g,e==c._pathToAbsolute&&!b(a).match(d)){var g=b(a).replace(q,function(a,b,c){var d=[],e="m"==b.toLowerCase(),g=p[b];return c.replace(s,function(a){e&&2==d.length&&(g+=d+p["m"==b?"l":"L"],d=[]),d.push(f(a*u))}),g+d});return g}var h,i,j=e(a);g=[];for(var k=0,l=j.length;l>k;k++){h=j[k],i=j[k][0].toLowerCase(),"z"==i&&(i="x");for(var m=1,r=h.length;r>m;m++)i+=f(h[m]*u)+(m!=r-1?",":o);g.push(i)}return g.join(n)},y=function(a,b,d){var e=c.matrix();return e.rotate(-a,.5,.5),{dx:e.x(b,d),dy:e.y(b,d)}},z=function(a,b,c,d,e,f){var g=a._,h=a.matrix,k=g.fillpos,l=a.node,m=l.style,o=1,p="",q=u/b,r=u/c;if(m.visibility="hidden",b&&c){if(l.coordsize=i(q)+n+i(r),m.rotation=f*(0>b*c?-1:1),f){var s=y(f,d,e);d=s.dx,e=s.dy}if(0>b&&(p+="x"),0>c&&(p+=" y")&&(o=-1),m.flip=p,l.coordorigin=d*-q+n+e*-r,k||g.fillsize){var t=l.getElementsByTagName(j);t=t&&t[0],l.removeChild(t),k&&(s=y(f,h.x(k[0],k[1]),h.y(k[0],k[1])),t.position=s.dx*o+n+s.dy*o),g.fillsize&&(t.size=g.fillsize[0]*i(b)+n+g.fillsize[1]*i(c)),l.appendChild(t)}m.visibility="visible"}};c.toString=function(){return"Your browser doesnt support SVG. Falling down to VML.\nYou are running Raphal "+this.version};var A=function(a,c,d){for(var e=b(c).toLowerCase().split("-"),f=d?"end":"start",g=e.length,h="classic",i="medium",j="medium";g--;)switch(e[g]){case"block":case"classic":case"oval":case"diamond":case"open":case"none":h=e[g];break;case"wide":case"narrow":j=e[g];break;case"long":case"short":i=e[g]}var k=a.node.getElementsByTagName("stroke")[0];k[f+"arrow"]=h,k[f+"arrowlength"]=i,k[f+"arrowwidth"]=j},B=function(e,i){e.attrs=e.attrs||{};var l=e.node,m=e.attrs,p=l.style,q=v[e.type]&&(i.x!=m.x||i.y!=m.y||i.width!=m.width||i.height!=m.height||i.cx!=m.cx||i.cy!=m.cy||i.rx!=m.rx||i.ry!=m.ry||i.r!=m.r),r=w[e.type]&&(m.cx!=i.cx||m.cy!=i.cy||m.r!=i.r||m.rx!=i.rx||m.ry!=i.ry),s=e;for(var t in i)i[a](t)&&(m[t]=i[t]);if(q&&(m.path=c._getPath[e.type](e),e._.dirty=1),i.href&&(l.href=i.href),i.title&&(l.title=i.title),i.target&&(l.target=i.target),i.cursor&&(p.cursor=i.cursor),"blur"in i&&e.blur(i.blur),(i.path&&"path"==e.type||q)&&(l.path=x(~b(m.path).toLowerCase().indexOf("r")?c._pathToAbsolute(m.path):m.path),e._.dirty=1,"image"==e.type&&(e._.fillpos=[m.x,m.y],e._.fillsize=[m.width,m.height],z(e,1,1,0,0,0))),"transform"in i&&e.transform(i.transform),r){var y=+m.cx,B=+m.cy,D=+m.rx||+m.r||0,E=+m.ry||+m.r||0;l.path=c.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x",f((y-D)*u),f((B-E)*u),f((y+D)*u),f((B+E)*u),f(y*u)),e._.dirty=1}if("clip-rect"in i){var G=b(i["clip-rect"]).split(k);if(4==G.length){G[2]=+G[2]+ +G[0],G[3]=+G[3]+ +G[1];var H=l.clipRect||c._g.doc.createElement("div"),I=H.style;I.clip=c.format("rect({1}px {2}px {3}px {0}px)",G),l.clipRect||(I.position="absolute",I.top=0,I.left=0,I.width=e.paper.width+"px",I.height=e.paper.height+"px",l.parentNode.insertBefore(H,l),H.appendChild(l),l.clipRect=H)}i["clip-rect"]||l.clipRect&&(l.clipRect.style.clip="auto")}if(e.textpath){var J=e.textpath.style;i.font&&(J.font=i.font),i["font-family"]&&(J.fontFamily='"'+i["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g,o)+'"'),i["font-size"]&&(J.fontSize=i["font-size"]),i["font-weight"]&&(J.fontWeight=i["font-weight"]),i["font-style"]&&(J.fontStyle=i["font-style"])}if("arrow-start"in i&&A(s,i["arrow-start"]),"arrow-end"in i&&A(s,i["arrow-end"],1),null!=i.opacity||null!=i["stroke-width"]||null!=i.fill||null!=i.src||null!=i.stroke||null!=i["stroke-width"]||null!=i["stroke-opacity"]||null!=i["fill-opacity"]||null!=i["stroke-dasharray"]||null!=i["stroke-miterlimit"]||null!=i["stroke-linejoin"]||null!=i["stroke-linecap"]){var K=l.getElementsByTagName(j),L=!1;if(K=K&&K[0],!K&&(L=K=F(j)),"image"==e.type&&i.src&&(K.src=i.src),i.fill&&(K.on=!0),(null==K.on||"none"==i.fill||null===i.fill)&&(K.on=!1),K.on&&i.fill){var M=b(i.fill).match(c._ISURL);if(M){K.parentNode==l&&l.removeChild(K),K.rotate=!0,K.src=M[1],K.type="tile";var N=e.getBBox(1);K.position=N.x+n+N.y,e._.fillpos=[N.x,N.y],c._preload(M[1],function(){e._.fillsize=[this.offsetWidth,this.offsetHeight]})}else K.color=c.getRGB(i.fill).hex,K.src=o,K.type="solid",c.getRGB(i.fill).error&&(s.type in{circle:1,ellipse:1}||"r"!=b(i.fill).charAt())&&C(s,i.fill,K)&&(m.fill="none",m.gradient=i.fill,K.rotate=!1)}if("fill-opacity"in i||"opacity"in i){var O=((+m["fill-opacity"]+1||2)-1)*((+m.opacity+1||2)-1)*((+c.getRGB(i.fill).o+1||2)-1);O=h(g(O,0),1),K.opacity=O,K.src&&(K.color="none")}l.appendChild(K);var P=l.getElementsByTagName("stroke")&&l.getElementsByTagName("stroke")[0],Q=!1;!P&&(Q=P=F("stroke")),(i.stroke&&"none"!=i.stroke||i["stroke-width"]||null!=i["stroke-opacity"]||i["stroke-dasharray"]||i["stroke-miterlimit"]||i["stroke-linejoin"]||i["stroke-linecap"])&&(P.on=!0),("none"==i.stroke||null===i.stroke||null==P.on||0==i.stroke||0==i["stroke-width"])&&(P.on=!1);var R=c.getRGB(i.stroke);P.on&&i.stroke&&(P.color=R.hex),O=((+m["stroke-opacity"]+1||2)-1)*((+m.opacity+1||2)-1)*((+R.o+1||2)-1);var S=.75*(d(i["stroke-width"])||1);if(O=h(g(O,0),1),null==i["stroke-width"]&&(S=m["stroke-width"]),i["stroke-width"]&&(P.weight=S),S&&1>S&&(O*=S)&&(P.weight=1),P.opacity=O,i["stroke-linejoin"]&&(P.joinstyle=i["stroke-linejoin"]||"miter"),P.miterlimit=i["stroke-miterlimit"]||8,i["stroke-linecap"]&&(P.endcap="butt"==i["stroke-linecap"]?"flat":"square"==i["stroke-linecap"]?"square":"round"),"stroke-dasharray"in i){var T={"-":"shortdash",".":"shortdot","-.":"shortdashdot","-..":"shortdashdotdot",". ":"dot","- ":"dash","--":"longdash","- .":"dashdot","--.":"longdashdot","--..":"longdashdotdot"};P.dashstyle=T[a](i["stroke-dasharray"])?T[i["stroke-dasharray"]]:o}Q&&l.appendChild(P)}if("text"==s.type){s.paper.canvas.style.display=o;var U=s.paper.span,V=100,W=m.font&&m.font.match(/\d+(?:\.\d*)?(?=px)/);p=U.style,m.font&&(p.font=m.font),m["font-family"]&&(p.fontFamily=m["font-family"]),m["font-weight"]&&(p.fontWeight=m["font-weight"]),m["font-style"]&&(p.fontStyle=m["font-style"]),W=d(m["font-size"]||W&&W[0])||10,p.fontSize=W*V+"px",s.textpath.string&&(U.innerHTML=b(s.textpath.string).replace(/</g,"&#60;").replace(/&/g,"&#38;").replace(/\n/g,"<br>"));var X=U.getBoundingClientRect();s.W=m.w=(X.right-X.left)/V,s.H=m.h=(X.bottom-X.top)/V,s.X=m.x,s.Y=m.y+s.H/2,("x"in i||"y"in i)&&(s.path.v=c.format("m{0},{1}l{2},{1}",f(m.x*u),f(m.y*u),f(m.x*u)+1));for(var Y=["x","y","text","font","font-family","font-weight","font-style","font-size"],Z=0,$=Y.length;$>Z;Z++)if(Y[Z]in i){s._.dirty=1;break}switch(m["text-anchor"]){case"start":s.textpath.style["v-text-align"]="left",s.bbx=s.W/2;break;case"end":s.textpath.style["v-text-align"]="right",s.bbx=-s.W/2;break;default:s.textpath.style["v-text-align"]="center",s.bbx=0}s.textpath.style["v-text-kern"]=!0}},C=function(a,f,g){a.attrs=a.attrs||{};var h=(a.attrs,Math.pow),i="linear",j=".5 .5";if(a.attrs.gradient=f,f=b(f).replace(c._radial_gradient,function(a,b,c){return i="radial",b&&c&&(b=d(b),c=d(c),h(b-.5,2)+h(c-.5,2)>.25&&(c=e.sqrt(.25-h(b-.5,2))*(2*(c>.5)-1)+.5),j=b+n+c),o}),f=f.split(/\s*\-\s*/),"linear"==i){var k=f.shift();if(k=-d(k),isNaN(k))return null}var l=c._parseDots(f);if(!l)return null;if(a=a.shape||a.node,l.length){a.removeChild(g),g.on=!0,g.method="none",g.color=l[0].color,g.color2=l[l.length-1].color;for(var m=[],p=0,q=l.length;q>p;p++)l[p].offset&&m.push(l[p].offset+n+l[p].color);g.colors=m.length?m.join():"0% "+g.color,"radial"==i?(g.type="gradientTitle",g.focus="100%",g.focussize="0 0",g.focusposition=j,g.angle=0):(g.type="gradient",g.angle=(270-k)%360),a.appendChild(g)}return 1},D=function(a,b){this[0]=this.node=a,a.raphael=!0,this.id=c._oid++,a.raphaelid=this.id,this.X=0,this.Y=0,this.attrs={},this.paper=b,this.matrix=c.matrix(),this._={transform:[],sx:1,sy:1,dx:0,dy:0,deg:0,dirty:1,dirtyT:1},!b.bottom&&(b.bottom=this),this.prev=b.top,b.top&&(b.top.next=this),b.top=this,this.next=null},E=c.el;D.prototype=E,E.constructor=D,E.transform=function(a){if(null==a)return this._.transform;var d,e=this.paper._viewBoxShift,f=e?"s"+[e.scale,e.scale]+"-1-1t"+[e.dx,e.dy]:o;e&&(d=a=b(a).replace(/\.{3}|\u2026/g,this._.transform||o)),c._extractTransform(this,f+a);var g,h=this.matrix.clone(),i=this.skew,j=this.node,k=~b(this.attrs.fill).indexOf("-"),l=!b(this.attrs.fill).indexOf("url(");if(h.translate(1,1),l||k||"image"==this.type)if(i.matrix="1 0 0 1",i.offset="0 0",g=h.split(),k&&g.noRotation||!g.isSimple){j.style.filter=h.toFilter();var m=this.getBBox(),p=this.getBBox(1),q=m.x-p.x,r=m.y-p.y;j.coordorigin=q*-u+n+r*-u,z(this,1,1,q,r,0)}else j.style.filter=o,z(this,g.scalex,g.scaley,g.dx,g.dy,g.rotate);else j.style.filter=o,i.matrix=b(h),i.offset=h.offset();return null!==d&&(this._.transform=d,c._extractTransform(this,d)),this},E.rotate=function(a,c,e){if(this.removed)return this;if(null!=a){if(a=b(a).split(k),a.length-1&&(c=d(a[1]),e=d(a[2])),a=d(a[0]),null==e&&(c=e),null==c||null==e){var f=this.getBBox(1);c=f.x+f.width/2,e=f.y+f.height/2}return this._.dirtyT=1,this.transform(this._.transform.concat([["r",a,c,e]])),this}},E.translate=function(a,c){return this.removed?this:(a=b(a).split(k),a.length-1&&(c=d(a[1])),a=d(a[0])||0,c=+c||0,this._.bbox&&(this._.bbox.x+=a,this._.bbox.y+=c),this.transform(this._.transform.concat([["t",a,c]])),this)},E.scale=function(a,c,e,f){if(this.removed)return this;if(a=b(a).split(k),a.length-1&&(c=d(a[1]),e=d(a[2]),f=d(a[3]),isNaN(e)&&(e=null),isNaN(f)&&(f=null)),a=d(a[0]),null==c&&(c=a),null==f&&(e=f),null==e||null==f)var g=this.getBBox(1);return e=null==e?g.x+g.width/2:e,f=null==f?g.y+g.height/2:f,this.transform(this._.transform.concat([["s",a,c,e,f]])),this._.dirtyT=1,this},E.hide=function(){return!this.removed&&(this.node.style.display="none"),this},E.show=function(){return!this.removed&&(this.node.style.display=o),this},E.auxGetBBox=c.el.getBBox,E.getBBox=function(){var a=this.auxGetBBox();if(this.paper&&this.paper._viewBoxShift){var b={},c=1/this.paper._viewBoxShift.scale;return b.x=a.x-this.paper._viewBoxShift.dx,b.x*=c,b.y=a.y-this.paper._viewBoxShift.dy,b.y*=c,b.width=a.width*c,b.height=a.height*c,b.x2=b.x+b.width,b.y2=b.y+b.height,b}return a},E._getBBox=function(){return this.removed?{}:{x:this.X+(this.bbx||0)-this.W/2,y:this.Y-this.H,width:this.W,height:this.H}},E.remove=function(){if(!this.removed&&this.node.parentNode){this.paper.__set__&&this.paper.__set__.exclude(this),c.eve.unbind("raphael.*.*."+this.id),c._tear(this,this.paper),this.node.parentNode.removeChild(this.node),this.shape&&this.shape.parentNode.removeChild(this.shape);for(var a in this)this[a]="function"==typeof this[a]?c._removedFactory(a):null;this.removed=!0}},E.attr=function(b,d){if(this.removed)return this;if(null==b){var e={};for(var f in this.attrs)this.attrs[a](f)&&(e[f]=this.attrs[f]);return e.gradient&&"none"==e.fill&&(e.fill=e.gradient)&&delete e.gradient,e.transform=this._.transform,e}if(null==d&&c.is(b,"string")){if(b==j&&"none"==this.attrs.fill&&this.attrs.gradient)return this.attrs.gradient;for(var g=b.split(k),h={},i=0,m=g.length;m>i;i++)b=g[i],h[b]=b in this.attrs?this.attrs[b]:c.is(this.paper.customAttributes[b],"function")?this.paper.customAttributes[b].def:c._availableAttrs[b];return m-1?h:h[g[0]]}if(this.attrs&&null==d&&c.is(b,"array")){for(h={},i=0,m=b.length;m>i;i++)h[b[i]]=this.attr(b[i]);return h}var n;null!=d&&(n={},n[b]=d),null==d&&c.is(b,"object")&&(n=b);for(var o in n)l("raphael.attr."+o+"."+this.id,this,n[o]);if(n){for(o in this.paper.customAttributes)if(this.paper.customAttributes[a](o)&&n[a](o)&&c.is(this.paper.customAttributes[o],"function")){var p=this.paper.customAttributes[o].apply(this,[].concat(n[o]));this.attrs[o]=n[o];for(var q in p)p[a](q)&&(n[q]=p[q])}n.text&&"text"==this.type&&(this.textpath.string=n.text),B(this,n)}return this},E.toFront=function(){return!this.removed&&this.node.parentNode.appendChild(this.node),this.paper&&this.paper.top!=this&&c._tofront(this,this.paper),this},E.toBack=function(){return this.removed?this:(this.node.parentNode.firstChild!=this.node&&(this.node.parentNode.insertBefore(this.node,this.node.parentNode.firstChild),c._toback(this,this.paper)),this)},E.insertAfter=function(a){return this.removed?this:(a.constructor==c.st.constructor&&(a=a[a.length-1]),a.node.nextSibling?a.node.parentNode.insertBefore(this.node,a.node.nextSibling):a.node.parentNode.appendChild(this.node),c._insertafter(this,a,this.paper),this)},E.insertBefore=function(a){return this.removed?this:(a.constructor==c.st.constructor&&(a=a[0]),a.node.parentNode.insertBefore(this.node,a.node),c._insertbefore(this,a,this.paper),this)},E.blur=function(a){var b=this.node.runtimeStyle,d=b.filter;return d=d.replace(r,o),0!==+a?(this.attrs.blur=a,b.filter=d+n+m+".Blur(pixelradius="+(+a||1.5)+")",b.margin=c.format("-{0}px 0 0 -{0}px",f(+a||1.5))):(b.filter=d,b.margin=0,delete this.attrs.blur),this},c._engine.path=function(a,b){var c=F("shape");c.style.cssText=t,c.coordsize=u+n+u,c.coordorigin=b.coordorigin;var d=new D(c,b),e={fill:"none",stroke:"#000"};a&&(e.path=a),d.type="path",d.path=[],d.Path=o,B(d,e),b.canvas.appendChild(c);var f=F("skew");return f.on=!0,c.appendChild(f),d.skew=f,d.transform(o),d},c._engine.rect=function(a,b,d,e,f,g){var h=c._rectPath(b,d,e,f,g),i=a.path(h),j=i.attrs;return i.X=j.x=b,i.Y=j.y=d,i.W=j.width=e,i.H=j.height=f,j.r=g,j.path=h,i.type="rect",i},c._engine.ellipse=function(a,b,c,d,e){{var f=a.path();f.attrs}return f.X=b-d,f.Y=c-e,f.W=2*d,f.H=2*e,f.type="ellipse",B(f,{cx:b,cy:c,rx:d,ry:e}),f},c._engine.circle=function(a,b,c,d){{var e=a.path();e.attrs}return e.X=b-d,e.Y=c-d,e.W=e.H=2*d,e.type="circle",B(e,{cx:b,cy:c,r:d}),e},c._engine.image=function(a,b,d,e,f,g){var h=c._rectPath(d,e,f,g),i=a.path(h).attr({stroke:"none"}),k=i.attrs,l=i.node,m=l.getElementsByTagName(j)[0];return k.src=b,i.X=k.x=d,i.Y=k.y=e,i.W=k.width=f,i.H=k.height=g,k.path=h,i.type="image",m.parentNode==l&&l.removeChild(m),m.rotate=!0,m.src=b,m.type="tile",i._.fillpos=[d,e],i._.fillsize=[f,g],l.appendChild(m),z(i,1,1,0,0,0),i},c._engine.text=function(a,d,e,g){var h=F("shape"),i=F("path"),j=F("textpath");d=d||0,e=e||0,g=g||"",i.v=c.format("m{0},{1}l{2},{1}",f(d*u),f(e*u),f(d*u)+1),i.textpathok=!0,j.string=b(g),j.on=!0,h.style.cssText=t,h.coordsize=u+n+u,h.coordorigin="0 0";var k=new D(h,a),l={fill:"#000",stroke:"none",font:c._availableAttrs.font,text:g};k.shape=h,k.path=i,k.textpath=j,k.type="text",k.attrs.text=b(g),k.attrs.x=d,k.attrs.y=e,k.attrs.w=1,k.attrs.h=1,B(k,l),h.appendChild(j),h.appendChild(i),a.canvas.appendChild(h);var m=F("skew");return m.on=!0,h.appendChild(m),k.skew=m,k.transform(o),k},c._engine.setSize=function(a,b){var d=this.canvas.style;return this.width=a,this.height=b,a==+a&&(a+="px"),b==+b&&(b+="px"),d.width=a,d.height=b,d.clip="rect(0 "+a+" "+b+" 0)",this._viewBox&&c._engine.setViewBox.apply(this,this._viewBox),this},c._engine.setViewBox=function(a,b,d,e,f){c.eve("raphael.setViewBox",this,this._viewBox,[a,b,d,e,f]);var g,h,i=this.getSize(),j=i.width,k=i.height;return f&&(g=k/e,h=j/d,j>d*g&&(a-=(j-d*g)/2/g),k>e*h&&(b-=(k-e*h)/2/h)),this._viewBox=[a,b,d,e,!!f],this._viewBoxShift={dx:-a,dy:-b,scale:i},this.forEach(function(a){a.transform("...")}),this};var F;c._engine.initWin=function(a){var b=a.document;b.styleSheets.length<31?b.createStyleSheet().addRule(".rvml","behavior:url(#default#VML)"):b.styleSheets[0].addRule(".rvml","behavior:url(#default#VML)");try{!b.namespaces.rvml&&b.namespaces.add("rvml","urn:schemas-microsoft-com:vml"),F=function(a){return b.createElement("<rvml:"+a+' class="rvml">')}}catch(c){F=function(a){return b.createElement("<"+a+' xmlns="urn:schemas-microsoft.com:vml" class="rvml">')}}},c._engine.initWin(c._g.win),c._engine.create=function(){var a=c._getContainer.apply(0,arguments),b=a.container,d=a.height,e=a.width,f=a.x,g=a.y;if(!b)throw new Error("VML container not found.");var h=new c._Paper,i=h.canvas=c._g.doc.createElement("div"),j=i.style;return f=f||0,g=g||0,e=e||512,d=d||342,h.width=e,h.height=d,e==+e&&(e+="px"),d==+d&&(d+="px"),h.coordsize=1e3*u+n+1e3*u,h.coordorigin="0 0",h.span=c._g.doc.createElement("span"),h.span.style.cssText="position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;",i.appendChild(h.span),j.cssText=c.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden",e,d),1==b?(c._g.doc.body.appendChild(i),j.left=f+"px",j.top=g+"px",j.position="absolute"):b.firstChild?b.insertBefore(i,b.firstChild):b.appendChild(i),h.renderfix=function(){},h},c.prototype.clear=function(){c.eve("raphael.clear",this),this.canvas.innerHTML=o,this.span=c._g.doc.createElement("span"),this.span.style.cssText="position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;",this.canvas.appendChild(this.span),this.bottom=this.top=null},c.prototype.remove=function(){c.eve("raphael.remove",this),this.canvas.parentNode.removeChild(this.canvas);for(var a in this)this[a]="function"==typeof this[a]?c._removedFactory(a):null;return!0};var G=c.st;for(var H in E)E[a](H)&&!G[a](H)&&(G[H]=function(a){return function(){var b=arguments;return this.forEach(function(c){c[a].apply(c,b)})}}(H))}}(),B.was?A.win.Raphael=c:Raphael=c,"object"==typeof exports&&(module.exports=c),c});

}
GlobalContext.setModule("component/sequenceDiagram.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/sharedCallbacks.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var slice = [].slice;

  module.exports.create = (function(_this) {
    return function() {
      var fn;
      fn = function() {
        var args, callback, cbs, i, len, results;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        cbs = fn.callbacks.slice(0);
        fn.callbacks.length = 0;
        results = [];
        for (i = 0, len = cbs.length; i < len; i++) {
          callback = cbs[i];
          results.push(callback.apply(null, args));
        }
        return results;
      };
      fn.callbacks = [];
      fn.__defineGetter__("length", function() {
        return fn.callbacks.length;
      });
      fn.__defineGetter__("count", function() {
        return fn.callbacks.length;
      });
      fn.push = function(callback) {
        if (typeof callback !== "function") {
          Logger.warn("SharedCallback.push with none function", callback);
          return false;
        }
        return this.callbacks.push(callback);
      };
      fn.clear = function() {
        return fn.callbacks.length = 0;
      };
      return fn;
    };
  })(this);

}).call(this);

}
GlobalContext.setModule("component/sharedCallbacks.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/showdown.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    /*! showdown 19-10-2015 */

(function(){function a(a){"use strict";var b={omitExtraWLInCodeBlocks:{"default":!1,describe:"Omit the default extra whiteline added to code blocks",type:"boolean"},noHeaderId:{"default":!1,describe:"Turn on/off generated header id",type:"boolean"},prefixHeaderId:{"default":!1,describe:"Specify a prefix to generated header ids",type:"string"},headerLevelStart:{"default":!1,describe:"The header blocks level start",type:"integer"},parseImgDimensions:{"default":!1,describe:"Turn on/off image dimension parsing",type:"boolean"},simplifiedAutoLink:{"default":!1,describe:"Turn on/off GFM autolink style",type:"boolean"},literalMidWordUnderscores:{"default":!1,describe:"Parse midword underscores as literal underscores",type:"boolean"},strikethrough:{"default":!1,describe:"Turn on/off strikethrough support",type:"boolean"},tables:{"default":!1,describe:"Turn on/off tables support",type:"boolean"},tablesHeaderId:{"default":!1,describe:"Add an id to table headers",type:"boolean"},ghCodeBlocks:{"default":!0,describe:"Turn on/off GFM fenced code blocks support",type:"boolean"},tasklists:{"default":!1,describe:"Turn on/off GFM tasklist support",type:"boolean"},smoothLivePreview:{"default":!1,describe:"Prevents weird effects in live previews due to incomplete input",type:"boolean"}};if(a===!1)return JSON.parse(JSON.stringify(b));var c={};for(var d in b)b.hasOwnProperty(d)&&(c[d]=b[d]["default"]);return c}function b(a,b){"use strict";var c=b?"Error in "+b+" extension->":"Error in unnamed extension",e={valid:!0,error:""};d.helper.isArray(a)||(a=[a]);for(var f=0;f<a.length;++f){var g=c+" sub-extension "+f+": ",h=a[f];if("object"!=typeof h)return e.valid=!1,e.error=g+"must be an object, but "+typeof h+" given",e;if(!d.helper.isString(h.type))return e.valid=!1,e.error=g+'property "type" must be a string, but '+typeof h.type+" given",e;var i=h.type=h.type.toLowerCase();if("language"===i&&(i=h.type="lang"),"html"===i&&(i=h.type="output"),"lang"!==i&&"output"!==i&&"listener"!==i)return e.valid=!1,e.error=g+"type "+i+' is not recognized. Valid values: "lang/language", "output/html" or "listener"',e;if("listener"===i){if(d.helper.isUndefined(h.listeners))return e.valid=!1,e.error=g+'. Extensions of type "listener" must have a property called "listeners"',e}else if(d.helper.isUndefined(h.filter)&&d.helper.isUndefined(h.regex))return e.valid=!1,e.error=g+i+' extensions must define either a "regex" property or a "filter" method',e;if(h.listeners){if("object"!=typeof h.listeners)return e.valid=!1,e.error=g+'"listeners" property must be an object but '+typeof h.listeners+" given",e;for(var j in h.listeners)if(h.listeners.hasOwnProperty(j)&&"function"!=typeof h.listeners[j])return e.valid=!1,e.error=g+'"listeners" property must be an hash of [event name]: [callback]. listeners.'+j+" must be a function but "+typeof h.listeners[j]+" given",e}if(h.filter){if("function"!=typeof h.filter)return e.valid=!1,e.error=g+'"filter" must be a function, but '+typeof h.filter+" given",e}else if(h.regex){if(d.helper.isString(h.regex)&&(h.regex=new RegExp(h.regex,"g")),!h.regex instanceof RegExp)return e.valid=!1,e.error=g+'"regex" property must either be a string or a RegExp object, but '+typeof h.regex+" given",e;if(d.helper.isUndefined(h.replace))return e.valid=!1,e.error=g+'"regex" extensions must implement a replace string or function',e}}return e}function c(a,b){"use strict";var c=b.charCodeAt(0);return"~E"+c+"E"}var d={},e={},f={},g=a(!0),h={github:{omitExtraWLInCodeBlocks:!0,prefixHeaderId:"user-content-",simplifiedAutoLink:!0,literalMidWordUnderscores:!0,strikethrough:!0,tables:!0,tablesHeaderId:!0,ghCodeBlocks:!0,tasklists:!0},vanilla:a(!0)};d.helper={},d.extensions={},d.setOption=function(a,b){"use strict";return g[a]=b,this},d.getOption=function(a){"use strict";return g[a]},d.getOptions=function(){"use strict";return g},d.resetOptions=function(){"use strict";g=a(!0)},d.setFlavor=function(a){"use strict";if(h.hasOwnProperty(a)){var b=h[a];for(var c in b)b.hasOwnProperty(c)&&(g[c]=b[c])}},d.getDefaultOptions=function(b){"use strict";return a(b)},d.subParser=function(a,b){"use strict";if(d.helper.isString(a)){if("undefined"==typeof b){if(e.hasOwnProperty(a))return e[a];throw Error("SubParser named "+a+" not registered!")}e[a]=b}},d.extension=function(a,c){"use strict";if(!d.helper.isString(a))throw Error("Extension 'name' must be a string");if(a=d.helper.stdExtName(a),d.helper.isUndefined(c)){if(!f.hasOwnProperty(a))throw Error("Extension named "+a+" is not registered!");return f[a]}"function"==typeof c&&(c=c()),d.helper.isArray(c)||(c=[c]);var e=b(c,a);if(!e.valid)throw Error(e.error);f[a]=c},d.getAllExtensions=function(){"use strict";return f},d.removeExtension=function(a){"use strict";delete f[a]},d.resetExtensions=function(){"use strict";f={}},d.validateExtension=function(a){"use strict";var c=b(a,null);return c.valid?!0:(console.warn(c.error),!1)},d.hasOwnProperty("helper")||(d.helper={}),d.helper.isString=function(a){"use strict";return"string"==typeof a||a instanceof String},d.helper.forEach=function(a,b){"use strict";if("function"==typeof a.forEach)a.forEach(b);else for(var c=0;c<a.length;c++)b(a[c],c,a)},d.helper.isArray=function(a){"use strict";return a.constructor===Array},d.helper.isUndefined=function(a){"use strict";return"undefined"==typeof a},d.helper.stdExtName=function(a){"use strict";return a.replace(/[_-]||\s/g,"").toLowerCase()},d.helper.escapeCharactersCallback=c,d.helper.escapeCharacters=function(a,b,d){"use strict";var e="(["+b.replace(/([\[\]\\])/g,"\\$1")+"])";d&&(e="\\\\"+e);var f=new RegExp(e,"g");return a=a.replace(f,c)},d.helper.matchRecursiveRegExp=function(a,b,c,d){"use strict";var e,f,g,h,i,j=d||"",k=j.indexOf("g")>-1,l=new RegExp(b+"|"+c,j),m=new RegExp(b,j.replace(/g/g,"")),n=[];do for(e=0;g=l.exec(a);)if(m.test(g[0]))e++||(h=g[0],f=l.lastIndex);else if(e&&!--e){i=g[0];var o=a.slice(f,g.index);if(n.push([h+o+i,o]),!k)return n}while(e&&(l.lastIndex=f));return n},d.helper.isUndefined(console)&&(console={warn:function(a){"use strict";alert(a)},log:function(a){"use strict";alert(a)},error:function(a){"use strict";throw a}}),d.Converter=function(a){"use strict";function c(){a=a||{};for(var b in g)g.hasOwnProperty(b)&&(k[b]=g[b]);if("object"!=typeof a)throw Error("Converter expects the passed parameter to be an object, but "+typeof a+" was passed instead.");for(var c in a)a.hasOwnProperty(c)&&(k[c]=a[c]);k.extensions&&d.helper.forEach(k.extensions,e)}function e(a,c){if(c=c||null,d.helper.isString(a)){if(a=d.helper.stdExtName(a),c=a,d.extensions[a])return console.warn("DEPRECATION WARNING: "+a+" is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!"),void i(d.extensions[a],a);if(d.helper.isUndefined(f[a]))throw Error('Extension "'+a+'" could not be loaded. It was either not found or is not a valid extension.');a=f[a]}"function"==typeof a&&(a=a()),d.helper.isArray(a)||(a=[a]);var e=b(a,c);if(!e.valid)throw Error(e.error);for(var g=0;g<a.length;++g){switch(a[g].type){case"lang":l.push(a[g]);break;case"output":m.push(a[g])}if(a[g].hasOwnProperty(n))for(var h in a[g].listeners)a[g].listeners.hasOwnProperty(h)&&j(h,a[g].listeners[h])}}function i(a,c){"function"==typeof a&&(a=a(new d.Converter)),d.helper.isArray(a)||(a=[a]);var e=b(a,c);if(!e.valid)throw Error(e.error);for(var f=0;f<a.length;++f)switch(a[f].type){case"lang":l.push(a[f]);break;case"output":m.push(a[f]);break;default:throw Error("Extension loader error: Type unrecognized!!!")}}function j(a,b){if(!d.helper.isString(a))throw Error("Invalid argument in converter.listen() method: name must be a string, but "+typeof a+" given");if("function"!=typeof b)throw Error("Invalid argument in converter.listen() method: callback must be a function, but "+typeof b+" given");n.hasOwnProperty(a)||(n[a]=[]),n[a].push(b)}var k={},l=[],m=[],n={};c(),this._dispatch=function(a,b,c){if(n.hasOwnProperty(a))for(var d=0;d<n[a].length;++d){var e=n[a][d](a,b,this,c);e&&"undefined"!=typeof e&&(b=e)}return b},this.listen=function(a,b){return j(a,b),this},this.makeHtml=function(a){if(!a)return a;var b={gHtmlBlocks:[],gHtmlSpans:[],gUrls:{},gTitles:{},gDimensions:{},gListLevel:0,hashLinkCounts:{},langExtensions:l,outputModifiers:m,converter:this};return a=a.replace(/~/g,"~T"),a=a.replace(/\$/g,"~D"),a=a.replace(/\r\n/g,"\n"),a=a.replace(/\r/g,"\n"),a="\n\n"+a+"\n\n",a=d.subParser("detab")(a,k,b),a=d.subParser("stripBlankLines")(a,k,b),d.helper.forEach(l,function(c){a=d.subParser("runExtension")(c,a,k,b)}),a=d.subParser("githubCodeBlocks")(a,k,b),a=d.subParser("hashHTMLBlocks")(a,k,b),a=d.subParser("hashHTMLSpans")(a,k,b),a=d.subParser("stripLinkDefinitions")(a,k,b),a=d.subParser("blockGamut")(a,k,b),a=d.subParser("unhashHTMLSpans")(a,k,b),a=d.subParser("unescapeSpecialChars")(a,k,b),a=a.replace(/~D/g,"$"),a=a.replace(/~T/g,"~"),d.helper.forEach(m,function(c){a=d.subParser("runExtension")(c,a,k,b)}),a},this.setOption=function(a,b){k[a]=b},this.getOption=function(a){return k[a]},this.getOptions=function(){return k},this.addExtension=function(a,b){b=b||null,e(a,b)},this.useExtension=function(a){e(a)},this.setFlavor=function(a){if(h.hasOwnProperty(a)){var b=h[a];for(var c in b)b.hasOwnProperty(c)&&(k[c]=b[c])}},this.removeExtension=function(a){d.helper.isArray(a)||(a=[a]);for(var b=0;b<a.length;++b){for(var c=a[b],e=0;e<l.length;++e)l[e]===c&&l[e].splice(e,1);for(var f=0;f<m.length;++e)m[f]===c&&m[f].splice(e,1)}},this.getAllExtensions=function(){return{language:l,output:m}}},d.subParser("anchors",function(a,b,c){"use strict";a=c.converter._dispatch("anchors.before",a,b);var e=function(a,b,e,f,g,h,i,j){d.helper.isUndefined(j)&&(j=""),a=b;var k=e,l=f.toLowerCase(),m=g,n=j;if(!m)if(l||(l=k.toLowerCase().replace(/ ?\n/g," ")),m="#"+l,d.helper.isUndefined(c.gUrls[l])){if(!(a.search(/\(\s*\)$/m)>-1))return a;m=""}else m=c.gUrls[l],d.helper.isUndefined(c.gTitles[l])||(n=c.gTitles[l]);m=d.helper.escapeCharacters(m,"*_",!1);var o='<a href="'+m+'"';return""!==n&&null!==n&&(n=n.replace(/"/g,"&quot;"),n=d.helper.escapeCharacters(n,"*_",!1),o+=' title="'+n+'"'),o+=">"+k+"</a>"};return a=a.replace(/(\[((?:\[[^\]]*]|[^\[\]])*)][ ]?(?:\n[ ]*)?\[(.*?)])()()()()/g,e),a=a.replace(/(\[((?:\[[^\]]*]|[^\[\]])*)]\([ \t]*()<?(.*?(?:\(.*?\).*?)?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g,e),a=a.replace(/(\[([^\[\]]+)])()()()()()/g,e),a=c.converter._dispatch("anchors.after",a,b)}),d.subParser("autoLinks",function(a,b,c){"use strict";function e(a,b){var c=d.subParser("unescapeSpecialChars")(b);return d.subParser("encodeEmailAddress")(c)}a=c.converter._dispatch("autoLinks.before",a,b);var f=/\b(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+)(?=\s|$)(?!["<>])/gi,g=/<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)>/gi,h=/(?:^|[ \n\t])([A-Za-z0-9!#$%&'*+-/=?^_`\{|}~\.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?:$|[ \n\t])/gi,i=/<(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi;return a=a.replace(g,'<a href="$1">$1</a>'),a=a.replace(i,e),b.simplifiedAutoLink&&(a=a.replace(f,'<a href="$1">$1</a>'),a=a.replace(h,e)),a=c.converter._dispatch("autoLinks.after",a,b)}),d.subParser("blockGamut",function(a,b,c){"use strict";a=c.converter._dispatch("blockGamut.before",a,b),a=d.subParser("blockQuotes")(a,b,c),a=d.subParser("headers")(a,b,c);var e=d.subParser("hashBlock")("<hr />",b,c);return a=a.replace(/^[ ]{0,2}([ ]?\*[ ]?){3,}[ \t]*$/gm,e),a=a.replace(/^[ ]{0,2}([ ]?\-[ ]?){3,}[ \t]*$/gm,e),a=a.replace(/^[ ]{0,2}([ ]?_[ ]?){3,}[ \t]*$/gm,e),a=d.subParser("lists")(a,b,c),a=d.subParser("codeBlocks")(a,b,c),a=d.subParser("tables")(a,b,c),a=d.subParser("hashHTMLBlocks")(a,b,c),a=d.subParser("paragraphs")(a,b,c),a=c.converter._dispatch("blockGamut.after",a,b)}),d.subParser("blockQuotes",function(a,b,c){"use strict";return a=c.converter._dispatch("blockQuotes.before",a,b),a=a.replace(/((^[ \t]{0,3}>[ \t]?.+\n(.+\n)*\n*)+)/gm,function(a,e){var f=e;return f=f.replace(/^[ \t]*>[ \t]?/gm,"~0"),f=f.replace(/~0/g,""),f=f.replace(/^[ \t]+$/gm,""),f=d.subParser("githubCodeBlocks")(f,b,c),f=d.subParser("blockGamut")(f,b,c),f=f.replace(/(^|\n)/g,"$1  "),f=f.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm,function(a,b){var c=b;return c=c.replace(/^  /gm,"~0"),c=c.replace(/~0/g,"")}),d.subParser("hashBlock")("<blockquote>\n"+f+"\n</blockquote>",b,c)}),a=c.converter._dispatch("blockQuotes.after",a,b)}),d.subParser("codeBlocks",function(a,b,c){"use strict";a=c.converter._dispatch("codeBlocks.before",a,b),a+="~0";var e=/(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=~0))/g;return a=a.replace(e,function(a,e,f){var g=e,h=f,i="\n";return g=d.subParser("outdent")(g),g=d.subParser("encodeCode")(g),g=d.subParser("detab")(g),g=g.replace(/^\n+/g,""),g=g.replace(/\n+$/g,""),b.omitExtraWLInCodeBlocks&&(i=""),g="<pre><code>"+g+i+"</code></pre>",d.subParser("hashBlock")(g,b,c)+h}),a=a.replace(/~0/,""),a=c.converter._dispatch("codeBlocks.after",a,b)}),d.subParser("codeSpans",function(a,b,c){"use strict";return a=c.converter._dispatch("codeSpans.before",a,b),a=a.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,function(a,b,c,e){var f=e;return f=f.replace(/^([ \t]*)/g,""),f=f.replace(/[ \t]*$/g,""),f=d.subParser("encodeCode")(f),b+"<code>"+f+"</code>"}),a=c.converter._dispatch("codeSpans.after",a,b)}),d.subParser("detab",function(a){"use strict";return a=a.replace(/\t(?=\t)/g,"    "),a=a.replace(/\t/g,"~A~B"),a=a.replace(/~B(.+?)~A/g,function(a,b){for(var c=b,d=4-c.length%4,e=0;d>e;e++)c+=" ";return c}),a=a.replace(/~A/g,"    "),a=a.replace(/~B/g,"")}),d.subParser("encodeAmpsAndAngles",function(a){"use strict";return a=a.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g,"&amp;"),a=a.replace(/<(?![a-z\/?\$!])/gi,"&lt;")}),d.subParser("encodeBackslashEscapes",function(a){"use strict";return a=a.replace(/\\(\\)/g,d.helper.escapeCharactersCallback),a=a.replace(/\\([`*_{}\[\]()>#+-.!])/g,d.helper.escapeCharactersCallback)}),d.subParser("encodeCode",function(a){"use strict";return a=a.replace(/&/g,"&amp;"),a=a.replace(/</g,"&lt;"),a=a.replace(/>/g,"&gt;"),a=d.helper.escapeCharacters(a,"*_{}[]\\",!1)}),d.subParser("encodeEmailAddress",function(a){"use strict";var b=[function(a){return"&#"+a.charCodeAt(0)+";"},function(a){return"&#x"+a.charCodeAt(0).toString(16)+";"},function(a){return a}];return a="mailto:"+a,a=a.replace(/./g,function(a){if("@"===a)a=b[Math.floor(2*Math.random())](a);else if(":"!==a){var c=Math.random();a=c>.9?b[2](a):c>.45?b[1](a):b[0](a)}return a}),a='<a href="'+a+'">'+a+"</a>",a=a.replace(/">.+:/g,'">')}),d.subParser("escapeSpecialCharsWithinTagAttributes",function(a){"use strict";var b=/(<[a-z\/!$]("[^"]*"|'[^']*'|[^'">])*>|<!(--.*?--\s*)+>)/gi;return a=a.replace(b,function(a){var b=a.replace(/(.)<\/?code>(?=.)/g,"$1`");return b=d.helper.escapeCharacters(b,"\\`*_",!1)})}),d.subParser("githubCodeBlocks",function(a,b,c){"use strict";return b.ghCodeBlocks?(a=c.converter._dispatch("githubCodeBlocks.before",a,b),a+="~0",a=a.replace(/(?:^|\n)```(.*)\n([\s\S]*?)\n```/g,function(a,e,f){var g=b.omitExtraWLInCodeBlocks?"":"\n";return f=d.subParser("encodeCode")(f),f=d.subParser("detab")(f),f=f.replace(/^\n+/g,""),f=f.replace(/\n+$/g,""),f="<pre><code"+(e?' class="'+e+" language-"+e+'"':"")+">"+f+g+"</code></pre>",d.subParser("hashBlock")(f,b,c)}),a=a.replace(/~0/,""),a=c.converter._dispatch("githubCodeBlocks.after",a,b)):a}),d.subParser("hashBlock",function(a,b,c){"use strict";return a=a.replace(/(^\n+|\n+$)/g,""),"\n\n~K"+(c.gHtmlBlocks.push(a)-1)+"K\n\n"}),d.subParser("hashElement",function(a,b,c){"use strict";return function(a,b){var d=b;return d=d.replace(/\n\n/g,"\n"),d=d.replace(/^\n/,""),d=d.replace(/\n+$/g,""),d="\n\n~K"+(c.gHtmlBlocks.push(d)-1)+"K\n\n"}}),d.subParser("hashHTMLBlocks",function(a,b,c){"use strict";return a=a.replace(/\n/g,"\n\n"),a=a.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\b[^\r]*?\n<\/\2>[ \t]*(?=\n+))/gm,d.subParser("hashElement")(a,b,c)),a=a.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside|address|audio|canvas|figure|hgroup|output|video)\b[^\r]*?<\/\2>[ \t]*(?=\n+)\n)/gm,d.subParser("hashElement")(a,b,c)),a=a.replace(/(\n[ ]{0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,d.subParser("hashElement")(a,b,c)),a=a.replace(/(\n\n[ ]{0,3}<!(--[^\r]*?--\s*)+>[ \t]*(?=\n{2,}))/g,d.subParser("hashElement")(a,b,c)),a=a.replace(/(?:\n\n)([ ]{0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,d.subParser("hashElement")(a,b,c)),a=a.replace(/\n\n/g,"\n")}),d.subParser("hashHTMLSpans",function(a,b,c){"use strict";for(var e=d.helper.matchRecursiveRegExp(a,"<code\\b[^>]*>","</code>","gi"),f=0;f<e.length;++f)a=a.replace(e[f][0],"~L"+(c.gHtmlSpans.push(e[f][0])-1)+"L");return a}),d.subParser("unhashHTMLSpans",function(a,b,c){"use strict";for(var d=0;d<c.gHtmlSpans.length;++d)a=a.replace("~L"+d+"L",c.gHtmlSpans[d]);return a}),d.subParser("headers",function(a,b,c){"use strict";function e(a){var b,e=a.replace(/[^\w]/g,"").toLowerCase();return c.hashLinkCounts[e]?b=e+"-"+c.hashLinkCounts[e]++:(b=e,c.hashLinkCounts[e]=1),f===!0&&(f="section"),d.helper.isString(f)?f+b:b}a=c.converter._dispatch("headers.before",a,b);var f=b.prefixHeaderId,g=isNaN(parseInt(b.headerLevelStart))?1:parseInt(b.headerLevelStart),h=b.smoothLivePreview?/^(.+)[ \t]*\n={2,}[ \t]*\n+/gm:/^(.+)[ \t]*\n=+[ \t]*\n+/gm,i=b.smoothLivePreview?/^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm:/^(.+)[ \t]*\n-+[ \t]*\n+/gm;return a=a.replace(h,function(a,f){var h=d.subParser("spanGamut")(f,b,c),i=b.noHeaderId?"":' id="'+e(f)+'"',j=g,k="<h"+j+i+">"+h+"</h"+j+">";return d.subParser("hashBlock")(k,b,c)}),a=a.replace(i,function(a,f){var h=d.subParser("spanGamut")(f,b,c),i=b.noHeaderId?"":' id="'+e(f)+'"',j=g+1,k="<h"+j+i+">"+h+"</h"+j+">";return d.subParser("hashBlock")(k,b,c)}),a=a.replace(/^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm,function(a,f,h){var i=d.subParser("spanGamut")(h,b,c),j=b.noHeaderId?"":' id="'+e(h)+'"',k=g-1+f.length,l="<h"+k+j+">"+i+"</h"+k+">";return d.subParser("hashBlock")(l,b,c)}),a=c.converter._dispatch("headers.after",a,b)}),d.subParser("images",function(a,b,c){"use strict";function e(a,b,e,f,g,h,i,j){var k=c.gUrls,l=c.gTitles,m=c.gDimensions;if(e=e.toLowerCase(),j||(j=""),""===f||null===f){if((""===e||null===e)&&(e=b.toLowerCase().replace(/ ?\n/g," ")),f="#"+e,d.helper.isUndefined(k[e]))return a;f=k[e],d.helper.isUndefined(l[e])||(j=l[e]),d.helper.isUndefined(m[e])||(g=m[e].width,h=m[e].height)}b=b.replace(/"/g,"&quot;"),b=d.helper.escapeCharacters(b,"*_",!1),f=d.helper.escapeCharacters(f,"*_",!1);var n='<img src="'+f+'" alt="'+b+'"';return j&&(j=j.replace(/"/g,"&quot;"),j=d.helper.escapeCharacters(j,"*_",!1),n+=' title="'+j+'"'),g&&h&&(g="*"===g?"auto":g,h="*"===h?"auto":h,n+=' width="'+g+'"',n+=' height="'+h+'"'),n+=" />"}a=c.converter._dispatch("images.before",a,b);var f=/!\[(.*?)]\s?\([ \t]*()<?(\S+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(['"])(.*?)\6[ \t]*)?\)/g,g=/!\[(.*?)][ ]?(?:\n[ ]*)?\[(.*?)]()()()()()/g;return a=a.replace(g,e),a=a.replace(f,e),a=c.converter._dispatch("images.after",a,b)}),d.subParser("italicsAndBold",function(a,b,c){"use strict";return a=c.converter._dispatch("italicsAndBold.before",a,b),b.literalMidWordUnderscores?(a=a.replace(/(^|\s|>|\b)__(?=\S)([^]+?)__(?=\b|<|\s|$)/gm,"$1<strong>$2</strong>"),a=a.replace(/(^|\s|>|\b)_(?=\S)([^]+?)_(?=\b|<|\s|$)/gm,"$1<em>$2</em>"),a=a.replace(/(\*\*)(?=\S)([^\r]*?\S[*]*)\1/g,"<strong>$2</strong>"),a=a.replace(/(\*)(?=\S)([^\r]*?\S)\1/g,"<em>$2</em>")):(a=a.replace(/(\*\*|__)(?=\S)([^\r]*?\S[*_]*)\1/g,"<strong>$2</strong>"),a=a.replace(/(\*|_)(?=\S)([^\r]*?\S)\1/g,"<em>$2</em>")),a=c.converter._dispatch("italicsAndBold.after",a,b)}),d.subParser("lists",function(a,b,c){"use strict";function e(a,e){c.gListLevel++,a=a.replace(/\n{2,}$/,"\n"),a+="~0";var f=/(\n)?(^[ \t]*)([*+-]|\d+[.])[ \t]+((\[(x| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(~0|\2([*+-]|\d+[.])[ \t]+))/gm,g=/\n[ \t]*\n(?!~0)/.test(a);return a=a.replace(f,function(a,e,f,h,i,j,k){k=k&&""!==k.trim();var l=d.subParser("outdent")(i,b,c),m="";return j&&b.tasklists&&(m=' class="task-list-item" style="list-style-type: none;"',l=l.replace(/^[ \t]*\[(x| )?]/m,function(){var a='<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';return k&&(a+=" checked"),a+=">"})),e||l.search(/\n{2,}/)>-1?(l=d.subParser("githubCodeBlocks")(l,b,c),l=d.subParser("blockGamut")(l,b,c)):(l=d.subParser("lists")(l,b,c),l=l.replace(/\n$/,""),l=g?d.subParser("paragraphs")(l,b,c):d.subParser("spanGamut")(l,b,c)),l="\n<li"+m+">"+l+"</li>\n"}),a=a.replace(/~0/g,""),c.gListLevel--,e&&(a=a.replace(/\s+$/,"")),a}function f(a,b,c){var d="ul"===b?/^ {0,2}\d+\.[ \t]/gm:/^ {0,2}[*+-][ \t]/gm,f=[],g="";if(-1!==a.search(d)){!function i(a){var f=a.search(d);-1!==f?(g+="\n\n<"+b+">"+e(a.slice(0,f),!!c)+"</"+b+">\n\n",b="ul"===b?"ol":"ul",d="ul"===b?/^ {0,2}\d+\.[ \t]/gm:/^ {0,2}[*+-][ \t]/gm,i(a.slice(f))):g+="\n\n<"+b+">"+e(a,!!c)+"</"+b+">\n\n"}(a);for(var h=0;h<f.length;++h);}else g="\n\n<"+b+">"+e(a,!!c)+"</"+b+">\n\n";return g}a=c.converter._dispatch("lists.before",a,b),a+="~0";var g=/^(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm;return c.gListLevel?a=a.replace(g,function(a,b,c){var d=c.search(/[*+-]/g)>-1?"ul":"ol";return f(b,d,!0)}):(g=/(\n\n|^\n?)(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,a=a.replace(g,function(a,b,c,d){var e=d.search(/[*+-]/g)>-1?"ul":"ol";return f(c,e)})),a=a.replace(/~0/,""),a=c.converter._dispatch("lists.after",a,b)}),d.subParser("outdent",function(a){"use strict";return a=a.replace(/^(\t|[ ]{1,4})/gm,"~0"),a=a.replace(/~0/g,"")}),d.subParser("paragraphs",function(a,b,c){"use strict";a=c.converter._dispatch("paragraphs.before",a,b),a=a.replace(/^\n+/g,""),a=a.replace(/\n+$/g,"");for(var e=a.split(/\n{2,}/g),f=[],g=e.length,h=0;g>h;h++){var i=e[h];i.search(/~K(\d+)K/g)>=0?f.push(i):i.search(/\S/)>=0&&(i=d.subParser("spanGamut")(i,b,c),i=i.replace(/^([ \t]*)/g,"<p>"),i+="</p>",f.push(i))}for(g=f.length,h=0;g>h;h++)for(;f[h].search(/~K(\d+)K/)>=0;){var j=c.gHtmlBlocks[RegExp.$1];j=j.replace(/\$/g,"$"),f[h]=f[h].replace(/~K\d+K/,j)}return a=c.converter._dispatch("paragraphs.after",a,b),f.join("\n\n")}),d.subParser("runExtension",function(a,b,c,d){"use strict";if(a.filter)b=a.filter(b,d.converter,c);else if(a.regex){var e=a.regex;!e instanceof RegExp&&(e=new RegExp(e,"g")),b=b.replace(e,a.replace)}return b}),d.subParser("spanGamut",function(a,b,c){"use strict";return a=c.converter._dispatch("spanGamut.before",a,b),a=d.subParser("codeSpans")(a,b,c),a=d.subParser("escapeSpecialCharsWithinTagAttributes")(a,b,c),a=d.subParser("encodeBackslashEscapes")(a,b,c),a=d.subParser("images")(a,b,c),a=d.subParser("anchors")(a,b,c),a=d.subParser("autoLinks")(a,b,c),a=d.subParser("encodeAmpsAndAngles")(a,b,c),a=d.subParser("italicsAndBold")(a,b,c),a=d.subParser("strikethrough")(a,b,c),a=a.replace(/  +\n/g," <br />\n"),a=c.converter._dispatch("spanGamut.after",a,b)}),d.subParser("strikethrough",function(a,b,c){"use strict";return b.strikethrough&&(a=c.converter._dispatch("strikethrough.before",a,b),a=a.replace(/(?:~T){2}([^~]+)(?:~T){2}/g,"<del>$1</del>"),a=c.converter._dispatch("strikethrough.after",a,b)),a}),d.subParser("stripBlankLines",function(a){"use strict";return a.replace(/^[ \t]+$/gm,"")}),d.subParser("stripLinkDefinitions",function(a,b,c){"use strict";var e=/^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(\S+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=~0))/gm;return a+="~0",a=a.replace(e,function(a,e,f,g,h,i,j){return e=e.toLowerCase(),c.gUrls[e]=d.subParser("encodeAmpsAndAngles")(f),i?i+j:(j&&(c.gTitles[e]=j.replace(/"|'/g,"&quot;")),b.parseImgDimensions&&g&&h&&(c.gDimensions[e]={width:g,height:h}),"")}),a=a.replace(/~0/,"")}),d.subParser("tables",function(a,b,c){"use strict";var e=function(){var a,e={};return e.th=function(a,e){var f="";return a=a.trim(),""===a?"":(b.tableHeaderId&&(f=' id="'+a.replace(/ /g,"_").toLowerCase()+'"'),a=d.subParser("spanGamut")(a,b,c),e=e&&""!==e.trim()?' style="'+e+'"':"","<th"+f+e+">"+a+"</th>")},e.td=function(a,e){var f=d.subParser("spanGamut")(a.trim(),b,c);return e=e&&""!==e.trim()?' style="'+e+'"':"","<td"+e+">"+f+"</td>"},e.ths=function(){var a="",b=0,c=[].slice.apply(arguments[0]),d=[].slice.apply(arguments[1]);for(b;b<c.length;b+=1)a+=e.th(c[b],d[b])+"\n";return a},e.tds=function(){var a="",b=0,c=[].slice.apply(arguments[0]),d=[].slice.apply(arguments[1]);for(b;b<c.length;b+=1)a+=e.td(c[b],d[b])+"\n";return a},e.thead=function(){var a,b=[].slice.apply(arguments[0]),c=[].slice.apply(arguments[1]);return a="<thead>\n",a+="<tr>\n",a+=e.ths.apply(this,[b,c]),a+="</tr>\n",a+="</thead>\n"},e.tr=function(){var a,b=[].slice.apply(arguments[0]),c=[].slice.apply(arguments[1]);return a="<tr>\n",a+=e.tds.apply(this,[b,c]),a+="</tr>\n"},a=function(a){var b,c,d=0,f=a.split("\n"),g=[];for(d;d<f.length;d+=1){if(b=f[d],b.trim().match(/^[|].*[|]$/)){b=b.trim();var h=[],i=f[d+1].trim(),j=[],k=0;if(i.match(/^[|][-=|: ]+[|]$/))for(j=i.substring(1,i.length-1).split("|"),k=0;k<j.length;++k)j[k]=j[k].trim(),j[k].match(/^[:][-=| ]+[:]$/)?j[k]="text-align:center;":j[k].match(/^[-=| ]+[:]$/)?j[k]="text-align:right;":j[k].match(/^[:][-=| ]+$/)?j[k]="text-align:left;":j[k]="";if(h.push("<table>"),c=b.substring(1,b.length-1).split("|"),0===j.length)for(k=0;k<c.length;++k)j.push("text-align:left");if(h.push(e.thead.apply(this,[c,j])),b=f[++d],b.trim().match(/^[|][-=|: ]+[|]$/)){for(b=f[++d],h.push("<tbody>");b.trim().match(/^[|].*[|]$/);)b=b.trim(),h.push(e.tr.apply(this,[b.substring(1,b.length-1).split("|"),j])),b=f[++d];h.push("</tbody>"),h.push("</table>"),g.push(h.join("\n"));continue}b=f[--d]}g.push(b)}return g.join("\n")},{parse:a}};if(b.tables){a=c.converter._dispatch("tables.before",a,b);var f=e();a=f.parse(a),a=c.converter._dispatch("tables.after",a,b)}return a}),d.subParser("unescapeSpecialChars",function(a){"use strict";return a=a.replace(/~E(\d+)E/g,function(a,b){var c=parseInt(b);return String.fromCharCode(c)})});var i=this;"undefined"!=typeof module&&module.exports?module.exports=d:"function"==typeof define&&define.amd?define("showdown",function(){"use strict";return d}):i.showdown=d}).call(this);
//# sourceMappingURL=showdown.min.js.map

}
GlobalContext.setModule("component/showdown.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/stringExpander.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var reg;

  reg = /{{([a-zA-Z0-9]+)(:[^}]*)?}}/g;

  exports.expandString = function(string, actions) {
    reg.lastIndex = 0;
    return string.replace(reg, function(match, name, content) {
      content = (content != null ? content.slice(1) : void 0) || null;
      if (typeof actions[name] === "function") {
        return actions[name](content);
      } else if (typeof actions[name] === "undefined") {
        return match[0];
      } else {
        return actions[name];
      }
    });
  };

}).call(this);

}
GlobalContext.setModule("component/stringExpander.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/textWidth.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = function(el) {
    var ref, style, text, textNode, width;
    if ((ref = el.tagName) === "INPUT" || ref === "TEXTAREA") {
      text = el.value;
    } else {
      text = el.textContent;
    }
    if (!this.fakeEl) {
      this.fakeEl = document.createElement("span");
    }
    textNode = document.createTextNode(text);
    this.fakeEl.innerHTML = "";
    this.fakeEl.appendChild(textNode);
    style = window.getComputedStyle(el);
    this.fakeEl.style.display = "inline-block";
    this.fakeEl.style.position = "absolute";
    this.fakeEl.style.font = style.font;
    document.body.appendChild(this.fakeEl);
    width = this.fakeEl.offsetWidth;
    this.fakeEl.parentElement.removeChild(this.fakeEl);
    return width;
  };

}).call(this);

}
GlobalContext.setModule("component/textWidth.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/validator.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = {
    isEmail: function(email) {
      var re;
      re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      return re.test(email);
    }
  };

}).call(this);

}
GlobalContext.setModule("component/validator.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/valueSaver.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var ValueSaver,
    slice = [].slice;

  ValueSaver = (function() {
    function ValueSaver() {
      var objects;
      objects = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.watches = objects.map(function(object) {
        return {
          target: object,
          saves: []
        };
      });
    }

    ValueSaver.prototype.reset = function() {
      var i, item, len, ref, results;
      ref = this.watches;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(item.saves = []);
      }
      return results;
    };

    ValueSaver.prototype.save = function(name, forceValue) {
      var i, item, j, len, len1, ref, ref1, results, save, target;
      ref = this.watches;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        target = null;
        ref1 = item.saves;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          save = ref1[j];
          if (save.name === name) {
            target = save;
            break;
          }
        }
        if (!target) {
          target = {
            name: name
          };
          item.saves.push(target);
        }
        if (typeof forceValue !== "undefined") {
          results.push(target.value = forceValue);
        } else {
          results.push(target.value = item.target[name]);
        }
      }
      return results;
    };

    ValueSaver.prototype.restore = function(name) {
      var i, item, len, ref, results, save;
      ref = this.watches;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push((function() {
          var j, len1, ref1, results1;
          ref1 = item.saves;
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            save = ref1[j];
            if (save.name === name || !name) {
              results1.push(item.target[save.name] = save.value);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    };

    return ValueSaver;

  })();

  module.exports = ValueSaver;

}).call(this);

}
GlobalContext.setModule("component/valueSaver.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"component/vibration.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = {
    vibrate: function(value) {
      var ref;
      return (ref = window.navigator) != null ? typeof ref.vibrate === "function" ? ref.vibrate(value) : void 0 : void 0;
    },
    feedback: function(value) {
      return this.vibrate(15);
    }
  };

}).call(this);

}
GlobalContext.setModule("component/vibration.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/editor.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Buffer, BufferManager, COMComposer, COMContext, COMDecoration, COMElement, COMNamespace, COMNode, COMRichText, COMSpell, CancelStack, Caret, Clipboard, CommandManager, ContextManager, DOMSelection, Debugger, DocumentFocus, DragManager, DropManager, Editor, HotkeyManager, InputMethod, NextRenderAware, Platform, PluginManager, SharedCallbacks,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  COMContext = require("./com/context");

  COMRichText = require("./com/richText");

  COMNamespace = require("./com/namespace");

  COMDecoration = require("./com/decoration");

  COMSpell = require("./com/spell");

  COMElement = require("./com/element");

  COMNode = require("./com/node");

  COMComposer = require("./com/composer");

  Caret = require("./facility/caret");

  InputMethod = require("./facility/inputMethod");

  HotkeyManager = require("./facility/hotkeyManager");

  CommandManager = require("./facility/commandManager");

  Clipboard = require("./facility/clipboard");

  PluginManager = require("./facility/pluginManager");

  Buffer = require("./facility/buffer");

  DropManager = require("./facility/dropManager");

  BufferManager = Buffer.BufferManager;

  Debugger = require("./facility/debugger");

  Platform = require("./facility/platform");

  ContextManager = require("./facility/contextManager");

  DocumentFocus = require("./facility/documentFocus");

  DOMSelection = require("./facility/selection");

  CancelStack = require("./facility/cancelStack");

  DragManager = require("./facility/dragManager");

  SharedCallbacks = require("/component/sharedCallbacks");

  Editor = (function(superClass) {
    extend(Editor, superClass);

    Editor.packs = [];

    Editor.prototype.COM = require("./com/index");

    function Editor(el) {
      this.asUser = bind(this.asUser, this);
      var Key, index;
      Editor.__super__.constructor.call(this, el);
      new NextRenderAware(this);
      this.namespace = COMContext.namespace;
      if (this["debugger"] == null) {
        this["debugger"] = new Debugger(this);
      }
      this.platform = Platform.create();
      this.contextManager = new ContextManager(this);
      this.contextManager.listenBy(this, "context/create", (function(_this) {
        return function(context) {
          return context.facilities.editor = _this;
        };
      })(this));
      this.bufferManager = new BufferManager(this);
      this.__defineGetter__("buffer", (function(_this) {
        return function() {
          return _this.bufferManager.currentFocus;
        };
      })(this));
      this.__defineGetter__("context", (function(_this) {
        return function() {
          var ref;
          return (ref = _this.bufferManager.currentFocus) != null ? ref.context : void 0;
        };
      })(this));
      this.__defineGetter__("selectSession", (function(_this) {
        return function() {
          var ref;
          return (ref = _this.bufferManager.currentFocus) != null ? ref.selectSession : void 0;
        };
      })(this));
      this.clipboard = new Clipboard(this);
      this.domSelection = new DOMSelection(this);
      if (this.inputMethod == null) {
        this.inputMethod = new InputMethod(this);
      }
      this.dragManager = new DragManager(this);
      if (this.caret == null) {
        this.caret = new Caret(this);
      }
      this.bufferManager.listenBy(this, "focus", (function(_this) {
        return function(buffer) {
          Buffer = require("./facility/buffer");
          if (buffer instanceof Buffer.RichBuffer) {
            return _this.caret.attachTo(buffer);
          }
        };
      })(this));
      this.initHeight = $(window).height();
      this.caret.init();
      this.inputMethod.init();
      if (this.hotkeys == null) {
        this.hotkeys = new HotkeyManager(this);
      }
      if (this.commands == null) {
        this.commands = new CommandManager(this);
      }
      if (this.plugins == null) {
        this.plugins = new PluginManager(this);
      }
      if (this.dropManager == null) {
        this.dropManager = new DropManager(this);
      }
      if (this.cancelStack == null) {
        this.cancelStack = new CancelStack(this);
      }
      this.inputMethod.on("input", (function(_this) {
        return function(input) {
          var ref;
          if ((ref = _this.buffer) != null ? ref.lockUserInput : void 0) {
            return;
          }
          if (_this.focus.level !== "all") {
            return;
          }
          _this.userIsWriting = true;
          _this.conduct("write", input);
          return _this.userIsWriting = false;
        };
      })(this));
      index = 0;
      Key = Leaf.Key;
      this.inputMethod.on("key", (function(_this) {
        return function(event) {
          var locked, ref, ref1, ref2, ref3, ref4, ref5, ref6;
          locked = _this.lockUserInput || ((ref = _this.buffer) != null ? ref.lockUserInput : void 0);
          _this.hotkeys.handleKeyEvent(event);
          if (event.altKey && !event.ctrlKey && event.code !== Leaf.Key.d) {
            event.capture();
          }
          if (!event.defaultPrevented && !window.hasCommandKey && _this.buffer && event.keyDown && ((ref1 = _this.buffer) != null ? (ref2 = ref1.selection) != null ? ref2.isActive : void 0 : void 0) && !((ref3 = _this.buffer.selection) != null ? typeof ref3.isCollapsed === "function" ? ref3.isCollapsed() : void 0 : void 0) && !event.isModified() && _this.focus.level === "buffer") {
            if (event.canOutput()) {
              event.capture();
              if (!locked) {
                _this.userIsWriting = true;
                _this.conduct("delete-selection");
                _this.conduct("write", event.getInputText());
                _this.userIsWriting = false;
                return;
              }
            }
          }
          if (((ref4 = event.code) === Leaf.Key.backspace) && ((ref5 = (ref6 = document.activeElement) != null ? ref6.tagName : void 0) !== "TEXTAREA" && ref5 !== "INPUT")) {
            event.raw.preventDefault();
            event.raw.stopImmediatePropagation();
          }
          if (event.altKey && event.code !== Leaf.Key.d) {
            return event.raw.preventDefault();
          }
        };
      })(this));
      this.focus = new DocumentFocus.FocusManager(this);
      if (typeof this.registerPlugin === "function") {
        this.registerPlugin();
      }
    }

    Editor.prototype.asUser = function(fn) {
      var e, error, userIsWriting;
      userIsWriting = this.userIsWriting;
      this.userIsWriting = true;
      try {
        fn();
      } catch (error) {
        e = error;
        Logger.error("Error during Editor.asUser", e);
      }
      return this.userIsWriting = userIsWriting;
    };

    Editor.prototype.getAllPlugins = function() {
      return this.plugins.plugins;
    };

    Editor.prototype.init = function() {
      this.setup();
      this.activate();
      this.focus.allowAll();
      this.emit("ready");
      return this.platform.emitEmbedEvent("ready");
    };

    Editor.prototype.setup = function() {
      this.caret.show();
      return this.plugins.init();
    };

    Editor.prototype.conduct = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (args[0] === "write") {
        this.emit("write", args[1]);
      }
      return (ref = this.commands).conduct.apply(ref, args);
    };

    Editor.prototype.announce = function() {
      var args, name;
      name = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return this.emit.apply(this, ["announcement/" + name].concat(slice.call(args)));
    };

    Editor.prototype.activate = function() {
      if (this.isActive) {
        return false;
      }
      this.isActive = true;
      this.inputMethod.activate();
      this.caret.activate();
      this.renderFrame();
      return true;
    };

    Editor.prototype.deactivate = function() {
      if (!this.isActive) {
        return false;
      }
      this.isActive = false;
      clearTimeout(this.timer);
      cancelAnimationFrame(this.timer);
      this.inputMethod.deactivate();
      this.caret.deactivate();
      return true;
    };

    Editor.prototype.plugin = function(name) {
      return this.plugins.plugins[name];
    };

    Editor.prototype.render = function() {
      this.emit("beforeRender");
      this.bufferManager.render();
      if (document.body.scrollTop !== 0) {
        if (!this.lastScrollTop) {
          this.lastScrollTop = document.body.scrollTop;
        } else if (this.lastScrollTop === document.body.scrollTop) {
          document.body.scrollTop = 0;
        }
      }
      if (this.caret.isShow) {
        this.caret.update();
      }
      return this.emit("afterRender");
    };

    Editor.prototype.renderFrame = function() {
      this.render();
      return this.timer = this.nextRenderFrame((function(_this) {
        return function() {
          return _this.renderFrame();
        };
      })(this));
    };

    Editor.prototype.nextRenderFrame = function(frame) {
      return window.requestAnimationFrame(frame);
    };

    Editor.prototype.addComponent = function() {
      var Cons, i, item, len, results;
      Cons = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (i = 0, len = Cons.length; i < len; i++) {
        item = Cons[i];
        if (item.prototype instanceof COMDecoration.DecorationMaintainer) {
          results.push(this.namespace.registerDecoration(new item));
        } else if (item instanceof COMDecoration.DecorationMaintainer) {
          results.push(this.namespace.registerDecoration(item));
        } else if (item.prototype instanceof COMSpell) {
          results.push(this.namespace.registerSpell(item));
        } else if (item.prototype instanceof COMNode) {
          results.push(this.namespace.registerNode(item));
        } else if (item instanceof COMComposer) {
          results.push(this.namespace.registerComposer(item));
        } else if (item.prototype instanceof COMComposer) {
          results.push(this.namespace.registerComposer(new item()));
        } else {
          results.push(Logger.error("unknown inline resource", item));
        }
      }
      return results;
    };

    Editor.prototype.addPackageStatic = function(pack) {
      var Command, Composer, Dec, Element, Intent, Rune, Spell, handler, i, j, k, key, l, len, len1, len2, len3, len4, len5, len6, len7, m, n, o, p, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, results;
      ref = pack.prototype.Commands || [];
      for (i = 0, len = ref.length; i < len; i++) {
        Command = ref[i];
        this.commands.register(Command);
      }
      ref1 = pack.prototype.Hotkeys || [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        ref2 = ref1[j], key = ref2[0], handler = ref2[1];
        this.hotkeys.registerCommandHotkey(key, handler);
      }
      ref3 = pack.prototype.Decorations || [];
      for (k = 0, len2 = ref3.length; k < len2; k++) {
        Dec = ref3[k];
        if (Dec instanceof COMDecoration.DecorationMaintainer) {
          this.namespace.registerDecoration(Dec);
        } else if (Dec.prototype instanceof COMDecoration.DecorationMaintainer) {
          this.namespace.registerDecoration(new Dec);
        } else {
          Logger.error("Invalid decoration", Dec, "at", pack);
        }
      }
      ref4 = pack.prototype.Runes || [];
      for (l = 0, len3 = ref4.length; l < len3; l++) {
        Rune = ref4[l];
        this.namespace.registerNode(Rune);
      }
      ref5 = pack.prototype.Spells || [];
      for (m = 0, len4 = ref5.length; m < len4; m++) {
        Spell = ref5[m];
        this.namespace.registerSpell(Spell);
      }
      ref6 = pack.prototype.Elements || [];
      for (n = 0, len5 = ref6.length; n < len5; n++) {
        Element = ref6[n];
        this.namespace.registerNode(Element);
      }
      ref7 = pack.prototype.Composers || [];
      for (o = 0, len6 = ref7.length; o < len6; o++) {
        Composer = ref7[o];
        if (Composer instanceof COM.COMComposer) {
          this.namespace.registerComposer(Composer);
        } else if (Composer.prototype instanceof COMComposer) {
          this.namespace.registerComposer(new Composer());
        } else {
          Logger.error("Invalid composer", Composer, "at", pack);
        }
      }
      ref8 = pack.prototype.Intents || [];
      results = [];
      for (p = 0, len7 = ref8.length; p < len7; p++) {
        Intent = ref8[p];
        results.push(COM.COMIntent.register(Intent, Intent.name || Intent.prototype.name));
      }
      return results;
    };

    return Editor;

  })(Leaf.Widget);

  NextRenderAware = (function(superClass) {
    extend(NextRenderAware, superClass);

    function NextRenderAware() {
      return NextRenderAware.__super__.constructor.apply(this, arguments);
    }

    NextRenderAware.prototype.nextRenderCallback = null;

    NextRenderAware.prototype.initialize = function() {
      this.nextRenderCallback = SharedCallbacks.create();
      return this.listenBy(NextRenderAware, "afterRender", (function(_this) {
        return function() {
          return _this.nextRenderCallback();
        };
      })(this));
    };

    NextRenderAware.prototype.nextRender = function(callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this.nextRenderCallback.push(callback);
    };

    return NextRenderAware;

  })(Leaf.Trait);

  module.exports = Editor;

}).call(this);

}
GlobalContext.setModule("vincent/editor.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/index.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = {
    Package: require("./package"),
    Caret: require("./facility/caret"),
    Buffer: require("./facility/buffer")
  };

}).call(this);

}
GlobalContext.setModule("vincent/index.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/pack.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMComposer, COMContext, COMElement, COMNamespace, COMNode, COMRichText, COMSpell, Decoration, Pack,
    slice = [].slice;

  COMRichText = require("./com/richText");

  Decoration = require("./com/decoration");

  COMSpell = require("./com/spell");

  COMElement = require("./com/element");

  COMNamespace = require("./com/namespace");

  COMNode = require("./com/node");

  COMContext = require("./com/context");

  COMComposer = require("./com/composer");

  Pack = (function() {
    function Pack() {
      var packs;
      packs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.decorations = [];
      this.spells = [];
      this.nodes = [];
      this.composers = [];
      this.add.apply(this, packs);
      this.cmds = [];
      this.hotkeys = [];
    }

    Pack.prototype.add = function() {
      var Cons, i, item, len, results;
      Cons = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (i = 0, len = Cons.length; i < len; i++) {
        item = Cons[i];
        if (item.prototype instanceof Decoration.DecorationMaintainer) {
          results.push(this.decorations.push(new item));
        } else if (item instanceof Decoration.DecorationMaintainer) {
          results.push(this.decorations.push(item));
        } else if (item.prototype instanceof COMSpell) {
          results.push(this.spells.push(item));
        } else if (item.prototype instanceof COMNode) {
          results.push(this.nodes.push(item));
        } else if (item instanceof COMComposer) {
          results.push(this.composers.push(item));
        } else if (item.prototype instanceof COMComposer) {
          results.push(this.composers.push(new item()));
        } else {
          results.push(Logger.error("unknown inline resource", item));
        }
      }
      return results;
    };

    Pack.prototype.registerCommand = function(cmd) {
      return this.cmds.push(cmd);
    };

    Pack.prototype.registerHotkey = function(keyString, handler) {
      return this.hotkeys.push({
        keyString: keyString,
        handler: handler
      });
    };

    Pack.prototype.applyTo = function(target) {
      var i, item, j, k, l, len, len1, len2, len3, ref, ref1, ref2, ref3, results;
      ref = this.nodes;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        target.registerNode(item);
      }
      ref1 = this.composers;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        item = ref1[j];
        target.registerComposer(item.type, item);
      }
      ref2 = this.spells;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        item = ref2[k];
        target.registerSpell(item);
      }
      ref3 = this.decorations;
      results = [];
      for (l = 0, len3 = ref3.length; l < len3; l++) {
        item = ref3[l];
        results.push(target.registerDecoration(item));
      }
      return results;
    };

    Pack.prototype.addConfig = function(config) {
      var Command, Composer, Element, Hotkey, Spell, i, j, k, l, len, len1, len2, len3, len4, len5, m, n, ref, ref1, ref2, ref3, ref4, ref5, results;
      ref = config.Commands;
      for (i = 0, len = ref.length; i < len; i++) {
        Command = ref[i];
        pack.registerCommand(Command);
      }
      ref1 = config.Hotkeys;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        Hotkey = ref1[j];
        pack.registerHotkey(Hotkey);
      }
      ref2 = config.Decorations;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        Decoration = ref2[k];
        pack.add(Decoration);
      }
      ref3 = config.Spells;
      for (l = 0, len3 = ref3.length; l < len3; l++) {
        Spell = ref3[l];
        pack.add(Spell);
      }
      ref4 = config.Elements;
      for (m = 0, len4 = ref4.length; m < len4; m++) {
        Element = ref4[m];
        pack.add(Element);
      }
      ref5 = config.Composers;
      results = [];
      for (n = 0, len5 = ref5.length; n < len5; n++) {
        Composer = ref5[n];
        results.push(pack.add(Composer));
      }
      return results;
    };

    return Pack;

  })();

  module.exports = Pack;

}).call(this);

}
GlobalContext.setModule("vincent/pack.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/package.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Package,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Package = (function(superClass) {
    extend(Package, superClass);

    function Package() {
      return Package.__super__.constructor.apply(this, arguments);
    }

    Package.prototype.name = "VoidPackage";

    Package.prototype.requires = [];

    Package.prototype.Commands = [];

    Package.prototype.Hotkeys = [];

    Package.prototype.Decorations = [];

    Package.prototype.Spells = [];

    Package.prototype.Runes = [];

    Package.prototype.Elements = [];

    Package.prototype.Composers = [];

    Package.prototype.Intents = [];

    Package.prototype.isInitialized = false;

    Package.prototype.onContextCreate = null;

    Package.prototype.onContextDestroy = null;

    Package.prototype.init = function(editor, deps) {
      this.editor = editor;
      this.deps = deps != null ? deps : {};
      this.isInitialized = true;
      if (typeof this.onContextCreate === "function") {
        this.editor.contextManager.listenBy(this, "context/create", (function(_this) {
          return function(c) {
            return _this.onContextCreate(c);
          };
        })(this));
      }
      if (typeof this.onContextDestroy === "function") {
        return this.editor.contextManager.listenBy(this, "context/destroy", (function(_this) {
          return function(c) {
            return _this.onContextDestroy(c);
          };
        })(this));
      }
    };

    return Package;

  })(Leaf.EventEmitter);

  module.exports = Package;

}).call(this);

}
GlobalContext.setModule("vincent/package.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/anchor.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMAnchor, EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = (require("./events")).EventEmitter;

  COMAnchor = (function(superClass) {
    extend(COMAnchor, superClass);

    function COMAnchor() {
      COMAnchor.__super__.constructor.call(this);
    }

    return COMAnchor;

  })(EventEmitter);

  module.exports = COMAnchor;

}).call(this);

}
GlobalContext.setModule("vincent/com/anchor.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/composePolicy.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMComposePolicy, COMPolicy,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMPolicy = require("./policy");

  COMComposePolicy = (function(superClass) {
    extend(COMComposePolicy, superClass);

    function COMComposePolicy(node) {
      this.node = node;
      COMComposePolicy.__super__.constructor.call(this, this.node);
    }

    COMComposePolicy.prototype.newlineSplitHead = false;

    COMComposePolicy.prototype.newlineSplitTail = false;

    COMComposePolicy.prototype.tailingNewline = false;

    COMComposePolicy.prototype.headingNewline = false;

    COMComposePolicy.prototype.borrows = false;

    COMComposePolicy.prototype.lend = false;

    return COMComposePolicy;

  })(COMPolicy);

  module.exports = COMComposePolicy;

}).call(this);

}
GlobalContext.setModule("vincent/com/composePolicy.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/composer.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMComposer;

  COMComposer = (function() {
    function COMComposer() {}

    COMComposer.prototype.type = "VoidComposer";

    COMComposer.prototype.compose = function(target) {
      var result;
      if (!target.root) {
        return false;
      }
      this.context = target.context;
      this.target = target;
      this.cache = target.composerBuffer;
      result = (typeof this.exec === "function" ? this.exec() : void 0) || false;
      return result;
    };

    return COMComposer;

  })();

  module.exports = COMComposer;

}).call(this);

}
GlobalContext.setModule("vincent/com/composer.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/container.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var AppendChildOperation, COMAnchor, COMContainer, COMNode, COMPath, EmptyOperation, Errors, InsertOperation, Operation, RemoveChildOperation,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice1 = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  COMNode = require("./node");

  COMPath = require("./path");

  Operation = require("./operation");

  COMAnchor = require("./anchor");

  Errors = require("./errors");

  COMContainer = (function(superClass) {
    extend(COMContainer, superClass);

    COMContainer.prototype.type = "Container";

    function COMContainer(context, option) {
      this.context = context;
      if (option == null) {
        option = {};
      }
      this.children = [];
      COMContainer.__super__.constructor.call(this, this.context, option);
      this.fromJSON(option);
      this.__defineGetter__("domContainer", (function(_this) {
        return function() {
          var ref;
          return ((ref = _this.cache) != null ? ref.domContainer : void 0) || null;
        };
      })(this));
      this.__defineSetter__("domContainer", (function(_this) {
        return function(domContainer) {
          if (domContainer != null) {
            domContainer.com = _this;
          }
          return _this.cache.domContainer = domContainer;
        };
      })(this));
    }

    COMContainer.prototype.onRootDispel = function() {
      var child, i, len, ref, results1;
      COMContainer.__super__.onRootDispel.call(this);
      ref = this.children;
      results1 = [];
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        results1.push(child.root = null);
      }
      return results1;
    };

    COMContainer.prototype.onRootAvailable = function() {
      var child, i, len, ref, results1;
      COMContainer.__super__.onRootAvailable.call(this);
      ref = this.children;
      results1 = [];
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        results1.push(child.root = this.root);
      }
      return results1;
    };

    COMContainer.prototype.setRenderContext = function(rc) {
      var child, i, len, ref, results1;
      if (rc === this.rc) {
        return;
      }
      COMContainer.__super__.setRenderContext.call(this, rc);
      ref = this.children;
      results1 = [];
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        results1.push(child.setRenderContext(rc));
      }
      return results1;
    };

    COMContainer.prototype.cacheIndex = function() {
      var i, index, item, len, ref;
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        item._containerIndex = index;
      }
      this._indexCached = true;
      return this._indexCached;
    };

    COMContainer.prototype.some = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return (ref = this.children).some.apply(ref, args);
    };

    COMContainer.prototype.every = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return (ref = this.children).every.apply(ref, args);
    };

    COMContainer.prototype.render = function(rc, option) {
      var child, extraAppearance, frag, i, item, j, k, l, len, len1, len2, len3, rearrange, recursive, ref, ref1, ref2, ref3, ref4, selfless;
      if (option == null) {
        option = {};
      }
      if (!this.dirty) {
        return;
      }
      recursive = option.recursive;
      selfless = option.selfless && this.el && this.el.children.length > 0;
      rearrange = !selfless || this.beforeMark("rearrange");
      if (rearrange) {
        COMContainer.__super__.render.call(this, rc, {
          force: true
        });
        this.specifyDomContainer();
        if (!this.domContainer) {
          this.domContainer = this.el;
        }
        frag = document.createDocumentFragment();
      } else {
        COMContainer.__super__.render.call(this, rc);
        this.specifyDomContainer();
        if (!this.domContainer) {
          this.domContainer = this.el;
        }
      }
      extraAppearance = [];
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        if (((ref1 = child.parentAppearance) != null ? ref1.length : void 0) > 0) {
          ref2 = child.parentAppearance;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            item = ref2[j];
            if (indexOf.call(extraAppearance, item) < 0) {
              extraAppearance.push(item);
            }
          }
        }
        if (recursive && (child.dirty || !child.el || option.force)) {
          child.render(rc, option);
          child.afterRender();
        }
        if (rearrange) {
          if (!child.el) {
            Logger.error(child, "has no el of", this, child.type, child._id, this.type, this._id);
          }
          if (child.elBefore) {
            frag.appendChild(child.elBefore);
          }
          frag.appendChild(child.el);
          if (child.elAfter) {
            frag.appendChild(child.elAfter);
          }
        }
      }
      ref4 = ((ref3 = this.cache) != null ? ref3.extraAppearance : void 0) || [];
      for (k = 0, len2 = ref4.length; k < len2; k++) {
        item = ref4[k];
        this.el.classList.remove(item);
      }
      for (l = 0, len3 = extraAppearance.length; l < len3; l++) {
        item = extraAppearance[l];
        this.el.classList.add(item);
      }
      this.cache.extraAppearance = extraAppearance;
      if (rearrange) {
        if (this.domContainer !== this.el) {
          this.domContainer.innerHTML = "";
        }
        return this.domContainer.appendChild(frag);
      }
    };

    COMContainer.prototype.specifyDomContainer = function() {
      this.domContainer = this.el;
    };

    COMContainer.prototype._attach = function(node) {
      if (node.parent) {
        throw new Errors.LogicError("can't attach a node to container that is not orphan");
      }
      node.parent = this;
      node.root = this.root;
      this.pend();
      this.setRevisionMark("rearrange");
      this.setRevisionMark("hasAttachedChild");
      return node.listenBy(this, "pend", (function(_this) {
        return function() {
          return _this.pend();
        };
      })(this));
    };

    COMContainer.prototype._detach = function(node) {
      if (node.parent !== this) {
        throw new Errors.LogicError("can't detach node without being it's parent");
      }
      node.parent = null;
      node.root = null;
      node.stopListenBy(this);
      this.pend();
      this.setRevisionMark("hasDetachedChild");
      return this.setRevisionMark("rearrange");
    };

    COMContainer.prototype.last = function() {
      return this.children[this.children.length - 1] || null;
    };

    COMContainer.prototype.child = function(index) {
      return this.children[index] || null;
    };

    COMContainer.prototype.indexOf = function(node) {
      if (node.parent !== this) {
        return -1;
      }
      if (this._indexCached) {
        return node._containerIndex;
      }
      return this.children.indexOf(node);
    };

    COMContainer.prototype.contains = function(node) {
      var child, i, j, len, len1, ref, ref1;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        if (child === node) {
          return true;
        }
      }
      ref1 = this.children;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        child = ref1[j];
        if (child.contains && child.contains(node)) {
          return true;
        }
      }
      return false;
    };

    COMContainer.prototype.removeChild = function(node) {
      var index;
      if (typeof node === "number") {
        index = node;
      } else if (node.parent !== this) {
        return false;
      } else {
        index = this.indexOf(node);
      }
      if (index < 0) {
        return false;
      }
      return this.context.operate(new RemoveChildOperation(this.context, this, {
        index: index
      }));
    };

    COMContainer.prototype.removeChildren = function(children) {
      var child, i, len, results1;
      results1 = [];
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        results1.push(this.removeChild(child));
      }
      return results1;
    };

    COMContainer.prototype.insert = function() {
      var index, nodes;
      index = arguments[0], nodes = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
      return this.context.operate(new InsertOperation(this.context, this, {
        index: index,
        children: nodes
      }));
    };

    COMContainer.prototype.append = function() {
      var nodes;
      nodes = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return this.context.operate(new AppendChildOperation(this.context, this, {
        children: nodes
      }));
    };

    COMContainer.prototype.empty = function() {
      if (this.children.length === 0) {
        return true;
      }
      return this.context.operate(new EmptyOperation(this.context, this, {}));
    };

    COMContainer.prototype.clone = function() {
      var clone, i, item, len, ref;
      clone = this.context.createElement(this.type);
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        clone.append(item.clone());
      }
      return clone;
    };

    COMContainer.prototype.pend = function() {
      this._indexCached = false;
      return COMContainer.__super__.pend.call(this);
    };

    COMContainer.prototype.compose = function() {
      this.cacheIndex();
      return COMContainer.__super__.compose.call(this);
    };

    COMContainer.prototype.slice = function(option) {
      var child, clone, i, isPartial, item, j, k, left, len, len1, len2, ref, ref1, results, right, slice;
      if (option == null) {
        option = {};
      }
      if ((!option.left || ((ref = option.left) != null ? ref.leftMost : void 0)) && (!option.right || option.right.rightMost)) {
        return this.clone();
      }
      if (option.left instanceof COMAnchor) {
        left = option.left;
      } else {
        left = {
          leftMost: true
        };
      }
      if (option.right instanceof COMAnchor) {
        right = option.right;
      } else {
        right = {
          rightMost: true
        };
      }
      results = [];
      ref1 = this.children;
      for (i = 0, len = ref1.length; i < len; i++) {
        child = ref1[i];
        slice = child.slice(option);
        if (!slice) {
          continue;
        }
        results.push(slice);
      }
      if (results.length === 0 && this.children.length !== 0) {
        return null;
      }
      isPartial = false;
      for (j = 0, len1 = results.length; j < len1; j++) {
        child = results[j];
        if (child.isPartial) {
          isPartial = true;
          break;
        }
      }
      clone = this.context.createElement(this.type);
      for (k = 0, len2 = results.length; k < len2; k++) {
        item = results[k];
        clone.append(item);
      }
      clone.isPartial = isPartial;
      return clone;
    };

    COMContainer.prototype.toPlainString = function() {
      var i, item, len, ref, results;
      results = [];
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(item.toPlainString());
      }
      return results.join("");
    };

    COMContainer.prototype.toHumanString = function() {
      var i, item, len, ref, results;
      results = [];
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(item.toHumanString());
      }
      return results.join("");
    };

    COMContainer.prototype.toJSON = function() {
      var item, result;
      result = COMContainer.__super__.toJSON.call(this);
      result.children = ((function() {
        var i, len, ref, results1;
        ref = this.children;
        results1 = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results1.push(item.toJSON());
        }
        return results1;
      }).call(this)).filter(function(item) {
        return item;
      });
      if (result.children.length === 0) {
        delete result.children;
      }
      return result;
    };

    COMContainer.prototype.fromJSON = function(option) {
      var child, i, len, node, ref, results1;
      if (option.children && option.children.length > 0) {
        this.empty();
        ref = option.children;
        results1 = [];
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (!child) {
            continue;
          }
          node = this.context.createElement(child);
          if (node) {
            results1.push(this.append(node));
          } else {
            results1.push(Logger.error("invalid json", child));
          }
        }
        return results1;
      }
    };

    return COMContainer;

  })(COMNode);

  AppendChildOperation = (function(superClass) {
    extend(AppendChildOperation, superClass);

    function AppendChildOperation() {
      return AppendChildOperation.__super__.constructor.apply(this, arguments);
    }

    AppendChildOperation.prototype.name = "AppendChildOperation";

    AppendChildOperation.prototype.invoke = function() {
      var child, i, len, ref, target;
      target = this.target || this.context.root.getChildByPath(this.path);
      if (!(target instanceof COMContainer)) {
        this.error("require a Container node to perform the action");
        return false;
      }
      if (!this.option.children) {
        this.error("request children to append");
        return false;
      }
      this.option.at = target.children.length;
      ref = this.option.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        child = child instanceof COMNode && child || this.context.createElement(child);
        target.children.push(child);
        target._attach(child);
      }
      return true;
    };

    AppendChildOperation.prototype.revoke = function() {
      var child, i, len, result, results1, target;
      target = this.target || this.context.root.getChildByPath(this.path);
      if (!(target instanceof COMContainer)) {
        this.error("require a Container node to perform the action");
        return false;
      }
      if (this.option.at + this.option.children.length !== target.children.length) {
        this.error("revoke with target of children length " + target.children.length + " does't match the invoke result");
        return false;
      }
      result = target.children.splice(this.option.at, this.option.children.length);
      results1 = [];
      for (i = 0, len = result.length; i < len; i++) {
        child = result[i];
        results1.push(target._detach(child));
      }
      return results1;
    };

    return AppendChildOperation;

  })(Operation.TreeOperation);

  EmptyOperation = (function(superClass) {
    extend(EmptyOperation, superClass);

    function EmptyOperation() {
      return EmptyOperation.__super__.constructor.apply(this, arguments);
    }

    EmptyOperation.prototype.name = "EmptyOperation";

    EmptyOperation.prototype.invoke = function() {
      var i, item, len, ref, target;
      target = this.target || this.context.root.getChildByPath(this.path);
      if (!(target instanceof COMContainer)) {
        this.error("require a Container node to perform the action");
        return false;
      }
      this.option.children = target.children.slice();
      target.children.length = 0;
      ref = this.option.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        target._detach(item);
      }
      return true;
    };

    EmptyOperation.prototype.revoke = function() {
      var i, item, len, ref, target;
      target = this.target || this.context.root.getChildByPath(this.path);
      if (!(target instanceof COMContainer)) {
        this.error("require a Container node to perform the action");
        return false;
      }
      if (target.children.length !== 0) {
        this.error("revoke with container chidlren.length " + target.children.length + " isnt 0");
      }
      ref = this.option.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        target.children.push(item);
        target._attach(item);
      }
      return true;
    };

    return EmptyOperation;

  })(Operation.TreeOperation);

  InsertOperation = (function(superClass) {
    extend(InsertOperation, superClass);

    function InsertOperation() {
      return InsertOperation.__super__.constructor.apply(this, arguments);
    }

    InsertOperation.prototype.name = "InsertOperation";

    InsertOperation.prototype.invoke = function() {
      var i, insertion, item, len, ref, target;
      if (!this.option.children || !(this.option.children.length > 0)) {
        this.error("insert without children provided");
      }
      target = this.target || this.context.root.getChildByPath(this.path);
      if (!(target instanceof COMContainer)) {
        this.error("require a Container node to perform the action");
        return false;
      }
      if (target.children.length < this.option.index) {
        this.error("container children.length is " + target.children.length + " less than the insert index " + this.option.index);
        return false;
      }
      insertion = this.option.children.map((function(_this) {
        return function(item) {
          if (item instanceof COMNode) {
            return item;
          }
          return _this.context.createElement(item);
        };
      })(this));
      (ref = target.children).splice.apply(ref, [this.option.index, 0].concat(slice1.call(insertion)));
      for (i = 0, len = insertion.length; i < len; i++) {
        item = insertion[i];
        target._attach(item);
      }
      return true;
    };

    InsertOperation.prototype.revoke = function() {
      var child, children, i, len, target;
      target = this.target || this.context.root.getChildByPath(this.path);
      if (!(target instanceof COMContainer)) {
        this.error("require a Container node to perform the action");
        return false;
      }
      children = target.children.splice(this.option.index, this.option.children.length);
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        target._detach(child);
      }
      return true;
    };

    return InsertOperation;

  })(Operation.TreeOperation);

  RemoveChildOperation = (function(superClass) {
    extend(RemoveChildOperation, superClass);

    function RemoveChildOperation() {
      return RemoveChildOperation.__super__.constructor.apply(this, arguments);
    }

    RemoveChildOperation.prototype.name = "RemoveChildOperation";

    RemoveChildOperation.prototype.invoke = function() {
      var child, i, len, ref, target;
      if (!this.option.length) {
        this.option.length = 1;
      }
      target = this.target || this.context.root.getChildByPath(this.path);
      if (!(target instanceof COMContainer)) {
        this.error("require a Container node to perform the action");
        return false;
      }
      if (target.children.length <= this.option.index) {
        this.error("container children.length is " + target.children.length + " less than the required index " + this.option.index);
        return false;
      }
      this.option.children = target.children.splice(this.option.index, this.option.length);
      ref = this.option.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        target._detach(child);
      }
      return true;
    };

    RemoveChildOperation.prototype.revoke = function() {
      var child, i, len, ref, ref1, target;
      target = this.target || this.context.root.getChildByPath(this.path);
      if (!(target instanceof COMContainer)) {
        this.error("require a Container node to perform the action");
        return false;
      }
      if (target.children.length < this.option.index) {
        this.error("revoke container children.length is " + target.children.length + " less than the required index " + this.option.index);
        return false;
      }
      (ref = target.children).splice.apply(ref, [this.option.index, 0].concat(slice1.call(this.option.children)));
      ref1 = this.option.children;
      for (i = 0, len = ref1.length; i < len; i++) {
        child = ref1[i];
        target._attach(child);
      }
      return true;
    };

    return RemoveChildOperation;

  })(Operation.TreeOperation);

  module.exports = COMContainer;

}).call(this);

}
GlobalContext.setModule("vincent/com/container.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/contents.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMComposer, COMContainer, COMContents, COMRichText, ContentsAvoidEmpty, ContentsAvoidNested, MergeByComposePolicy, NormalizeRichTexts,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMComposer = require("./composer");

  COMRichText = require("./richText");

  COMContainer = require("./container");

  COMContents = (function(superClass) {
    extend(COMContents, superClass);

    COMContents.prototype.type = "Contents";

    function COMContents(context, data) {
      this.context = context;
      this.data = data;
      if (this.appearance == null) {
        this.appearance = {
          tagName: "div",
          classList: ["com", "com-contents"]
        };
      }
      COMContents.__super__.constructor.call(this, this.context, this.data);
    }

    COMContents.prototype.render = function(rc) {
      return COMContents.__super__.render.call(this, rc, {
        recursive: true,
        selfless: !this.beforeMark("hasAttachedChild") && !this.beforeMark("hasDetachedChild")
      });
    };

    return COMContents;

  })(COMContainer);

  ContentsAvoidNested = (function(superClass) {
    extend(ContentsAvoidNested, superClass);

    function ContentsAvoidNested() {
      return ContentsAvoidNested.__super__.constructor.apply(this, arguments);
    }

    ContentsAvoidNested.prototype.type = "Contents";

    ContentsAvoidNested.prototype.exec = function() {
      var child, children, i, index, item, j, len, once, toAppend;
      children = this.target.children.slice();
      for (index = i = 0, len = children.length; i < len; index = ++i) {
        item = children[index];
        if (item.sortOf("Contents") || item.sortOf("Root")) {
          once = true;
          toAppend = item.children.slice();
          item.empty();
          for (j = toAppend.length - 1; j >= 0; j += -1) {
            child = toAppend[j];
            item.after(child);
          }
          item.remove();
        }
      }
      return once || false;
    };

    return ContentsAvoidNested;

  })(COMComposer);

  ContentsAvoidEmpty = (function(superClass) {
    extend(ContentsAvoidEmpty, superClass);

    function ContentsAvoidEmpty() {
      return ContentsAvoidEmpty.__super__.constructor.apply(this, arguments);
    }

    ContentsAvoidEmpty.prototype.type = "Contents";

    ContentsAvoidEmpty.prototype.exec = function() {
      var last, node;
      last = this.target.last();
      if (!last) {
        node = this.context.createElement("RichText", {
          contentString: ""
        });
        this.target.append(node);
        return true;
      }
    };

    return ContentsAvoidEmpty;

  })(COMComposer);

  NormalizeRichTexts = (function(superClass) {
    extend(NormalizeRichTexts, superClass);

    function NormalizeRichTexts() {
      return NormalizeRichTexts.__super__.constructor.apply(this, arguments);
    }

    NormalizeRichTexts.prototype.type = "Contents";

    NormalizeRichTexts.prototype.exec = function() {
      var anchor, children, contents, currentJoins, cursor, i, index, item, j, joined, k, l, last, len, len1, len2, len3, ref, ref1, ref2, ref3, ref4, ref5, ref6, removed, renderTarget;
      children = this.target.children.slice();
      if ((ref = window.perf) != null) {
        ref.start("L1");
      }
      for (i = 0, len = children.length; i < len; i++) {
        item = children[i];
        index = this.target.indexOf(item);
        if (children.length > 1 && item.length === 0) {
          if ((ref1 = window.perf) != null) {
            ref1.start("AC");
          }
          ref2 = item.anchors;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            anchor = ref2[j];
            cursor = anchor.cursor;
            cursor.next({
              actions: ["head"]
            }) || cursor.previous({
              actions: ["tail"]
            });
          }
          if ((ref3 = window.perf) != null) {
            ref3.end("AC");
          }
          item.remove();
          removed = true;
        } else if (item.length === 0) {
          true;
        }
      }
      if ((ref4 = window.perf) != null) {
        ref4.end("L1");
      }
      currentJoins = [];
      children = this.target.children.slice();
      children.push({
        end: true
      });
      if ((ref5 = window.perf) != null) {
        ref5.start("L2");
      }
      for (index = k = 0, len2 = children.length; k < len2; index = ++k) {
        item = children[index];
        if (item.type === "RichText" && !(item.length === 0 && item === this.target.last())) {
          currentJoins.push(item);
        } else {
          if (currentJoins.length < 2) {
            currentJoins.length = 0;
            continue;
          }
          index = this.target.indexOf(currentJoins[0]);
          contents = currentJoins.map(function(item) {
            return item.contentString;
          }).join("");
          for (l = 0, len3 = currentJoins.length; l < len3; l++) {
            item = currentJoins[l];
            item.remove();
            joined = true;
          }
          renderTarget = this.context.createElement("RichText", {
            contentString: contents
          });
          this.target.insert(index, renderTarget);
          this.mergeAnchors(currentJoins, renderTarget);
          currentJoins.length = 0;
          joined = true;
        }
      }
      if ((ref6 = window.perf) != null) {
        ref6.end("L2");
      }
      last = this.target.last();
      if (!last || last.type !== "RichText") {
        this.target.append(this.context.createElement("RichText", {
          contentString: "\n"
        }));
        return true;
      }
      if (removed || joined) {
        return true;
      }
      return false;
    };

    NormalizeRichTexts.prototype.mergeAnchors = function(children, target) {
      var anchor, base, i, item, j, len, len1, ref, results;
      base = 0;
      results = [];
      for (i = 0, len = children.length; i < len; i++) {
        item = children[i];
        ref = item.anchors;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          anchor = ref[j];
          anchor.cursor.pointAt(target, {
            anchor: {
              index: base + anchor.index
            }
          });
        }
        results.push(base += item.length);
      }
      return results;
    };

    return NormalizeRichTexts;

  })(COMComposer);

  MergeByComposePolicy = (function(superClass) {
    extend(MergeByComposePolicy, superClass);

    function MergeByComposePolicy() {
      return MergeByComposePolicy.__super__.constructor.apply(this, arguments);
    }

    MergeByComposePolicy.prototype.type = "Contents";

    MergeByComposePolicy.prototype.obeys = function(a, b) {
      var ca, cb, needSplit;
      if (!a || !b) {
        return true;
      }
      needSplit = a.composePolicy.newlineSplitTail || b.composePolicy.newlineSplitHead;
      if (!needSplit) {
        return false;
      }
      ca = a.contentString;
      cb = b.contentString;
      return !ca || ca.slice(-1) === "\n" || !cb || cb[0] === "\n" || false;
    };

    MergeByComposePolicy.prototype.exec = function() {
      var afterContent, anchor, beforeContent, changed, child, childIndex, children, counter, i, index, j, len, len1, length, newText, next, ref, ref1;
      children = this.target.children.slice();
      length = children.length;
      index = 0;
      counter = 0;
      while (child = children[index]) {
        counter += 1;
        index += 1;
        next = children[index];
        if (!child || !next) {
          continue;
        }
        if (child.composerBuffer.passMerge && next.composerBuffer.passMerge) {
          continue;
        }
        if (this.obeys(child, next)) {
          continue;
        }
        beforeContent = child.contentString;
        afterContent = next.contentString;
        childIndex = this.target.indexOf(child);
        this.target.removeChild(child);
        this.target.removeChild(next);
        newText = this.context.createElement("RichText", {
          contentString: ((typeof child.toContentString === "function" ? child.toContentString() : void 0) || beforeContent) + (next.toContentString() || afterContent)
        });
        this.target.insert(childIndex, newText);
        ref = child.anchors;
        for (i = 0, len = ref.length; i < len; i++) {
          anchor = ref[i];
          anchor.cursor.pointAt(newText, {
            anchor: {
              index: anchor.index
            }
          });
        }
        ref1 = next.anchors;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          anchor = ref1[j];
          anchor.cursor.pointAt(newText, {
            anchor: {
              index: beforeContent.length + anchor.index
            }
          });
        }
        children[index] = newText;
        changed = true;
      }
      if (changed) {
        return true;
      }
      return false;
    };

    return MergeByComposePolicy;

  })(COMComposer);

  COMContents.ContentsAvoidEmpty = ContentsAvoidEmpty;

  COMContents.NormalizeRichTexts = NormalizeRichTexts;

  COMContents.MergeByComposePolicy = MergeByComposePolicy;

  module.exports = COMContents;

}).call(this);

}
GlobalContext.setModule("vincent/com/contents.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/context.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMContainer, COMContents, COMContext, COMCursor, COMIntent, COMNamespace, COMNode, COMRichText, COMRoot, COMRune, COMRuneCache, COMSpell, COMText, COMUnknownRune, CheckPointProvider, ComposableTrait, ComposeContext, Compressor, CursorManagerTrait, Errors, EventEmitter, FacilityAttachable, IntentCapable, MetaManagerTrait, NestedContextTrait, NodeAttachableTrait, OperationHistory, PluginStorageCapable, PropertyTrait, RenderContext, RenderableTrait, SharedCallbacks, Trait, Walker,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  COMRoot = require("./root");

  COMNode = require("./node");

  COMContainer = require("./container");

  COMContents = require("./contents");

  COMCursor = require("./cursor");

  COMNamespace = require("./namespace");

  COMRichText = require("./richText");

  COMRune = require("./rune");

  COMSpell = require("./spell");

  COMUnknownRune = require("./unknownRune");

  COMText = require("./text");

  Walker = require("./helper/walker");

  EventEmitter = (require("./events")).EventEmitter;

  Errors = require("./errors");

  COMRuneCache = require("./runeCache");

  Compressor = require("./helper/compressor");

  COMIntent = require("./intent");

  SharedCallbacks = require("./helper/sharedCallbacks");

  Trait = require("./helper/trait");

  RenderContext = (function(superClass) {
    extend(RenderContext, superClass);

    function RenderContext(context1, id1) {
      this.context = context1;
      this.id = id1;
      RenderContext.__super__.constructor.call(this);
      this.caches = {};
      this.interactive = true;
      this.renderConfig = {};
    }

    RenderContext.prototype.destroy = function() {
      this.emit("destroy");
      return this.caches = null;
    };

    RenderContext.prototype.cache = function(id) {
      if (!this.caches[id]) {
        this.caches[id] = {};
      }
      return this.caches[id];
    };

    RenderContext.prototype.staticize = function() {
      var child, container, contents, el, i, index, j, l, len, len1, ref, ref1, ref2, results, t;
      contents = this.context.root.children[0];
      container = contents.el;
      ref = contents.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        el = child.el;
        ref1 = [el.offsetLeft, el.offsetTop], l = ref1[0], t = ref1[1];
        child.position = {
          l: l,
          t: t
        };
      }
      ref2 = contents.children;
      results = [];
      for (index = j = 0, len1 = ref2.length; j < len1; index = ++j) {
        child = ref2[index];
        child.el.style.position = "absolute";
        child.el.style.left = "0";
        child.el.style.top = "0";
        child.el.style.transform = "translateX(" + child.position.l + "px) translateY(" + child.position.t + "px)";
        if (index < 500) {
          child.el.style.display = "none";
          results.push(child.el.parentElement.removeChild(child.el));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return RenderContext;

  })(EventEmitter);

  IntentCapable = (function(superClass) {
    extend(IntentCapable, superClass);

    function IntentCapable() {
      return IntentCapable.__super__.constructor.apply(this, arguments);
    }

    IntentCapable.prototype.Intent = COMIntent;

    IntentCapable.prototype.getConstructor = function(name) {
      return this.namespace.creators[name].creator;
    };

    IntentCapable.prototype.createIntent = function() {
      var Intent, args, name;
      name = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      Intent = this.Intent.Intents[name];
      if (!Intent) {
        return null;
      }
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Intent, [this.context].concat(slice.call(args)), function(){});
    };

    IntentCapable.prototype.castIntent = function() {
      var args, intent, result;
      intent = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (intent instanceof COMIntent) {
        this.emit("intent", intent);
        return true;
      }
      result = this.createIntent.apply(this, [intent].concat(slice.call(args)));
      if (!result) {
        Logger.error("Intent not found:", intent);
        return false;
      }
      this.emit("intent", result);
      return true;
    };

    return IntentCapable;

  })(Trait);

  COMContext = (function(superClass) {
    extend(COMContext, superClass);

    COMContext.namespace = new COMNamespace();

    COMContext.index = 0;

    function COMContext(option) {
      if (option == null) {
        option = {};
      }
      COMContext.__super__.constructor.call(this);
      new IntentCapable(this);
      new RenderableTrait(this);
      new PropertyTrait(this);
      new NestedContextTrait(this);
      new CursorManagerTrait(this);
      new MetaManagerTrait(this);
      new PluginStorageCapable(this);
      new FacilityAttachable(this);
      new ComposableTrait(this);
      new NodeAttachableTrait(this);
      this.enableAsync = false;
      this.namespace = option.namespace || COMContext.namespace.clone();
      this.runeCache = new COMRuneCache(this);
      this.root = this.createElement("Root", {
        withContext: true
      });
      this.id = (COMContext.index++).toString();
      this.__defineGetter__("locked", (function(_this) {
        return function() {
          return _this.composeContext.isComposing;
        };
      })(this));
      this.__defineGetter__("isSelfReadly", (function(_this) {
        return function() {
          return _this._isReadonly;
        };
      })(this));
      this.__defineGetter__("isReadonly", (function(_this) {
        return function() {
          var ref;
          return _this._isReadonly || ((ref = _this.parent) != null ? ref.isReadonly : void 0);
        };
      })(this));
      this.__defineSetter__("isReadonly", (function(_this) {
        return function(v) {
          _this._isReadonly = v;
          return _this.emit("readonly", _this._isReadonly);
        };
      })(this));
      this.define("title");
      this.define("type");
      this.define("ownerName");
      this.define("noteName");
      this.namespace.initContext(this);
    }

    COMContext.prototype.fromJSON = function(json) {
      var prop, ref, ro, value;
      ro = this.isReadonly;
      this.isReadonly = false;
      this.root.fromJSON(json.content);
      this.revision = json.revision || 1;
      if (json.pluginStorage) {
        ref = json.pluginStorage;
        for (prop in ref) {
          value = ref[prop];
          this.setPluginData(prop, value);
        }
      }
      this.compose();
      this.isReadonly = ro;
      return this;
    };

    COMContext.prototype.toJSON = function() {
      var json, prop, ref, ref1, value;
      if (this._jsonHistory && this.revision === this._jsonHistory.revision) {
        return this._jsonHistory;
      }
      this._jsonHistory = json = {
        content: this.root.toJSON(),
        revision: this.revision
      };
      ref = this.metas;
      for (prop in ref) {
        value = ref[prop];
        if (value != null ? value.toJSON : void 0) {
          value = value.toJSON();
        }
        json[prop] = value;
      }
      if (this.pluginStorage) {
        json.pluginStorage = this.getPluginStorageJSON();
      }
      json.humanString = this.toHumanString();
      json.digest = ((ref1 = json.humanString) != null ? ref1.slice(0, 1000).replace(/(^|\n)#{1,6}\s+.*/, "").trim() : void 0) || "";
      return json;
    };

    COMContext.prototype.toHumanString = function() {
      var ref;
      if (this._humanStringRevision === this.revision) {
        return this._humanStringCache;
      } else {
        this._humanStringCache = ((ref = this.root) != null ? ref.toHumanString() : void 0) || "";
        this._humanStringRevision = this.revision;
        return this._humanStringCache;
      }
    };

    COMContext.prototype.createElement = function() {
      var args, name, ref;
      name = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (name instanceof COMNode) {
        return name.clone();
      } else if (typeof name.type === "string") {
        return this.namespace.create(this, name.type, name);
      } else if (typeof name === "string") {
        return (ref = this.namespace).create.apply(ref, [this, name].concat(slice.call(args)));
      }
      return null;
    };

    COMContext.prototype.forceChange = function() {
      this.revision += 1;
      return this.emit("change");
    };

    return COMContext;

  })(EventEmitter);

  NodeAttachableTrait = (function(superClass) {
    extend(NodeAttachableTrait, superClass);

    function NodeAttachableTrait() {
      return NodeAttachableTrait.__super__.constructor.apply(this, arguments);
    }

    NodeAttachableTrait.prototype.handleNodeAttach = function(node) {};

    NodeAttachableTrait.prototype.handleNodeDetach = function(node) {};

    return NodeAttachableTrait;

  })(Trait);

  PropertyTrait = (function(superClass) {
    extend(PropertyTrait, superClass);

    function PropertyTrait() {
      return PropertyTrait.__super__.constructor.apply(this, arguments);
    }

    PropertyTrait.prototype.waitPropertyAvailables = [];

    PropertyTrait.prototype.property = {};

    PropertyTrait.prototype.getWhenAvailable = function(name, callback) {
      if (this.property[name]) {
        callback(null, this.property[name]);
        return;
      }
      return this.waitPropertyAvailables.push({
        name: name,
        callback: callback
      });
    };

    PropertyTrait.prototype.getAndListenBy = function(who, name, callback) {
      this.listenBy(who, "property/" + name, callback);
      if (this.property[name]) {
        return callback(this.property[name]);
      }
    };

    PropertyTrait.prototype.define = function() {};

    PropertyTrait.prototype.get = function(name) {
      return this.property[name];
    };

    PropertyTrait.prototype.set = function(name, value) {
      this.property[name] = value;
      this.emit("property", name, value);
      this.emit("property/" + name, value);
      this.waitPropertyAvailables = this.waitPropertyAvailables.filter(function(item) {
        if (item.name === name) {
          item.callback(null, value);
          return false;
        }
        return true;
      });
    };

    return PropertyTrait;

  })(Trait);

  RenderableTrait = (function(superClass) {
    extend(RenderableTrait, superClass);

    function RenderableTrait() {
      return RenderableTrait.__super__.constructor.apply(this, arguments);
    }

    RenderableTrait.prototype.renderContexts = {};

    RenderableTrait.prototype.defaultRenderContext = null;

    RenderableTrait.prototype.initialize = function() {
      return this.defaultRenderContext = this.allocateRenderContext();
    };

    RenderableTrait.prototype.allocateRenderContext = function() {
      var id;
      if (this.renderContextOffset == null) {
        this.renderContextOffset = 0;
      }
      id = this.id * 10000 + this.renderContextOffset++;
      this.renderContexts[id] = new RenderContext(this, id);
      return this.renderContexts[id];
    };

    RenderableTrait.prototype.destroyRenderContext = function(rc) {
      if (rc.context !== this) {
        Logger.error("destroy context not belongs to current context", rc);
        return;
      }
      rc.destroy();
      return this.renderContexts[rc.id] = null;
    };

    RenderableTrait.prototype.setRenderContext = function(rc) {
      this.currentRenderContext = rc;
      return this.root.setRenderContext(rc);
    };

    RenderableTrait.prototype.render = function(rc, option) {
      if (rc == null) {
        rc = this.defaultRenderContext;
      }
      if (option == null) {
        option = {};
      }
      this.setRenderContext(rc);
      if (!this.root.dirty) {
        return;
      }
      return this.root.render(rc, option);
    };

    return RenderableTrait;

  })(Trait);

  NestedContextTrait = (function(superClass) {
    extend(NestedContextTrait, superClass);

    function NestedContextTrait() {
      return NestedContextTrait.__super__.constructor.apply(this, arguments);
    }

    NestedContextTrait.prototype.children = [];

    NestedContextTrait.prototype.parent = null;

    NestedContextTrait.prototype.addChild = function(context) {
      if (context.parent === this) {
        return true;
      }
      if (context.parent) {
        return false;
      }
      context.parent = this;
      return this.children.push(context);
    };

    NestedContextTrait.prototype.removeChild = function(context) {
      if (context.parent !== this) {
        return false;
      }
      this.children = this.children.filter(function(item) {
        return item === context;
      });
      context.parent = null;
      return true;
    };

    return NestedContextTrait;

  })(Trait);

  CursorManagerTrait = (function(superClass) {
    extend(CursorManagerTrait, superClass);

    function CursorManagerTrait() {
      return CursorManagerTrait.__super__.constructor.apply(this, arguments);
    }

    CursorManagerTrait.prototype.cursors = {};

    CursorManagerTrait.prototype.createCursor = function(option) {
      var cursor;
      cursor = new COMCursor(this, option);
      this.cursors[cursor.id] = cursor;
      cursor.listenBy(this, "destroyed", (function(_this) {
        return function() {
          cursor.stopListenBy(_this);
          return delete _this.cursors[cursor.id];
        };
      })(this));
      return cursor;
    };

    CursorManagerTrait.prototype.removeCursor = function(cursor) {
      return delete this.cursors[cursor.id];
    };

    CursorManagerTrait.prototype.getCursorsJSON = function() {
      var cursor, cursors, id, ref;
      cursors = {};
      ref = this.cursors;
      for (id in ref) {
        cursor = ref[id];
        cursors[id] = cursor.toJSON();
      }
      return cursors;
    };

    CursorManagerTrait.prototype.pointIdenticalCursors = function(cursor, node, option) {
      cursor.captureIdenticalCursors();
      cursor.pointAt(node, option);
      return cursor.transportIdenticalCursors();
    };

    CursorManagerTrait.prototype.pointIdenticalCursorsAnchor = function(cursor, anchor) {
      cursor.captureIdenticalCursors();
      cursor.pointAtAnchor(anchor);
      return cursor.transportIdenticalCursors();
    };

    CursorManagerTrait.prototype.ensureCursorValid = function() {
      var cursor, id, ref, results;
      ref = this.cursors;
      results = [];
      for (id in ref) {
        cursor = ref[id];
        if (!cursor.anchor || !cursor.anchor.node.root) {
          cursor.emit("invalid");
          if (this.cursors[cursor.id] === cursor) {
            results.push(cursor.begin());
          } else {
            results.push(void 0);
          }
        } else {
          results.push(cursor.conduct("applyTailBoundary"));
        }
      }
      return results;
    };

    return CursorManagerTrait;

  })(Trait);

  MetaManagerTrait = (function(superClass) {
    extend(MetaManagerTrait, superClass);

    function MetaManagerTrait() {
      return MetaManagerTrait.__super__.constructor.apply(this, arguments);
    }

    MetaManagerTrait.prototype.metas = {};

    MetaManagerTrait.prototype.setMeta = function(prop, value) {
      var change;
      if (this.metas[prop] === value) {
        return;
      }
      if (!Leaf.Util.compare(this.metas[prop], value)) {
        this.metas[prop] = value;
        change = {};
        change[prop] = value;
        this.emit("change/meta/" + prop, value);
        this.emit("change/meta", change);
        return this.emit("change");
      }
    };

    return MetaManagerTrait;

  })(Trait);

  PluginStorageCapable = (function(superClass) {
    extend(PluginStorageCapable, superClass);

    function PluginStorageCapable() {
      return PluginStorageCapable.__super__.constructor.apply(this, arguments);
    }

    PluginStorageCapable.prototype.pluginStorage = {};

    PluginStorageCapable.prototype.setPluginData = function(key, value) {
      if (this.pluginStorage[key] === value) {
        return;
      }
      if (!Leaf.Util.compare(this.pluginStorage[key], value)) {
        this.pluginStorage[key] = value;
        this.emit("pluginStorage/" + key, value);
        return this.emit("change");
      }
    };

    PluginStorageCapable.prototype.getPluginData = function(key) {
      return this.pluginStorage[key];
    };

    PluginStorageCapable.prototype.getPluginStorageJSON = function() {
      var json, prop, ref, value;
      json = {};
      ref = this.pluginStorage;
      for (prop in ref) {
        value = ref[prop];
        if (value != null ? value.toJSON : void 0) {
          json[prop] = value.toJSON();
        } else {
          json[prop] = value;
        }
      }
      return json;
    };

    return PluginStorageCapable;

  })(Trait);

  FacilityAttachable = (function(superClass) {
    extend(FacilityAttachable, superClass);

    function FacilityAttachable() {
      return FacilityAttachable.__super__.constructor.apply(this, arguments);
    }

    FacilityAttachable.prototype.facilities = {};

    return FacilityAttachable;

  })(Trait);

  ComposableTrait = (function(superClass) {
    extend(ComposableTrait, superClass);

    function ComposableTrait() {
      return ComposableTrait.__super__.constructor.apply(this, arguments);
    }

    ComposableTrait.prototype.composeOperations = [];

    ComposableTrait.prototype.seedOperations = [];

    ComposableTrait.prototype.nextComposeCallback = [];

    ComposableTrait.prototype.initialize = function() {
      this.composeContext = new ComposeContext(this);
      this.history = new OperationHistory(this);
      this.checkPointProvider = new CheckPointProvider(this);
      return this.nextComposeCallback = SharedCallbacks.create();
    };

    ComposableTrait.prototype.operate = function(operation) {
      var ref;
      if (this.isReadonly) {
        this.emit("editAttempt");
        return false;
      }
      if (operation.invoke()) {
        if (((ref = operation.target) != null ? ref.root : void 0) === this.root) {
          if (this.composeContext.isComposing) {
            this.composeOperations.push(operation);
          } else {
            this.seedOperations.push(operation);
          }
          this.emit("operate", operation);
        }
        return true;
      }
      return false;
    };

    ComposableTrait.prototype.nextCompose = function(handler) {
      if (!this.isComposing && !this.composeContext.requireCompose) {
        return handler();
      } else {
        return this.nextComposeCallback.push(handler);
      }
    };

    ComposableTrait.prototype["try"] = function(fn, debug) {
      var e, error;
      if (debug) {
        fn();
        return null;
      } else {
        try {
          fn();
        } catch (error) {
          e = error;
          return e;
        }
        return null;
      }
    };

    ComposableTrait.prototype.transact = function(executer) {
      var e, returnValue;
      returnValue = null;
      e = this["try"]((function(_this) {
        return function() {
          var result, transaction;
          transaction = _this.isTransaction;
          if (!_this.isTransaction) {
            if (!_this.history.isRedoing()) {
              _this.history.addCheckPoint();
            }
          }
          _this.isTransaction = true;
          result = executer();
          _this.isTransaction = transaction;
          if (!_this.isTransaction) {
            returnValue = _this.compose();
            if (!_this.isComposing && !_this.requireCompose) {
              return _this.runeCache.gc();
            }
          }
        };
      })(this), typeof window !== "undefined" && window !== null ? window.isDebug : void 0);
      if (e) {
        Logger.error("error occurs during COMContext transaction", e);
      }
      return returnValue;
    };

    ComposableTrait.prototype.compose = function() {
      var composeFinish, hasInput, start;
      this.isComposing = true;
      start = Date.now();
      if (this.seedOperations.length > 0) {
        this.history.addSeedRecord(this.seedOperations.slice());
        this.seedOperations.length = 0;
        hasInput = true;
        this.emit("hasInput");
      }
      this.composeOperations.length = 0;
      composeFinish = (function(_this) {
        return function() {
          var SLOW_COMPOSE, e, endCompose, error, hasCompose;
          if (_this.composeOperations.length > 0) {
            try {
              _this.history.addComposeRecord(_this.composeOperations.slice());
            } catch (error) {
              e = error;
              if (e.type === "multiCompose") {
                Logger.error(e, "multiCompose");
              } else if (e.type === "impossibleCompose") {
                Logger.error(e, "impossibleCompose");
              } else {
                Logger.error(e, "unkown compose");
              }
            }
            hasCompose = true;
            _this.emit("hasCompose");
          }
          SLOW_COMPOSE = 100;
          SLOW_COMPOSE = 10;
          endCompose = Date.now();
          if (endCompose - start > SLOW_COMPOSE) {
            Logger.debug("SLOW_COMPOSE", endCompose - start, "ms", ">", SLOW_COMPOSE, "ms");
          }
          _this.ensureCursorValid();
          _this.isComposing = false;
          if (_this.revision == null) {
            _this.revision = 0;
          }
          if (hasInput || hasCompose) {
            _this.revision += 1;
          }
          if (_this.checkPointProvider.consume() || true) {
            _this.history.addCheckPoint();
          }
          _this.emit("composeEnd", {
            hasInput: hasInput,
            hasCompose: hasCompose
          });
          if (hasInput || hasCompose) {
            _this.emit("change");
          }
          return _this.nextComposeCallback();
        };
      })(this);
      if (this.enableAsync) {
        return this.composeContext.composeAsync((function(_this) {
          return function() {
            return composeFinish();
          };
        })(this));
      } else {
        this.composeContext.compose();
        return composeFinish();
      }
    };

    ComposableTrait.prototype.requestCompose = function(who) {
      if (who.context !== this) {
        return;
      }
      return this.composeContext.add(who);
    };

    return ComposableTrait;

  })(Trait);

  CheckPointProvider = (function() {
    function CheckPointProvider(context1) {
      this.context = context1;
      this.value = 0;
      this.context.on("operate", (function(_this) {
        return function() {
          return _this.value += 3;
        };
      })(this));
      this.context.on("hasInput", (function(_this) {
        return function() {
          return _this.value += 1;
        };
      })(this));
      this.context.on("hasCompose", (function(_this) {
        return function() {
          return _this.value += 10;
        };
      })(this));
      this.threshold = 10;
    }

    CheckPointProvider.prototype.consume = function() {
      if (this.value > this.threshold) {
        this.value = 0;
        return true;
      }
      return false;
    };

    return CheckPointProvider;

  })();

  OperationHistory = (function() {
    function OperationHistory(context1) {
      this.context = context1;
      this.stack = [];
      this.index = -1;
      this.maxHistoryStep = 1000;
      this.checkPointCount = 0;
      this.overflowStepDeletion = 10;
    }

    OperationHistory.prototype.last = function() {
      return this.stack[this.stack.length - 1] || null;
    };

    OperationHistory.prototype.current = function() {
      return this.stack[this.index] || null;
    };

    OperationHistory.prototype.addSeedRecord = function(operations) {
      this.index += 1;
      this.stack.length = this.index;
      return this.stack.push({
        operations: operations,
        type: "Seed"
      });
    };

    OperationHistory.prototype.addComposeRecord = function(operations) {
      var last;
      last = this.last();
      if ((last != null ? last.type : void 0) === "Compose") {
        throw new Errors.LogicError("continuous composing record", {
          type: "multiCompose"
        });
      } else if ((last != null ? last.type : void 0) === "CheckPoint") {
        this.debug();
        throw new Errors.LogicError("composing next to check point", {
          type: "impossibleCompose",
          records: operations
        });
      }
      this.index++;
      this.stack.length = this.index;
      return this.stack.push({
        operations: operations,
        type: "Compose"
      });
    };

    OperationHistory.prototype.addCheckPoint = function() {
      if (this.isRedoing()) {
        return false;
      }
      return this.context.nextCompose((function(_this) {
        return function() {
          return _this._addCheckPoint();
        };
      })(this));
    };

    OperationHistory.prototype.enableCheckPoint = function() {
      return this.isCheckPointDisabled = false;
    };

    OperationHistory.prototype.disableCheckPoint = function() {
      return this.isCheckPointDisabled = true;
    };

    OperationHistory.prototype.isRedoing = function() {
      return this.index !== this.stack.length - 1;
    };

    OperationHistory.prototype._addCheckPoint = function(option) {
      var counter, i, index, item, len, ref, ref1, targetIndex;
      if (option == null) {
        option = {};
      }
      if (this.isCheckPointDisabled) {
        return;
      }
      this.index++;
      this.stack.length = this.index;
      if (((ref = this.stack[this.index - 1]) != null ? ref.type : void 0) === "CheckPoint") {
        this.stack.pop();
        this.checkPointCount -= 1;
        this.index--;
      }
      this.stack.push({
        type: "CheckPoint",
        cursors: this.context.getCursorsJSON(),
        time: Date.now()
      });
      this.checkPointCount += 1;
      if (this.checkPointCount > this.maxHistoryStep) {
        counter = this.overflowStepDeletion;
        ref1 = this.stack;
        for (index = i = 0, len = ref1.length; i < len; index = ++i) {
          item = ref1[index];
          if (item.type === "CheckPoint") {
            if (counter > 0) {
              counter -= 1;
              continue;
            } else {
              targetIndex = index;
              break;
            }
          } else {
            continue;
          }
        }
        if (!targetIndex) {

        } else {
          this.stack.splice(0, targetIndex);
          this.index -= targetIndex;
          return this.checkPointCount -= this.overflowStepDeletion;
        }
      }
    };

    OperationHistory.prototype.backward = function() {
      var i, id, json, op, ops, records, ref, ref1, ref2;
      if (((ref = this.current()) != null ? ref.type : void 0) !== "CheckPoint") {
        this.addCheckPoint();
      }
      records = [];
      while (true) {
        if (this.index === 0) {
          break;
        }
        if (this.index > 0) {
          this.index -= 1;
        }
        if (this.current().type === "CheckPoint") {
          break;
        }
        records.push(this.current());
      }
      if (records.length === 0) {
        return false;
      }
      records.reverse();
      ops = [];
      records.forEach(function(record) {
        return ops.push.apply(ops, record.operations);
      });
      for (i = ops.length - 1; i >= 0; i += -1) {
        op = ops[i];
        op.revoke();
      }
      ref1 = this.current().cursors || {};
      for (id in ref1) {
        json = ref1[id];
        if ((ref2 = this.context.cursors[id]) != null) {
          ref2.setByJSON(json);
        }
      }
      return true;
    };

    OperationHistory.prototype.forward = function(n) {
      var i, id, json, len, op, ops, records, ref, ref1;
      records = [];
      if (this.index === this.stack.length - 1) {
        return false;
      }
      while (true) {
        if (this.index === this.stack.length - 1) {
          break;
        }
        if (this.index >= this.stack.length) {
          break;
        }
        this.index += 1;
        if (this.current().type === "CheckPoint") {
          break;
        }
        records.push(this.current());
      }
      if (records.length === 0) {
        return false;
      }
      ops = [];
      records.forEach(function(record) {
        return ops.push.apply(ops, record.operations);
      });
      for (i = 0, len = ops.length; i < len; i++) {
        op = ops[i];
        op.invoke();
      }
      ref = this.current().cursors || {};
      for (id in ref) {
        json = ref[id];
        if ((ref1 = this.context.cursors[id]) != null) {
          ref1.setByJSON(json);
        }
      }
      return true;
    };

    OperationHistory.prototype.fromNow = function() {
      this.stack.length = 0;
      this.index = -1;
      return this.addCheckPoint();
    };

    OperationHistory.prototype.describe = function() {
      return this.stack.slice().map(function(item) {
        var ref, ref1;
        return item.type + "." + (((ref = (ref1 = item.operations) != null ? ref1.map(function(o) {
          return o.describe();
        }) : void 0) != null ? ref.join('|') : void 0) || "nil");
      });
    };

    OperationHistory.prototype.debug = function() {
      var infos;
      return infos = this.stack.map(function(item) {
        if (item.type === "Seed") {
          return "S";
        } else if (item.type === "Compose") {
          return "C";
        } else {
          return "CP:" + (JSON.stringify(item.cursors));
        }
      });
    };

    return OperationHistory;

  })();

  ComposeContext = (function() {
    function ComposeContext() {
      this.queue = [];
      this.counter = 0;
      this.composeInterval = 30;
      this.requireCompose = false;
    }

    ComposeContext.prototype.add = function(target) {
      if (target._requireCompose) {
        return false;
      }
      target._requireCompose = true;
      this.requireCompose = true;
      return this.queue.push(target);
    };

    ComposeContext.prototype.next = function() {
      var target;
      if (this.queue.length === 0) {
        return false;
      }
      target = this.queue.shift();
      target._requireCompose = false;
      this.previousComposeTarget = target;
      if (target.root && target.root.withContext && target.compose()) {
        return true;
      }
      return true;
    };

    ComposeContext.prototype.composeAsync = function(callback) {
      if (callback == null) {
        callback = function() {};
      }
      if (!this.requireCompose) {
        this.composeStartDate = null;
        return false;
      }
      if (this.isComposing) {
        return;
      }
      this.composeStartDate = Date.now();
      this.isComposing = true;
      this.totalComposeCount = 0;
      this.asyncInterval = 0;
      this.asyncHasCompose = false;
      this.asyncComposeCallback = callback;
      return this._composeChunk();
    };

    ComposeContext.prototype._composeChunk = function() {
      var DANGER_COMPOSE, MAX_COMPOSE, callback, chunkCheck, chunkTime, counter, notYet, start;
      counter = 0;
      MAX_COMPOSE = 200000;
      DANGER_COMPOSE = 10000;
      chunkCheck = 500;
      chunkTime = 200;
      start = Date.now();
      while (notYet = this.next()) {
        this.totalComposeCount += 1;
        counter += 1;
        if (this.totalComposeCount > DANGER_COMPOSE) {
          debugger;
        }
        if (this.totalComposeCount > MAX_COMPOSE) {
          throw new Error("MAX COMPOSE EXCEED " + MAX_COMPOSE);
        }
        this.asyncHasCompose = true;
        if (counter > chunkCheck) {
          counter = 0;
          if (Date.now() - start > chunkTime) {
            break;
          }
        }
      }
      if (notYet) {
        setTimeout((function(_this) {
          return function() {
            return _this._composeChunk();
          };
        })(this), this.asyncInterval);
        return;
      }
      this.requireCompose = false;
      this.isComposing = false;
      callback = this.asyncComposeCallback;
      this.asyncComposeCallback = null;
      callback(this.asyncHasCompose);
    };

    ComposeContext.prototype.compose = function() {
      var DANGER_COMPOSE, MAX_COMPOSE, RECORD, counter, debug, hasCompose, target;
      if (!this.requireCompose) {
        this.composeStartDate = null;
        return false;
      }
      if (this.isComposing) {
        return;
      }
      this.composeStartDate = Date.now();
      this.isComposing = true;
      hasCompose = false;
      counter = 0;
      debug = false;
      MAX_COMPOSE = 1000 * 100;
      DANGER_COMPOSE = 10 * 1000;
      if (debug) {
        MAX_COMPOSE /= 100;
        DANGER_COMPOSE /= 10;
      }
      RECORD = DANGER_COMPOSE - 100;
      while (this.next()) {
        counter += 1;
        if (counter > RECORD && counter < DANGER_COMPOSE) {
          window.DANGER_LOG = function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return Logger.error.apply(Logger, args);
          };
          target = this.previousComposeTarget;
          if (this._composeDebugTrunk == null) {
            this._composeDebugTrunk = [];
          }
          this._composeDebugTrunk.push(target);
        }
        if (counter > DANGER_COMPOSE) {
          debugger;
        }
        if (counter > MAX_COMPOSE) {
          debugger;
          throw new Error("MAX COMPOSE EXCEED " + MAX_COMPOSE);
        }
        hasCompose = true;
      }
      this.requireCompose = false;
      this.isComposing = false;
      this.counter++;
      return hasCompose;
    };

    return ComposeContext;

  })();

  COMContext.namespace.registerNode(COMText);

  COMContext.namespace.registerNode(COMSpell);

  COMContext.namespace.registerNode(COMRichText);

  COMContext.namespace.registerNode(COMNode);

  COMContext.namespace.registerNode(COMContainer);

  COMContext.namespace.registerNode(COMRoot);

  COMContext.namespace.registerNode(COMRune);

  COMContext.namespace.registerNode(COMContents);

  COMContext.namespace.registerNode(COMUnknownRune);

  COMContext.namespace.registerComposer(new COMContents.ContentsAvoidEmpty);

  COMContext.namespace.registerComposer(new COMContents.NormalizeRichTexts);

  COMContext.namespace.registerComposer(new COMContents.MergeByComposePolicy);

  COMContext.namespace.registerComposer(new COMRoot.RootAvoidEmpty);

  module.exports = COMContext;

}).call(this);

}
GlobalContext.setModule("vincent/com/context.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/cursor.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMCursor, COMCursorState, COMPath, COMTravelPolicy, CaretUISuggesterTrait, ConductableTrait, CursorActions, CursorCommands, Errors, EventEmitter, IdenticalCursorTrasportable, InputSuggesterTrait, PointableTrait, Teleportable, Trait, TrapableTrait, WalkableTrait, Walker, WalkerRootFirst,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Walker = require("./helper/walker");

  WalkerRootFirst = Walker.WalkerRootFirst;

  COMPath = require("./path");

  Errors = require("./errors");

  EventEmitter = (require("./events")).EventEmitter;

  COMTravelPolicy = require("./travelPolicy");

  Trait = require("./helper/trait");

  COMCursor = (function(superClass) {
    extend(COMCursor, superClass);

    COMCursor.index = 1000;

    function COMCursor(context, option1) {
      this.context = context;
      this.option = option1 != null ? option1 : {};
      COMCursor.__super__.constructor.call(this);
      new WalkableTrait(this);
      new ConductableTrait(this);
      new CaretUISuggesterTrait(this);
      new InputSuggesterTrait(this);
      new TrapableTrait(this);
      new PointableTrait(this);
      new Teleportable(this);
      new IdenticalCursorTrasportable(this);
      this.id = (COMCursor.index++).toString();
      this.name = this.option.name || null;
      this.isShadow = this.option.isShadow || false;
      return;
    }

    COMCursor.prototype.destroy = function() {
      var ref;
      this.isDestroyed = true;
      if ((ref = this.anchor) != null) {
        if (typeof ref.deactivate === "function") {
          ref.deactivate();
        }
      }
      this.target = null;
      this.emit("destroyed");
      return true;
    };

    COMCursor.prototype.getPath = function() {
      var path;
      if (!this.anchor) {
        return null;
      }
      path = this.anchor.node.getPath();
      path.anchor = this.anchor.toJSON();
      return path;
    };

    COMCursor.prototype.getCurrentPath = function() {
      var path;
      if (!this.target) {
        return null;
      }
      path = new COMPath(this.target);
      return path;
    };

    COMCursor.prototype.toJSON = function() {
      var json;
      if (!this.target) {
        return null;
      }
      json = {
        path: this.getCurrentPath().toJSON() || null,
        anchor: this.anchor.toJSON()
      };
      return json;
    };

    COMCursor.prototype.setByJSON = function(json) {
      if (json == null) {
        json = {};
      }
      return this.setByPath(new COMPath(json.path) || [], json.anchor || null);
    };

    COMCursor.prototype.setByPath = function(path, anchor) {
      var child;
      if (!path) {
        return false;
      }
      child = this.context.root.getChildByPath(path);
      return this.pointAt(child, {
        anchor: anchor
      });
    };

    COMCursor.prototype.setCursorByDOMRegion = function(region) {
      var com, lastPointable, node, offset, target;
      node = region.node;
      offset = region.index;
      if (node instanceof Text) {
        target = node.parentElement;
      } else {
        target = node;
      }
      while (target && target !== this.context.root.el) {
        if (!target.com) {
          target = target.parentElement;
          continue;
        }
        com = target.com;
        break;
      }
      if (!com) {
        return false;
      }
      lastPointable = null;
      while (com.parent) {
        if (com.anchor) {
          lastPointable = com;
          break;
        }
        com = com.parent;
      }
      if (!lastPointable) {
        return false;
      }
      this.setByPath(lastPointable.getPath());
      this.anchor.setByDOM(node, offset);
      return true;
    };

    COMCursor.prototype.clone = function() {
      var cursor;
      cursor = this.context.createCursor();
      cursor.pointAtAnchor(this.anchor);
      return cursor;
    };

    COMCursor.prototype.getData = function() {
      return {
        context: this.context,
        anchor: this.anchor.clone()
      };
    };

    COMCursor.prototype.fromData = function(data) {
      this.pointAtAnchor(data.anchor);
      return this;
    };

    COMCursor.prototype.equal = function(cursor) {
      var ref;
      return cursor.context === this.context && ((ref = cursor.anchor) != null ? ref.equal(this.anchor) : void 0);
    };

    return COMCursor;

  })(EventEmitter);

  TrapableTrait = (function(superClass) {
    extend(TrapableTrait, superClass);

    function TrapableTrait() {
      return TrapableTrait.__super__.constructor.apply(this, arguments);
    }

    TrapableTrait.prototype.getTrapTop = function(target) {
      var node;
      node = target || this.target;
      while (node && !node.trapPolicy) {
        node = node.parent;
      }
      if (node && node.trapPolicy) {
        return node;
      }
      return null;
    };

    TrapableTrait.prototype.trapIn = function(node, option) {
      var action, current, method;
      if (!node.trapPolicy || node.trapPolicy.trap === "ignore") {
        return false;
      }
      current = this.getTrapTop();
      if (current && !current.contains(node)) {
        Logger.error("invalid trap inhirency");
        return false;
      }
      this.walkerRootFirst.setTop(node);
      if (node.anchor) {
        if (option.direction === "left") {
          action = "head";
        } else {
          action = "tail";
        }
        this.pointAt(node, {
          actions: [action]
        });
        return true;
      }
      this.walkerRootFirst.setNode(node);
      if (option.direction === "left") {
        method = "next";
        action = "head";
      } else {
        method = "previous";
        action = "tail";
      }
      if (this.walkerRootFirst[method](function(item) {
        return item.anchor;
      })) {
        this.pointAt(this.walkerRootFirst.node, {
          actions: [action]
        });
        return true;
      }
      this.pointAt(node.parent, {
        trapTarget: node,
        trapOutDirection: option.direction
      });
      return false;
    };

    return TrapableTrait;

  })(Trait);

  Teleportable = (function(superClass) {
    extend(Teleportable, superClass);

    function Teleportable() {
      return Teleportable.__super__.constructor.apply(this, arguments);
    }

    Teleportable.prototype.teleportStartAnchor = null;

    Teleportable.prototype.startTeleport = function() {
      if (!this.anchor) {
        return;
      }
      this.isTeleporting = true;
      return this.teleportStartAnchor = this.anchor.clone();
    };

    Teleportable.prototype.endTeleport = function() {
      if (!this.teleportStartAnchor) {
        return;
      }
      this.isTeleporting = false;
      if (!this.teleportStartAnchor.equal(this.anchor)) {
        this.emit("move");
      }
      return this.teleportStartAnchor = null;
    };

    return Teleportable;

  })(Trait);

  PointableTrait = (function(superClass) {
    extend(PointableTrait, superClass);

    function PointableTrait() {
      return PointableTrait.__super__.constructor.apply(this, arguments);
    }

    PointableTrait.prototype.rev = 0;

    PointableTrait.prototype.initialize = function() {
      return this.__defineGetter__("version", (function(_this) {
        return function() {
          var ref;
          return _this.rev + ":" + (((ref = _this.anchor) != null ? ref.rev : void 0) || "");
        };
      })(this));
    };

    PointableTrait.prototype.pointAtRune = function(rune) {
      var anchor, parent, ref;
      if (!rune) {
        return false;
      }
      parent = rune.parent;
      anchor = (ref = parent.anchor) != null ? ref.clone() : void 0;
      if (!anchor) {
        return false;
      }
      anchor.pointAt(rune);
      return this.pointAtAnchor(anchor);
    };

    PointableTrait.prototype.pointAtAnchor = function(anchor) {
      return this.pointAt(anchor.node, {
        anchor: anchor.toJSON()
      });
    };

    PointableTrait.prototype.pointAt = function(node, option) {
      var action, actionResult, i, len, ref, ref1, ref2, ref3, result, walker;
      if (option == null) {
        option = {};
      }
      if (node.context !== this.context) {
        throw new Error("can't point at node not belongs to cursor.context");
      }
      if (this.isDestroyed) {
        throw new Error("the cursor is already destroyed");
      }
      if (!node.anchor) {
        if (option.trapTarget) {
          Logger.error("trap out to a non pointable node", node);
          return false;
        }
        walker = new WalkerRootFirst(this.context);
        walker.setTop(node);
        walker.setNode(node);
        result = walker.next(function(item) {
          return item.anchor;
        });
        if (!result) {
          Logger.error("can't point to target", node, "without anchor");
          return false;
        }
        node = walker.node;
        if (option.anchor) {
          Logger.error("indirect point at, ignore anchor option");
          option.anchor = null;
        }
      }
      this.walkerRootFirst.setTop(this.getTrapTop(node));
      if ((ref = this.anchor) != null) {
        ref.deactivate({
          replacementCursor: this,
          replacementAnchor: node.anchor
        });
      }
      if (this.anchor) {
        this.anchor.stopListenBy(this);
      }
      this.target = node;
      this.anchor = this.target.anchor.clone();
      if (option.index) {
        this.anchor.index = option.index;
      }
      if ((ref1 = this.anchor) != null) {
        ref1.listenBy(this, "move", (function(_this) {
          return function() {
            if (_this.isTeleporting) {
              return;
            }
            return _this.emit("move");
          };
        })(this));
      }
      if ((ref2 = this.anchor) != null) {
        ref2.activate(this);
      }
      if (option.anchor) {
        this.anchor.fromJSON(option.anchor);
      }
      if (option.trapTarget) {
        this.anchor.trapRecover(option.trapTarget, option.trapOutDirection);
      }
      if (option.actions) {
        ref3 = option.actions;
        for (i = 0, len = ref3.length; i < len; i++) {
          action = ref3[i];
          if (typeof action === "string") {
            actionResult = this.conduct(action);
          } else {
            actionResult = this.conduct(action.name, action.value);
          }
        }
      }
      if (!this.isTeleporting) {
        this.emit("move");
      }
      this.rev += 1;
      if (typeof actionResult === "boolean") {
        return actionResult;
      }
      return true;
    };

    return PointableTrait;

  })(Trait);

  WalkableTrait = (function(superClass) {
    extend(WalkableTrait, superClass);

    function WalkableTrait() {
      return WalkableTrait.__super__.constructor.apply(this, arguments);
    }

    WalkableTrait.prototype.initialize = function() {
      this.walkerRootFirst = new WalkerRootFirst(this.context);
      return this.walker = new Walker(this.context);
    };

    WalkableTrait.prototype.begin = function() {
      var has;
      this.walkerRootFirst.setNode(this.context.root);
      has = this.walkerRootFirst.next(function(node) {
        return node.anchor;
      });
      if (!has) {
        return false;
      }
      return this.pointAt(this.walkerRootFirst.node, {
        actions: ["head"]
      });
    };

    WalkableTrait.prototype.end = function() {
      var has;
      this.walkerRootFirst.setNode(this.context.root);
      has = this.walkerRootFirst.previous(function(node) {
        return node.anchor;
      });
      if (!has) {
        return false;
      }
      return this.pointAt(this.walkerRootFirst.node, {
        actions: ["tail"]
      });
    };

    WalkableTrait.prototype.next = function(option) {
      var top;
      this.walkerRootFirst.setNode(this.target);
      this.walkerRootFirst.skipChildOnce = true;
      if (this.walkerRootFirst.next(function(node) {
        return node.anchor;
      })) {
        this.walkerRootFirst.skipChildOnce = false;
        return this.pointAt(this.walkerRootFirst.node, option);
      }
      top = this.getTrapTop(this.target);
      if (top) {
        this.walkerRootFirst.setTop(this.getTrapTop(top.parent) || null);
        if (option == null) {
          option = {};
        }
        option.actions = [];
        option.trapOutDirection = "right";
        option.trapTarget = top;
        return this.pointAt(top.parent, option);
      }
      return false;
    };

    WalkableTrait.prototype.previous = function(option) {
      var top;
      this.walkerRootFirst.setNode(this.target);
      this.walkerRootFirst.skipChildOnce = true;
      if (this.walkerRootFirst.previous(function(node) {
        return node.anchor;
      })) {
        this.walkerRootFirst.skipChildOnce = false;
        return this.pointAt(this.walkerRootFirst.node, option);
      }
      top = this.getTrapTop();
      if (top) {
        this.walkerRootFirst.setTop(this.getTrapTop(top.parent) || null);
        if (option == null) {
          option = {};
        }
        option.actions = [];
        option.trapOutDirection = "left";
        option.trapTarget = top;
        return this.pointAt(top.parent, option);
      }
      return false;
    };

    return WalkableTrait;

  })(Trait);

  CaretUISuggesterTrait = (function(superClass) {
    extend(CaretUISuggesterTrait, superClass);

    function CaretUISuggesterTrait() {
      return CaretUISuggesterTrait.__super__.constructor.apply(this, arguments);
    }

    CaretUISuggesterTrait.prototype.getBoundary = function() {
      var boundary, ref;
      boundary = ((ref = this.anchor) != null ? ref.getCorrespondingBoundary() : void 0) || null;
      return boundary;
    };

    CaretUISuggesterTrait.prototype.getVisualPosition = function() {
      var ref;
      return ((ref = this.anchor) != null ? ref.getVisualPosition() : void 0) || null;
    };

    CaretUISuggesterTrait.prototype.getStyle = function() {
      var ref;
      return ((ref = this.anchor) != null ? ref.getCaretStyle() : void 0) || null;
    };

    return CaretUISuggesterTrait;

  })(Trait);

  InputSuggesterTrait = (function(superClass) {
    extend(InputSuggesterTrait, superClass);

    function InputSuggesterTrait() {
      return InputSuggesterTrait.__super__.constructor.apply(this, arguments);
    }

    InputSuggesterTrait.prototype.getSurroundingText = function(count) {
      var ref;
      return ((ref = this.anchor) != null ? typeof ref.getSurroundingText === "function" ? ref.getSurroundingText(count) : void 0 : void 0) || {
        before: "",
        after: ""
      };
    };

    InputSuggesterTrait.prototype.getSurroundingWord = function(count) {
      var ref;
      return ((ref = this.anchor) != null ? ref.getSurroundingWord(count) : void 0) || {
        before: "",
        after: ""
      };
    };

    InputSuggesterTrait.prototype.matchingBeforeText = function(string) {
      var ref;
      return (ref = this.anchor) != null ? ref.matchingBeforeText(string) : void 0;
    };

    InputSuggesterTrait.prototype.IMEReplace = function(before, after) {
      var value;
      if (this.context.isReadonly) {
        this.context.emit("editAttemp");
        return false;
      }
      value = false;
      this.context.transact((function(_this) {
        return function() {
          var ref;
          return value = (ref = _this.anchor) != null ? ref.IMEReplace(before, after) : void 0;
        };
      })(this));
      return value;
    };

    return InputSuggesterTrait;

  })(Trait);

  ConductableTrait = (function(superClass) {
    extend(ConductableTrait, superClass);

    function ConductableTrait() {
      return ConductableTrait.__super__.constructor.apply(this, arguments);
    }

    ConductableTrait.prototype.initialize = function() {
      this.state = new COMCursorState(this);
      this.actions = new CursorActions(this);
      return this.commands = new CursorCommands(this);
    };

    ConductableTrait.prototype.conduct = function() {
      var args, ref, ref1, result;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      result = (ref = this.actions).conduct.apply(ref, args);
      if (result) {
        return true;
      }
      return (ref1 = this.commands).exec.apply(ref1, args);
    };

    return ConductableTrait;

  })(Trait);

  CursorActions = (function() {
    function CursorActions(cursor1) {
      this.cursor = cursor1;
      this.defaultPolicy = new COMTravelPolicy();
    }

    CursorActions.prototype.conduct = function(name, value) {
      var anchor, isEditAction, policy, result, target;
      if (name.toLowerCase().indexOf("delete") >= 0) {
        isEditAction = true;
      }
      if (isEditAction) {
        this.cursor.captureIdenticalCursors();
      }
      target = this.cursor.target;
      anchor = this.cursor.anchor;
      if (!name) {
        return false;
      }
      if (!target) {
        return false;
      }
      if (typeof this[name] !== "function") {
        return false;
      }
      if (!anchor) {
        return false;
      }
      policy = target.travelPolicy || this.defaultPolicy;
      if ((!anchor[name] && !this[name]) || policy[name] === "ignore") {
        return false;
      }
      result = this[name](target, anchor, policy, value);
      if (isEditAction) {
        this.cursor.transportIdenticalCursors();
      }
      return result;
    };

    CursorActions.prototype.previous = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.cursor).previous.apply(ref, args);
    };

    CursorActions.prototype.next = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.cursor).next.apply(ref, args);
    };

    CursorActions.prototype.nextRune = function(target, anchor, policy, option) {
      var result;
      if (option == null) {
        option = {};
      }
      result = anchor.nextRune(option);
      if (result) {
        return true;
      }
      this.cursor.state.save();
      if (this.next({
        actions: [
          "head", {
            name: "nextRune",
            value: {
              fresh: true
            }
          }
        ]
      })) {
        this.cursor.state.discard();
        return true;
      } else {
        this.cursor.state.restore();
        return false;
      }
    };

    CursorActions.prototype.previousRune = function(target, anchor, policy, option) {
      var result;
      result = anchor.previousRune(option);
      if (result) {
        return true;
      }
      this.cursor.state.save();
      if (this.previous({
        actions: [
          "tail", {
            name: "previousRune",
            value: {
              fresh: true
            }
          }
        ]
      })) {
        this.cursor.state.discard();
        return true;
      } else {
        this.cursor.state.restore();
        return false;
      }
    };

    CursorActions.prototype.forwardChar = function(target, anchor, policy) {
      var result;
      result = anchor.forwardChar();
      if (result) {
        if (anchor.isTail() && policy.tailBoundary === "pass") {
          this.next({
            actions: ["head"]
          });
        }
        return true;
      }
      if (anchor.isTail() && policy.tailBoundary === "pass") {
        return this.next({
          actions: ["head"]
        });
      }
      if (policy.forwardBypassed === "handover") {
        return this.next({
          actions: ["head", "forwardChar"]
        });
      } else if (policy.forwardBypassed === "bypass") {
        return this.next({
          actions: ["head"]
        });
      } else {
        return false;
      }
    };

    CursorActions.prototype.applyTailBoundary = function(target, anchor, policy) {
      if (anchor.isTail() && policy.tailBoundary === "pass") {
        this.next({
          actions: ["head", "applyTailBoundary"]
        });
        return true;
      }
      return false;
    };

    CursorActions.prototype.backwardChar = function(target, anchor, policy) {
      var result;
      result = anchor.backwardChar();
      if (result) {
        return true;
      }
      if (policy.backwardBypassed === "handover") {
        return this.previous({
          actions: ["tail", "backwardChar"]
        });
      } else if (policy.backwardBypassed === "bypass") {
        return this.previous({
          actions: ["tail"]
        });
      } else {
        return false;
      }
    };

    CursorActions.prototype.upwardChar = function(target, anchor, policy) {
      return anchor.upwardChar();
    };

    CursorActions.prototype.downwardChar = function(target, anchor, policy) {
      return anchor.downwardChar();
    };

    CursorActions.prototype.forwardWord = function(target, anchor, policy) {
      var result;
      result = anchor.forwardWord();
      if (result) {
        if (anchor.isTail() && policy.tailBoundary === "pass") {
          this.next({
            actions: ["head"]
          });
        }
        return true;
      }
      if (policy.forwardBypassed === "handover") {
        return this.next({
          actions: ["head", "forwardWord"]
        });
      } else if (policy.forwardBypassed === "bypass") {
        return this.next({
          actions: ["head"]
        });
      }
    };

    CursorActions.prototype.backwardWord = function(target, anchor, policy) {
      var result;
      result = anchor.backwardWord();
      if (result) {
        return true;
      }
      if (policy.backwardBypassed === "handover") {
        return this.previous({
          actions: ["tail", "backwardWord"]
        });
      } else if (policy.backwardBypassed === "bypass") {
        return this.previous({
          actions: ["tail"]
        });
      }
    };

    CursorActions.prototype.deleteWord = function(target, anchor, policy) {
      var result;
      result = anchor.backwardWord();
      if (result) {
        return true;
      }
      if (policy.backwardBypassed === "handover") {
        return this.previous({
          actions: ["tail", "backwardWord"]
        });
      } else if (policy.backwardBypassed === "bypass") {
        return this.previous({
          actions: ["tail"]
        });
      }
    };

    CursorActions.prototype.head = function(target, anchor, policy) {
      return anchor.head();
    };

    CursorActions.prototype.tail = function(target, anchor, policy) {
      return anchor.tail();
    };

    CursorActions.prototype.deleteLineBeforeCursor = function(target, anchor, policy, option) {
      var result;
      result = typeof anchor.deleteLineBeforeAnchor === "function" ? anchor.deleteLineBeforeAnchor() : void 0;
      if (result) {
        return true;
      }
      if (policy.deleteBypassed === "handover") {
        return this.previous({
          actions: ["tail", "deleteLineBeforeCursor"]
        });
      } else if (policy.deleteBypassed === "bypass") {
        return this.previous({
          actions: ["tail", "deleteLineBeforeCursor"]
        });
      } else if (policy.deleteBypassed === "merge") {
        if (!this.previous({
          actions: ["tail"]
        })) {
          return false;
        }
        if (this.cursor.target.mergeContentString && target.toContentString) {
          this.cursor.target.mergeContentString(target.toContentString(), target);
          target.remove();
        }
        return false;
      }
      return false;
    };

    CursorActions.prototype.deleteChar = function(target, anchor, policy) {
      var result;
      result = anchor.deleteChar();
      if (result) {
        return true;
      }
      if (policy.deleteBypassed === "handover") {
        return this.previous({
          actions: ["tail", "deleteChar"]
        });
      } else if (policy.deleteBypassed === "bypass") {
        return this.previous({
          actions: ["tail", "deleteChar"]
        });
      } else if (policy.deleteBypassed === "merge") {
        if (!this.previous({
          actions: ["tail"]
        })) {
          return false;
        }
        if (this.cursor.target.mergeContentString && target.toContentString) {
          this.cursor.target.mergeContentString(target.toContentString(), target);
          target.remove();
        }
        return false;
      }
      return false;
    };

    CursorActions.prototype.startOfLine = function(target, anchor, policy) {
      var result;
      result = typeof anchor.startOfLine === "function" ? anchor.startOfLine() : void 0;
      if (result) {
        return true;
      }
      if (policy.startOfLine === "boundary") {
        anchor.index = 0;
        return true;
      }
      if (policy.startOfLine === "handover") {
        if (this.previous({
          actions: ["tail", "startOfLine"]
        })) {
          return true;
        } else {
          return this.cursor.begin();
        }
      }
      return false;
    };

    CursorActions.prototype.endOfLine = function(target, anchor, policy) {
      var result;
      result = typeof anchor.endOfLine === "function" ? anchor.endOfLine() : void 0;
      if (result) {
        return true;
      }
      if (policy.endOfLine === "boundary") {
        anchor.index = target.length;
        return true;
      }
      if (policy.endOfLine === "handover") {
        if (this.next({
          actions: ["endOfLine"]
        })) {
          return true;
        } else {
          return this.cursor.end();
        }
      }
      return false;
    };

    CursorActions.prototype.deleteWord = function(target, anchor, policy) {
      var result;
      result = anchor.deleteWord();
      if (result) {
        return true;
      }
      if (policy.deleteBypassed === "handover") {
        return this.previous({
          actions: ["tail", "deleteWord"]
        });
      } else if (policy.deleteBypassed === "bypass") {
        return this.previous({
          actions: ["tail", "deleteWord"]
        });
      } else if (policy.deleteBypassed === "merge") {
        if (!this.previous({
          actions: ["tail"]
        })) {
          return false;
        }
        if (this.cursor.target.mergeContentString && target.toContentString) {
          this.cursor.target.mergeContentString(target.toContentString(), target);
          target.remove();
        }
        return false;
      }
      return false;
    };

    CursorActions.prototype.trigger = function() {
      var anchor, args, policy, result, target;
      target = arguments[0], anchor = arguments[1], policy = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
      result = anchor.trigger.apply(anchor, args);
      if (result) {
        this.cursor.emit("trigger");
      }
      return result;
    };

    CursorActions.prototype.write = function(target, anchor, policy, value) {
      return anchor.write(value);
    };

    return CursorActions;

  })();

  CursorCommands = (function() {
    function CursorCommands(cursor1) {
      this.cursor = cursor1;
    }

    CursorCommands.prototype.exec = function() {
      var name, node, params;
      name = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!this.cursor.target) {
        return false;
      }
      node = this.cursor.target;
      while (node) {
        if (typeof node.exec === "function" ? node.exec.apply(node, [name].concat(slice.call(params))) : void 0) {
          return true;
        }
        node = node.parent;
      }
      return false;
    };

    return CursorCommands;

  })();

  COMCursorState = (function() {
    function COMCursorState(cursor1) {
      this.cursor = cursor1;
      this.states = [];
    }

    COMCursorState.prototype.save = function() {
      return this.states.push(this.cursor.clone());
    };

    COMCursorState.prototype.discard = function() {
      var cursor;
      cursor = this.states.pop();
      return cursor.destroy();
    };

    COMCursorState.prototype.restore = function() {
      var cursor;
      cursor = this.states.pop();
      if (cursor && cursor.anchor) {
        this.cursor.pointAtAnchor(cursor.anchor);
      }
      return cursor.destroy();
    };

    return COMCursorState;

  })();

  IdenticalCursorTrasportable = (function(superClass) {
    extend(IdenticalCursorTrasportable, superClass);

    function IdenticalCursorTrasportable() {
      return IdenticalCursorTrasportable.__super__.constructor.apply(this, arguments);
    }

    IdenticalCursorTrasportable.prototype.friendCursors = null;

    IdenticalCursorTrasportable.prototype.initialize = function() {
      return this.friendCursors = [];
    };

    IdenticalCursorTrasportable.prototype.captureIdenticalCursors = function() {
      var cursor, id, ref;
      this.friendCursors.length = 0;
      ref = this.context.cursors;
      for (id in ref) {
        cursor = ref[id];
        if (cursor !== this && cursor.equal(this)) {
          this.friendCursors.push(cursor);
        }
      }
      return true;
    };

    IdenticalCursorTrasportable.prototype.transportIdenticalCursors = function() {
      var cursor, i, len, ref;
      ref = this.friendCursors;
      for (i = 0, len = ref.length; i < len; i++) {
        cursor = ref[i];
        cursor.pointAtAnchor(this.anchor);
      }
      return this.friendCursors.length = 0;
    };

    return IdenticalCursorTrasportable;

  })(Trait);

  module.exports = COMCursor;

}).call(this);

}
GlobalContext.setModule("vincent/com/cursor.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/decoration.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Decoration, DecorationMaintainer, MID, Operation, RegExpDecorationMaintainer, exports,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Operation = require("./operation");

  DecorationMaintainer = (function() {
    function DecorationMaintainer() {}

    DecorationMaintainer.prototype.compute = function() {
      return [];
    };

    DecorationMaintainer.prototype.apply = function() {};

    return DecorationMaintainer;

  })();

  RegExpDecorationMaintainer = (function(superClass) {
    extend(RegExpDecorationMaintainer, superClass);

    function RegExpDecorationMaintainer() {
      RegExpDecorationMaintainer.__super__.constructor.call(this);
      if (this.reg == null) {
        this.reg = null;
      }
      if (this.classes == null) {
        this.classes = [];
      }
      if (this.option == null) {
        this.option = {};
      }
      this.parts = this.option.parts || [];
    }

    RegExpDecorationMaintainer.prototype.getMatchRegion = function(contentString) {
      var backwardFix, forwardFix, match, ref, ref1, results;
      if (!this.reg) {
        return;
      }
      this.reg.lastIndex = 0;
      results = [];
      backwardFix = ((ref = this.option.backwardAssert) != null ? ref.length : void 0) || 0;
      forwardFix = ((ref1 = this.option.forwardAssert) != null ? ref1.length : void 0) || 0;
      while (match = this.reg.exec(contentString)) {
        if (match[0].length === 0) {
          break;
        }
        results.push([match.index + backwardFix, match.index + match[0].length - forwardFix, match[0], match]);
      }
      return results;
    };

    RegExpDecorationMaintainer.prototype.compute = function(contentString) {
      var content, coreResults, i, item, len, results;
      results = [];
      coreResults = (typeof this.getMatchRegion === "function" ? this.getMatchRegion(contentString) : void 0) || [];
      for (i = 0, len = coreResults.length; i < len; i++) {
        item = coreResults[i];
        if (this.parts.length > 0) {
          content = contentString.slice(item[0], item[1]);
          results.push.apply(results, this.computePart(content, item[0]));
        }
        results.push(item);
      }
      return results.map((function(_this) {
        return function(info) {
          return (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(Decoration, [_this].concat(slice.call(info)), function(){});
        };
      })(this));
    };

    RegExpDecorationMaintainer.prototype.apply = function(dec, el) {
      var ref, ref1, ref2, ref3;
      (ref = el.classList).add.apply(ref, this.classes);
      if ((ref1 = dec.detail) != null ? ref1.classes : void 0) {
        return (ref3 = el.classList).add.apply(ref3, (ref2 = dec.detail) != null ? ref2.classes : void 0);
      }
    };

    RegExpDecorationMaintainer.prototype.cancel = function(dec, el) {
      var i, j, len, len1, name, ref, ref1, ref2, ref3, results1;
      ref = this.classes;
      for (i = 0, len = ref.length; i < len; i++) {
        name = ref[i];
        el.classList.remove(name);
      }
      if ((ref1 = dec.detail) != null ? ref1.classes : void 0) {
        ref3 = (ref2 = dec.detail) != null ? ref2.classes : void 0;
        results1 = [];
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          name = ref3[j];
          results1.push(el.classList.remove(name));
        }
        return results1;
      }
    };

    RegExpDecorationMaintainer.prototype.computePart = function(content, offset) {
      var i, len, match, part, ref, results;
      results = [];
      ref = this.parts;
      for (i = 0, len = ref.length; i < len; i++) {
        part = ref[i];
        part.reg.lastIndex = 0;
        while (match = part.reg.exec(content)) {
          if (match[0].length === 0) {
            break;
          }
          results.push([match.index + offset, match.index + offset + match[0].length, part]);
        }
      }
      return results;
    };

    return RegExpDecorationMaintainer;

  })(DecorationMaintainer);

  Decoration = (function() {
    function Decoration(maintainer, start1, end1, detail) {
      var ref;
      this.maintainer = maintainer;
      this.start = start1 != null ? start1 : 0;
      this.end = end1 != null ? end1 : 0;
      this.detail = detail;
      this.length = this.end - this.start;
      this.mid = (ref = this.maintainer) != null ? ref.id : void 0;
    }

    Decoration.prototype.apply = function(el) {
      return this.maintainer.apply(this, el);
    };

    Decoration.prototype.cancel = function(el) {
      return this.maintainer.cancel(this, el);
    };

    Decoration.prototype.clone = function() {
      return new Decoration(this.maintainer, this.start, this.end, this.detail);
    };

    Decoration.prototype.split = function(index) {
      var next;
      next = this.clone();
      next.start = index;
      this.end = index;
      this.length = this.end - this.start;
      return next;
    };

    Decoration.prototype.shift = function(unit) {
      this.start += unit;
      this.end += unit;
      return this;
    };

    Decoration.prototype.equal = function(target) {
      return target.mid === this.mid && target.start === this.start && target.end === this.end;
    };

    return Decoration;

  })();

  Decoration.PairDecorationMaintainer = (function(superClass) {
    extend(PairDecorationMaintainer, superClass);

    function PairDecorationMaintainer() {
      PairDecorationMaintainer.__super__.constructor.call(this);
      this.rules = [];
    }

    PairDecorationMaintainer.prototype.compute = function(cs) {
      var breakChar, char, close, i, index, item, j, len, ref, ref1, ref2, rule, start;
      this.results = [];
      this.stack = [];
      this.offset = 0;
      this.enterCount = 0;
      breakChar = "\uE1F8";
      while (this.offset < cs.length) {
        close = false;
        start = false;
        char = cs[this.offset];
        if (char === breakChar) {
          this.offset += 1;
          this.stack.length = 0;
          continue;
        }
        if (char === "\n") {
          this.enterCount += 1;
          this.offset += 1;
          if (this.enterCount >= 1) {
            this.enterCount = 0;
            this.stack.length = 0;
          }
          continue;
        } else {
          this.enterCount = 0;
        }
        ref = this.stack;
        for (index = i = ref.length - 1; i >= 0; index = i += -1) {
          item = ref[index];
          if (this.strcmp(cs, this.offset, item.right)) {
            this.stack.length = index;
            this.offset += item.right.length;
            item.end = this.offset;
            if (item.end - item.start === item.left.length + item.right.length) {
              continue;
              item.empty = true;
            }
            (ref1 = this.results).push.apply(ref1, this.createMatchingDecoration(cs, item));
            close = true;
            break;
          }
        }
        if (close) {
          continue;
        }
        ref2 = this.rules;
        for (j = 0, len = ref2.length; j < len; j++) {
          rule = ref2[j];
          if (this.strcmp(cs, this.offset, rule.left)) {
            this.stack.push({
              start: this.offset,
              rule: rule,
              right: rule.right,
              left: rule.left
            });
            this.offset += rule.left.length;
            start = true;
            break;
          }
        }
        if (start) {
          continue;
        }
        this.offset += 1;
      }
      return this.results;
    };

    PairDecorationMaintainer.prototype.strcmp = function(string, offset, match) {
      var char, i, index, len;
      if (match.length === 0) {
        return false;
      }
      for (index = i = 0, len = match.length; i < len; index = ++i) {
        char = match[index];
        if (string[offset + index] !== char) {
          return false;
        }
      }
      return true;
    };

    PairDecorationMaintainer.prototype.createMatchingDecoration = function(cs, result) {
      var l1, l2, rule;
      l1 = result.left.length;
      l2 = result.right.length;
      rule = result.rule;
      return [
        new Decoration.PairDecoration(this, result.start, result.start + l1, {
          rule: rule,
          isStart: true,
          empty: result.empty
        }), new Decoration.PairDecoration(this, result.start + l1, result.end - l2, {
          rule: rule,
          empty: result.empty
        }), new Decoration.PairDecoration(this, result.end - l2, result.end, {
          rule: rule,
          isEnd: true,
          empty: result.empty
        })
      ];
    };

    PairDecorationMaintainer.prototype.register = function(left, right, info) {
      var index, rid;
      if (info == null) {
        info = {};
      }
      rid = Decoration.allocateId();
      index = this.rules.length;
      return this.rules.push({
        left: left,
        right: right,
        rid: rid,
        index: index,
        info: info
      });
    };

    return PairDecorationMaintainer;

  })(DecorationMaintainer);

  Decoration.PairDecoration = (function(superClass) {
    extend(PairDecoration, superClass);

    function PairDecoration() {
      return PairDecoration.__super__.constructor.apply(this, arguments);
    }

    PairDecoration.prototype.clone = function() {
      return new Decoration.PairDecoration(this.maintainer, this.start, this.end, this.detail);
    };

    PairDecoration.prototype.apply = function(el) {
      var className, end, i, len, ref, start;
      ref = this.detail.rule.info.classNames || [];
      for (i = 0, len = ref.length; i < len; i++) {
        className = ref[i];
        el.classList.add(className);
      }
      if (this.detail.empty) {
        el.classList.add("com-dec-empty");
      }
      if (this.detail.isStart) {
        if (start = this.detail.rule.startDecorator) {
          return el.classList.add(start);
        } else {
          return el.classList.add("com-dec-pair-start");
        }
      } else if (this.detail.isEnd) {
        if (end = this.detail.rule.endDecorator) {
          return el.classList.add(end);
        } else {
          return el.classList.add("com-dec-pair-end");
        }
      }
    };

    PairDecoration.prototype.cancel = function(el) {
      var className, i, len, ref, results1;
      if (this.detail.empty) {
        el.classList.remove("com-dec-empty");
      }
      ref = this.detail.rule.info.classNames || [];
      results1 = [];
      for (i = 0, len = ref.length; i < len; i++) {
        className = ref[i];
        results1.push(el.classList.remove(className));
      }
      return results1;
    };

    PairDecoration.prototype.equal = function(target) {
      var ref, ref1;
      return this.detail.rule.rid === (target != null ? (ref = target.detail) != null ? (ref1 = ref.rule) != null ? ref1.rid : void 0 : void 0 : void 0) && target.start === this.start && target.end === this.end;
    };

    return PairDecoration;

  })(Decoration);

  Decoration.ChangeDecorationOperation = (function(superClass) {
    extend(ChangeDecorationOperation, superClass);

    function ChangeDecorationOperation() {
      return ChangeDecorationOperation.__super__.constructor.apply(this, arguments);
    }

    ChangeDecorationOperation.prototype.name = "ChangeDecorationOperation";

    ChangeDecorationOperation.prototype.invoke = function() {
      var ref, ref1, ref2, text;
      text = this.target;
      this.option.oldDecorations = ((ref = text.decorations) != null ? typeof ref.slice === "function" ? ref.slice() : void 0 : void 0) || [];
      text.decorations = ((ref1 = this.option.decorations) != null ? typeof ref1.slice === "function" ? ref1.slice() : void 0 : void 0) || [];
      text.dirty = true;
      if ((ref2 = text.parent) != null) {
        ref2.dirty = true;
      }
      return true;
    };

    ChangeDecorationOperation.prototype.revoke = function() {
      var ref, ref1, text;
      text = this.target;
      text.decorations = ((ref = this.option.oldDecorations) != null ? typeof ref.slice === "function" ? ref.slice() : void 0 : void 0) || [];
      text.dirty = true;
      return (ref1 = text.parent) != null ? ref1.dirty = true : void 0;
    };

    ChangeDecorationOperation.prototype.describe = function() {
      return "make a decoration change to " + this.target.type;
    };

    return ChangeDecorationOperation;

  })(Operation.EditOperation);

  exports = Decoration;

  exports.DecorationMaintainer = DecorationMaintainer;

  MID = 0;

  exports.createRegExpMaintainer = function(name, reg, classes, option) {
    var CustomDecoratioMaintainer, Maintainer;
    if (option == null) {
      option = {};
    }
    Maintainer = CustomDecoratioMaintainer = (function(superClass) {
      extend(CustomDecoratioMaintainer, superClass);

      function CustomDecoratioMaintainer() {
        this.option = option || {};
        this.reg = reg;
        this.name = name;
        CustomDecoratioMaintainer.__super__.constructor.call(this);
      }

      return CustomDecoratioMaintainer;

    })(RegExpDecorationMaintainer);
    Maintainer.prototype.id = MID++;
    Maintainer.prototype.name = name;
    Maintainer.prototype.classes = classes;
    return Maintainer;
  };

  exports.allocateId = function() {
    return MID++;
  };

  module.exports = exports;

}).call(this);

}
GlobalContext.setModule("vincent/com/decoration.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/decorationPolicy.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMDecorationPolicy, COMPolicy,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMPolicy = require("./policy");

  COMDecorationPolicy = (function(superClass) {
    extend(COMDecorationPolicy, superClass);

    function COMDecorationPolicy(node) {
      this.node = node;
      COMDecorationPolicy.__super__.constructor.call(this, this.node);
    }

    COMDecorationPolicy.prototype.behavior = "default";

    return COMDecorationPolicy;

  })(COMPolicy);

  module.exports = COMDecorationPolicy;

}).call(this);

}
GlobalContext.setModule("vincent/com/decorationPolicy.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/element.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMContainer, COMContext, COMElement, COMRichText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMContext = require("./context");

  COMContainer = require("./container");

  COMRichText = require("./richText");

  COMElement = (function(superClass) {
    extend(COMElement, superClass);

    COMElement.prototype.type = "VoidElement";

    function COMElement(context, data) {
      this.context = context;
      this.data = data;
      COMElement.__super__.constructor.call(this, this.context, this.data);
    }

    return COMElement;

  })(COMContainer);

  module.exports = COMElement;

}).call(this);

}
GlobalContext.setModule("vincent/com/element.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/errors.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = require("../common/errors");

}).call(this);

}
GlobalContext.setModule("vincent/com/errors.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/events.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  exports.EventEmitter = Leaf.EventEmitter;

}).call(this);

}
GlobalContext.setModule("vincent/com/events.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/i18n.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = {
    UnknownRuneTitle: "No need to worry, your data should be safe. But your software might be outdated or missing some plugin, please contact service provider for help."
  };

}).call(this);

}
GlobalContext.setModule("vincent/com/i18n.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/index.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = {
    COMNode: require("./node"),
    COMContainer: require("./container"),
    COMComposer: require("./composer"),
    COMContext: require("./context"),
    COMCursor: require("./cursor"),
    COMDecoration: require("./decoration"),
    COMWalker: require("./helper/walker"),
    COMNamespace: require("./namespace"),
    COMOperation: require("./operation"),
    COMPath: require("./path"),
    COMPolicy: require("./policy"),
    COMRichText: require("./richText"),
    COMAnchor: require("./anchor"),
    COMText: require("./text"),
    COMRoot: require("./root"),
    COMRune: require("./rune"),
    COMSpell: require("./spell"),
    COMSelection: require("./selection"),
    COMTrapPolicy: require("./trapPolicy"),
    COMTravelPolicy: require("./travelPolicy"),
    COMContents: require("./contents"),
    COMNodeList: require("./helper/nodeList"),
    COMIntent: require("./intent"),
    COMVisualPosition: require("./visualPosition")
  };

}).call(this);

}
GlobalContext.setModule("vincent/com/index.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/intent.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMIntent, EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = (require("./events")).EventEmitter;

  COMIntent = (function(superClass) {
    extend(COMIntent, superClass);

    COMIntent.register = function(Intent, name) {
      name = name || Intent.prototype.name || Intent.name;
      return COMIntent.Intents[name] = Intent;
    };

    COMIntent.Intents = {};

    COMIntent.prototype.name = "VoidIntent";

    COMIntent.prototype.isCaptured = false;

    function COMIntent(context, name1, detail) {
      var prop, value;
      this.context = context;
      this.name = name1;
      if (detail == null) {
        detail = {};
      }
      for (prop in detail) {
        value = detail[prop];
        this[prop] = value;
      }
    }

    COMIntent.prototype.capture = function() {
      return this.isCaptured = true;
    };

    return COMIntent;

  })(EventEmitter);

  module.exports = COMIntent;

}).call(this);

}
GlobalContext.setModule("vincent/com/intent.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/namespace.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMComposer, COMNamespace, Errors,
    slice = [].slice;

  Errors = require("./errors");

  COMComposer = require("./composer");

  COMNamespace = (function() {
    function COMNamespace() {
      this.creators = {};
      this.decorations = [];
      this.spells = [];
      return this;
    }

    COMNamespace.prototype.registerDecoration = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.decorations).push.apply(ref, args);
    };

    COMNamespace.prototype.registerSpell = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.spells).push.apply(ref, args);
    };

    COMNamespace.prototype.registerComposer = function(name, composer) {
      var target;
      if (name instanceof COMComposer) {
        composer = name;
        name = composer.type;
      }
      target = this.creators[name];
      if (!target) {
        Logger.debug(target, name, composer, "///");
        Logger.error("invalid composer target " + name);
        return false;
      }
      if (target.composers == null) {
        target.composers = [];
      }
      return target.composers.push(composer);
    };

    COMNamespace.prototype.initContext = function(context) {
      var base, ctr, name, ref, results;
      ref = this.creators;
      results = [];
      for (name in ref) {
        ctr = ref[name];
        results.push(typeof (base = ctr.creator).initContext === "function" ? base.initContext(context) : void 0);
      }
      return results;
    };

    COMNamespace.prototype.registerNode = function(creator) {
      if (!creator.prototype.type) {
        Logger.error("invalid creator without Ctor::type");
        return false;
      }
      if (this.creators[creator.prototype.type]) {
        Logger.error("fail to register creator " + creator.prototype.type + ",type conflict", creator);
        return false;
      }
      return this.creators[creator.prototype.type] = {
        type: creator.prototype.type,
        creator: creator
      };
    };

    COMNamespace.prototype.sortOf = function(a, type) {
      var creator, ref, ref1;
      creator = (ref = this.creators[type]) != null ? ref.creator : void 0;
      if (typeof a === "string") {
        a = (ref1 = this.creators[a]) != null ? ref1.creator : void 0;
        if (a) {
          return a.prototype instanceof creator || a === creator;
        } else {
          return false;
        }
      }
      return (typeof creator === "function") && a instanceof creator;
    };

    COMNamespace.prototype.create = function() {
      var args, context, result, target, type;
      context = arguments[0], type = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      target = this.creators[type];
      if (!target) {
        Logger.error("Unregistered Node type " + type);
        return null;
      }
      result = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(target.creator, [context].concat(slice.call(args)), function(){});
      return result;
    };

    COMNamespace.prototype.compose = function(target) {
      var Ctor, composer, composers, i, len, ref, result;
      if (!target.root || target.root !== ((ref = target.context) != null ? ref.root : void 0)) {
        return false;
      }
      Ctor = this.creators[target.type];
      if (!Ctor) {
        throw new Errors.LogicError("compose unregistered element " + target.type);
      }
      composers = Ctor.composers || [];
      if (window.perf == null) {
        window.perf = new Perf();
      }
      for (i = 0, len = composers.length; i < len; i++) {
        composer = composers[i];
        perf.start(composer.constructor.name);
        result = composer.compose(target);
        perf.end(composer.constructor.name);
        if (result) {
          return true;
        }
        if (!target.root) {
          Logger.error("composer should return true if it changes it's target");
          return true;
        }
      }
      return false;
    };

    COMNamespace.prototype.clone = function() {
      var ns, prop;
      ns = new COMNamespace();
      for (prop in this.creators) {
        ns.creators[prop] = this.creators[prop];
      }
      ns.spells = this.spells.slice();
      ns.decorations = this.decorations.slice();
      return ns;
    };

    return COMNamespace;

  })();

  module.exports = COMNamespace;

}).call(this);

}
GlobalContext.setModule("vincent/com/namespace.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/node.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMNode, COMPath, Errors, EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Errors = require("./errors");

  EventEmitter = (require("./events")).EventEmitter;

  COMPath = require("./path");

  COMNode = (function(superClass) {
    extend(COMNode, superClass);

    COMNode.index = 1000;

    COMNode.prototype.type = "Node";

    function COMNode(context) {
      var base, base1;
      this.context = context;
      COMNode.__super__.constructor.call(this);
      this.composerBuffer = {};
      this._id = COMNode.index++;
      this.id = this._id;
      this.type = this.type;
      this.rev = 0;
      this.revisionMarks = {};
      this.parent = null;
      if (this.appearance == null) {
        this.appearance = {};
      }
      if ((base = this.appearance).tagName == null) {
        base.tagName = "div";
      }
      if ((base1 = this.appearance).classList == null) {
        base1.classList = ["com"];
      }
      this.parentAppearance = [];
      this.isCOMObject = true;
      this.pend();
      this.__defineGetter__("dirty", (function(_this) {
        return function() {
          var ref;
          if (!_this.cache) {
            return false;
          }
          return ((ref = _this.cache) != null ? ref.rev : void 0) !== _this.rev || false;
        };
      })(this));
      this.__defineSetter__("dirty", (function(_this) {
        return function(v) {
          var ref;
          if (v) {
            _this.rev += 1;
            if (_this.parent) {
              return _this.parent.dirty = true;
            }
          } else {
            return (ref = _this.cache) != null ? ref.rev = _this.rev : void 0;
          }
        };
      })(this));
      this.__defineGetter__("el", (function(_this) {
        return function() {
          var ref;
          return ((ref = _this.cache) != null ? ref.el : void 0) || null;
        };
      })(this));
      this.__defineSetter__("el", (function(_this) {
        return function(el) {
          if (el != null) {
            el.com = _this;
          }
          return _this.cache.el = el;
        };
      })(this));
      this.__defineGetter__("elAfter", (function(_this) {
        return function() {
          var ref;
          return ((ref = _this.cache) != null ? ref.elAfter : void 0) || null;
        };
      })(this));
      this.__defineSetter__("elAfter", (function(_this) {
        return function(elAfter) {
          if (elAfter != null) {
            elAfter.com = _this;
          }
          return _this.cache.elAfter = elAfter;
        };
      })(this));
      this.__defineGetter__("elBefore", (function(_this) {
        return function() {
          var ref;
          return ((ref = _this.cache) != null ? ref.elBefore : void 0) || null;
        };
      })(this));
      this.__defineSetter__("elBefore", (function(_this) {
        return function(elBefore) {
          if (elBefore != null) {
            elBefore.com = _this;
          }
          return _this.cache.elBefore = elBefore;
        };
      })(this));
      this.__defineGetter__("root", (function(_this) {
        return function() {
          return _this._root || null;
        };
      })(this));
      this.__defineSetter__("root", (function(_this) {
        return function(root) {
          var old;
          old = _this._root;
          _this._root = root;
          if ((!old || !old.withContext) && root && root.withContext) {
            if (typeof _this.onRootAvailable === "function") {
              _this.onRootAvailable();
            }
            return _this.emit("rootAvailable");
          } else if (!root && old && old.withContext) {
            if (typeof _this.onRootDispel === "function") {
              _this.onRootDispel();
            }
            return _this.emit("rootDispel");
          }
        };
      })(this));
      this.commands = {};
      this.anchors = [];
    }

    COMNode.prototype.setRevisionMark = function(mark) {
      return this.revisionMarks[mark] = this.rev;
    };

    COMNode.prototype.beforeMark = function(mark) {
      var ref;
      if (!((ref = this.cache) != null ? ref.rev : void 0)) {
        return true;
      }
      return this.cache.rev < this.revisionMarks[mark];
    };

    COMNode.prototype.setRenderContext = function(rc) {
      this.rc = rc;
      return this.cache = this.rc.cache(this.id);
    };

    COMNode.prototype.sortOf = function(type) {
      return this.context.namespace.sortOf(this, type);
    };

    COMNode.prototype.exec = function() {
      var base, name, params;
      name = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return typeof (base = this.commands)[name] === "function" ? base[name].apply(base, params) : void 0;
    };

    COMNode.prototype.registerCommand = function(name, fn) {
      return this.commands[name] = fn;
    };

    COMNode.prototype.getPath = function() {
      return COMPath.fromNode(this);
    };

    COMNode.prototype.customBaseRender = function() {
      return false;
    };

    COMNode.prototype.afterRender = function() {
      return this.cache.rev = this.rev;
    };

    COMNode.prototype.render = function(rc, option) {
      var _el;
      if (option == null) {
        option = {};
      }
      if (this.el && !option.force) {
        this.el.com = this;
        return;
      }
      _el = this.el;
      if (this.customBaseRender()) {
        this.el.com = this;
        return true;
      } else {
        this.el = document.createElement(this.appearance.tagName || "div");
        this.appearance.classList.filter(function(item) {
          return item;
        }).map((function(_this) {
          return function(name) {
            if (name) {
              return _this.el.classList.add(name);
            }
          };
        })(this));
      }
      if (_el && _el.parentElement) {
        _el.parentElement.replaceChild(this.el, _el);
      }
      return this.el.com = this;
    };

    COMNode.prototype.before = function(node) {
      var index;
      if (!this.parent) {
        return;
      }
      index = this.parent.indexOf(this);
      return this.parent.insert(index, node);
    };

    COMNode.prototype.after = function(node) {
      var index;
      if (!this.parent) {
        return;
      }
      index = this.parent.indexOf(this);
      return this.parent.insert(index + 1, node);
    };

    COMNode.prototype.previous = function(count) {
      var index;
      if (count == null) {
        count = 1;
      }
      if (!this.parent) {
        return null;
      }
      if (count === 0) {
        return this;
      }
      if (!count) {
        return null;
      }
      index = this.parent.indexOf(this);
      index -= count;
      if (index >= 0) {
        return this.parent.child(index);
      }
      return null;
    };

    COMNode.prototype.replaceBy = function(node) {
      var index, parent;
      if (!this.parent) {
        throw new Errors.LogicError("can't replace orphan node");
      }
      parent = this.parent;
      if (node.parent) {
        node.parent.removeChild(node);
      }
      index = parent.indexOf(this);
      parent.insert(index, node);
      return parent.removeChild(this);
    };

    COMNode.prototype.next = function(count) {
      var index;
      if (count == null) {
        count = 1;
      }
      if (!this.parent) {
        return null;
      }
      if (count === 0) {
        return this;
      }
      if (!count) {
        return null;
      }
      index = this.parent.indexOf(this);
      index += count;
      if (index < this.parent.children.length) {
        return this.parent.child(index);
      }
      return null;
    };

    COMNode.prototype.remove = function() {
      if (this.parent) {
        return this.parent.removeChild(this);
      }
    };

    COMNode.prototype.toJSON = function() {
      var result;
      result = {};
      result.type = this.type || "Void";
      return result;
    };

    COMNode.prototype.compose = function() {
      if (this.context.namespace.compose(this)) {
        return true;
      }
      if (typeof this.acknowledge === "function") {
        this.acknowledge();
      }
      return false;
    };

    COMNode.prototype.onRootDispel = function() {
      return this.context.handleNodeDetach(this);
    };

    COMNode.prototype.onRootAvailable = function() {
      this.context.requestCompose(this);
      if (this.root.rc) {
        this.setRenderContext(this.root.rc);
      }
      return this.context.handleNodeAttach(this);
    };

    COMNode.prototype.forceChange = function() {
      return this.context.forceChange();
    };

    COMNode.prototype.pend = function() {
      this.dirty = true;
      if (this.root) {
        this.context.requestCompose(this);
      }
      this.composerBuffer = {};
      return this.emit("pend");
    };

    COMNode.prototype.acknowledge = function() {
      return false;
    };

    COMNode.prototype.slice = function(option) {
      if (option == null) {
        option = {};
      }
      return this.clone();
    };

    COMNode.prototype.clone = function() {
      var result;
      result = this.context.createElement(this.type, this.toJSON());
      result.isPartial = false;
      return result;
    };

    COMNode.prototype.compareNodePosition = function(b) {
      if (!this.parent && !this.isRoot) {
        return null;
      }
      return this.getPath().compare(b.getPath());
    };

    COMNode.prototype.toHumanString = function() {
      return "";
    };

    COMNode.prototype.toPlainString = function() {
      return this.toHumanString();
    };

    COMNode.prototype.transactTrigger = function() {
      var args, result;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (!this.trigger) {
        return false;
      }
      result = false;
      this.context.transact((function(_this) {
        return function() {
          return result = _this.trigger.apply(_this, args);
        };
      })(this));
      return result;
    };

    COMNode.prototype.toMarkdown = function() {
      return this.toHumanString();
    };

    return COMNode;

  })(EventEmitter);

  module.exports = COMNode;

}).call(this);

}
GlobalContext.setModule("vincent/com/node.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/operation.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMNode, ChangePropertyOperation, EditOperation, Errors, OpIndex, TreeOperation,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Errors = require("./errors");

  COMNode = require("./node");

  OpIndex = 0;

  EditOperation = (function() {
    EditOperation.prototype.name = "VoidEditOperation";

    function EditOperation(context, target, option) {
      this.context = context;
      this.target = target;
      this.option = option != null ? option : {};
      this._index = OpIndex++;
      if (this.target instanceof COMNode) {
        this.path = this.target.getPath();
      } else if (this.target.type === "COMPath") {
        this.path = this.target;
        this.target = null;
      }
    }

    EditOperation.prototype.error = function(message, meta) {
      var error;
      error = new Errors.OperationError("Edit->" + this.name + " Error: " + message, meta);
      Logger.error(error, this);
      return error;
    };

    EditOperation.prototype.invoke = function() {};

    EditOperation.prototype.revoke = function() {};

    EditOperation.prototype.toJSON = function() {
      return {
        path: this.path,
        option: this.option
      };
    };

    EditOperation.prototype.describe = function() {
      return this.name;
    };

    return EditOperation;

  })();

  ChangePropertyOperation = (function(superClass) {
    extend(ChangePropertyOperation, superClass);

    ChangePropertyOperation.prototype.name = "ChangePropertyOperation";

    ChangePropertyOperation.prototype.describe = function() {
      return "change prop:" + JSON.stringify(this.option, null, 4);
    };

    function ChangePropertyOperation(context, target, option) {
      var base;
      this.context = context;
      this.target = target;
      this.option = option != null ? option : {};
      ChangePropertyOperation.__super__.constructor.call(this, this.context, this.target, this.option);
      if ((base = this.option).property == null) {
        base.property = {};
      }
    }

    ChangePropertyOperation.prototype.invoke = function() {
      var base, prop;
      if ((base = this.option).oldProperty == null) {
        base.oldProperty = {};
      }
      for (prop in this.option.property) {
        this.option.oldProperty[prop] = this.target[prop];
        this.target[prop] = this.option.property[prop];
      }
      return this.target.pend();
    };

    ChangePropertyOperation.prototype.revoke = function() {
      var prop;
      if (this.option.immutable) {
        return false;
      }
      for (prop in this.option.oldProperty) {
        this.target[prop] = this.option.oldProperty[prop];
      }
      return this.target.pend();
    };

    return ChangePropertyOperation;

  })(EditOperation);

  TreeOperation = (function() {
    TreeOperation.prototype.name = "TreeOperation";

    function TreeOperation(context, target, option) {
      this.context = context;
      this.target = target;
      this.option = option != null ? option : {};
      this.path = this.target.getPath();
      this._index = OpIndex++;
    }

    TreeOperation.prototype.error = function(message, meta) {
      var error;
      error = new Errors.OperationError("Tree->" + this.name + " Error: " + message, meta);
      Logger.error(error, this, this.describe());
      return error;
    };

    TreeOperation.prototype.toJSON = function() {
      return {
        path: this.path,
        option: this.option
      };
    };

    TreeOperation.prototype.describe = function() {
      return this.name;
    };

    return TreeOperation;

  })();

  exports.EditOperation = EditOperation;

  exports.TreeOperation = TreeOperation;

  exports.ChangePropertyOperation = ChangePropertyOperation;

}).call(this);

}
GlobalContext.setModule("vincent/com/operation.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/path.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMPath;

  COMPath = (function() {
    COMPath.fromNode = function(node) {
      var path, ref, routes;
      routes = [];
      while (node.parent) {
        routes.push(node.parent.indexOf(node));
        node = node.parent;
      }
      path = new COMPath({
        type: "COMPath",
        routes: routes
      });
      path.anchor = ((ref = node.anchor) != null ? typeof ref.toJSON === "function" ? ref.toJSON() : void 0 : void 0) || null;
      return path;
    };

    COMPath.prototype.type = "COMPath";

    function COMPath(node) {
      var base;
      if (node == null) {
        node = {};
      }
      if (node.leftMost) {
        this.leftMost = true;
      } else if (node.rightMost) {
        this.rightMost = true;
      }
      this.routes = [];
      if (node.isCOMObject) {
        while (node.parent) {
          this.routes.push(node.parent.indexOf(node));
          node = node.parent;
        }
        if (node.anchor) {
          this.anchor = (typeof (base = node.anchor).toJSON === "function" ? base.toJSON() : void 0) || null;
        }
      } else if (node instanceof COMPath) {
        this.routes = node.getRoutes();
        this.anchor = node.anchor;
      } else if (node.type === "COMPath") {
        this.routes = node.routes || [];
        this.anchor = node.anchor || null;
      } else {
        this.routes = [];
        this.anchor = null;
      }
    }

    COMPath.prototype.getRoutes = function() {
      return this.routes.slice();
    };

    COMPath.prototype.toJSON = function() {
      return {
        routes: this.routes,
        type: "COMPath",
        leftMost: this.leftMost,
        rightMost: this.rightMost
      };
    };

    COMPath.prototype.compare = function(b) {
      var a, asub, bsub, pa, pb;
      if (this.leftMost) {
        if (b.leftMost) {
          return "identical";
        } else {
          return "before";
        }
      } else if (this.rightMost) {
        if (b.rightMost) {
          return "identical";
        } else {
          return "after";
        }
      }
      a = this;
      if (a === b) {
        return "identical";
      }
      pa = a.getRoutes();
      pb = b.getRoutes();
      while (typeof (asub = pa.pop()) === "number") {
        bsub = pb.pop();
        if (asub === bsub) {
          continue;
        } else if (typeof bsub !== "number") {
          return "under";
        } else if (asub > bsub) {
          return "after";
        } else if (asub < bsub) {
          return "before";
        }
      }
      if (typeof pb.pop() === "number") {
        return "contain";
      }
      return "identical";
    };

    return COMPath;

  })();

  module.exports = COMPath;

}).call(this);

}
GlobalContext.setModule("vincent/com/path.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/policy.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMPolicy;

  COMPolicy = (function() {
    function COMPolicy(node) {
      this.node = node;
    }

    COMPolicy.prototype.behave = function(behavior) {
      var prop;
      for (prop in behavior) {
        if (behavior.hasOwnProperty(prop)) {
          this[prop] = behavior[prop];
        }
      }
      return this;
    };

    return COMPolicy;

  })();

  module.exports = COMPolicy;

}).call(this);

}
GlobalContext.setModule("vincent/com/policy.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/richText.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMComposePolicy, COMComposer, COMContainer, COMPath, COMRichText, COMRichTextAnchor, COMRune, COMSpell, COMText, COMTravelPolicy, Errors, Operation,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  COMContainer = require("./container");

  COMPath = require("./path");

  COMRune = require("./rune");

  COMSpell = require("./spell");

  COMText = require("./text");

  Operation = require("./operation");

  COMTravelPolicy = require("./travelPolicy");

  COMComposePolicy = require("./composePolicy");

  COMComposer = require("./composer");

  Errors = require("./errors");

  COMRichTextAnchor = null;

  COMRichText = (function(superClass) {
    extend(COMRichText, superClass);

    COMRichText.packs = [];

    COMRichText.prototype.type = "RichText";

    COMRichText.prototype.mime = "text/com-rich-text";

    COMRichText.prototype.isSingleLine = false;

    function COMRichText(context, option1) {
      var i, item, j, len, len1, ref, ref1, ref2;
      this.context = context;
      this.option = option1 != null ? option1 : {};
      if (this.appearance == null) {
        this.appearance = {
          tagName: "span",
          classList: ["com", "com-rich-text"]
        };
      }
      this.decorationMaintainers = [];
      if (this.availableSpells == null) {
        this.availableSpells = [];
      }
      this.disableTextHolder = false;
      ref = this.context.namespace.decorations;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        this.decorationMaintainers.push(item);
      }
      ref1 = this.context.namespace.spells;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        item = ref1[j];
        this.availableSpells.push(item);
      }
      if (this.privateSpells) {
        (ref2 = this.availableSpells).push.apply(ref2, this.privateSpells);
      }
      this.placeholder = this.option.placeholder;
      this.__defineGetter__("contentString", (function(_this) {
        return function() {
          if (_this._contentString !== null) {
            return _this._contentString;
          }
          _this._contentString = (_this.children.map(function(item) {
            return item.contentString || "";
          })).join("");
          return _this._contentString;
        };
      })(this));
      this.__defineSetter__("contentString", (function(_this) {
        return function(cs) {
          _this.empty();
          _this.append(new COMText(_this.context, {
            contentString: cs,
            passive: true
          }));
          return _this.pend();
        };
      })(this));
      this.__defineGetter__("length", (function(_this) {
        return function() {
          if (_this._length >= 0) {
            return _this._length;
          }
          return _this.reflow();
        };
      })(this));
      COMRichText.__super__.constructor.call(this, this.context, this.option);
      if (this.option.contentString || this.children.length === 0) {
        this.contentString = this.option.contentString || "";
      }
      this.__defineGetter__("holder", function() {
        if (!this.cache) {
          return null;
        }
        if (!this.cache.holder) {
          this.cache.holder = document.createElement("span");
          this.cache.holder.textNode = document.createTextNode("");
          this.cache.holder.appendChild(this.cache.holder.textNode);
          this.cache.holder.classList.add("com-holder");
          this.cache.holder.com = this;
        }
        return this.cache.holder;
      });
      this.travelPolicy = new COMTravelPolicy(this).behave({
        write: "enable",
        forwardChar: "enable",
        backwardChar: "enable",
        deleteChar: "enable",
        forwardBypassed: "handover",
        backwardBypassed: "handover",
        deleteBypassed: "handover",
        head: "enable",
        tail: "enable",
        startOfLine: "boundary",
        endOfLine: "handover",
        tailBoundary: "pass"
      });
      this.layout = "block";
      this.composePolicy = new COMComposePolicy(this).behave({
        newlineSplitHead: true,
        newlineSplitTail: true,
        tailingNewline: false,
        headingNewline: false,
        borrow: false,
        lend: true
      });
      if (!COMRichTextAnchor) {
        COMRichTextAnchor = require("./richTextAnchor");
      }
      this.anchor = new COMRichTextAnchor(this);
    }

    COMRichText.prototype.cutOut = function(offset) {
      var children, i, index, item, j, len, len1, ref, result, target;
      this.reflow();
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.endOffset >= offset) {
          target = item;
          break;
        }
      }
      if (!target) {
        return null;
      }
      if (item.sortOf("Rune") || item.endOffset === offset) {
        offset = item.endOffset;
      } else {
        item.splitInPlace(offset - item.startOffset);
      }
      index = this.indexOf(item);
      children = this.children.slice(index + 1);
      this.removeChildren(children);
      result = this.context.createElement("RichText", {});
      for (j = 0, len1 = children.length; j < len1; j++) {
        item = children[j];
        result.append(item);
      }
      return result;
    };

    COMRichText.prototype.pend = function() {
      this._contentString = null;
      this._length = -1;
      return COMRichText.__super__.pend.call(this);
    };

    COMRichText.prototype.getRunes = function() {
      return this.children.filter(function(item) {
        return item.sortOf("Rune");
      });
    };

    COMRichText.prototype.isStartOfChar = function(char) {
      var first;
      first = this.children[0];
      if (!first || !first.sortOf("Text")) {
        return false;
      }
      return first.contentString.slice(0, 1) === char;
    };

    COMRichText.prototype.isEndOfChar = function(char) {
      var last;
      last = this.last();
      if (!last || !last.sortOf("Text")) {
        return false;
      }
      return last.contentString.slice(-1) === char;
    };

    COMRichText.prototype.isEmpty = function() {
      return this.children.length === 0 || (this.children.length === 1 && this.children[0].isEmpty()) && true;
    };

    COMRichText.prototype.append = function(item) {
      if (!(item instanceof COMText) && !(item instanceof COMRune)) {
        throw new Errors.LogicError("COMRichText only support COMSpell or COMText as child");
      }
      return COMRichText.__super__.append.call(this, item);
    };

    COMRichText.prototype.reflow = function() {
      var i, index, item, len, offset, ref;
      offset = 0;
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        item.startOffset = offset;
        offset += item.length;
        item.endOffset = offset;
      }
      this._length = offset;
      return offset;
    };

    COMRichText.prototype.borrowFirstLine = function() {
      var cs, index;
      if (!this.composePolicy.lend) {
        return "";
      }
      cs = this.contentString;
      index = cs.indexOf("\n");
      if (index < 0) {
        return "";
      }
      this.removeText(0, index + 1);
      return cs.slice(0, index + 1);
    };

    COMRichText.prototype.borrowHeadingNewline = function() {
      if (!this.composePolicy.lend) {
        return false;
      }
      if (this.contentString[0] === "\n") {
        this.removeText(0, 1);
        return true;
      }
      return false;
    };

    COMRichText.prototype.borrowTailingNewline = function() {
      if (!this.composePolicy.lend) {
        return false;
      }
      if (this.contentString.slice(-1) === "\n") {
        this.removeText(this.contentString.length - 1);
        return true;
      }
      return false;
    };

    COMRichText.prototype.render = function(rc) {
      var child, ctail, el, hasCorrectParent, i, index, item, j, k, l, len, len1, len2, len3, len4, len5, len6, m, modified, n, neAnchor, nes, nesShould, next, o, p, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, removes, solved;
      solved = false;
      modified = this.beforeMark("hasDetachedChild") || this.beforeMark("hasAttachedChild");
      next = this.next();
      if (this.children.length === 0 || (this.children.length === 1 && this.children[0].length === 0) || this.forceHolder) {
        this.holder.textNode.textContent = this.placeholder || "";
        if (this.trigger && !this.holder.withClick) {
          this.holder.withClick = true;
          this.holder.onclick = (function(_this) {
            return function() {
              return _this.context.transact(function() {
                return typeof _this.trigger === "function" ? _this.trigger({
                  via: "holder"
                }) : void 0;
              });
            };
          })(this);
        }
      } else {
        this.holder.textNode.textContent = "";
      }
      if (this.layout === "block") {
        ref = this.children;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          item = ref[index];
          item.blockTail = false;
          if (index === this.children.length - 1 && item.sortOf("Text") && next) {
            item.blockTail = true;
          }
        }
      }
      if (!this.beforeMark("hasAttachedChild")) {
        ref1 = this.children;
        for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
          item = ref1[index];
          if (item.richTextIndex !== index) {
            modified = true;
            item.richTextIndex = index;
          }
        }
      }
      if (this.beforeMark("hasDetachedChild") && this.domContainer) {
        removes = [];
        ref2 = this.domContainer.children;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          item = ref2[k];
          if ((ref3 = item.com, indexOf.call(this.children, ref3) < 0) && item !== this.holder) {
            removes.push(item);
          }
        }
        for (l = 0, len3 = removes.length; l < len3; l++) {
          item = removes[l];
          this.domContainer.removeChild(item);
        }
      }
      if (modified && this.domContainer) {
        ref4 = this.children;
        for (m = 0, len4 = ref4.length; m < len4; m++) {
          child = ref4[m];
          if (child.dirty) {
            child.render(rc);
            child.afterRender();
          }
        }
        ref5 = this.children;
        for (index = n = ref5.length - 1; n >= 0; index = n += -1) {
          child = ref5[index];
          next = this.children[index + 1];
          if (!next) {
            if (!child.elAfter) {
              nes = child.el.nextElementSibling;
            } else {
              nes = child.elAfter.nextElementSibling;
            }
            hasCorrectParent = true;
            ref6 = [child.el, child.elBefore, child.elAfter];
            for (o = 0, len5 = ref6.length; o < len5; o++) {
              el = ref6[o];
              if (!el) {
                continue;
              }
              if (el && el.parentElement !== this.domContainer) {
                hasCorrectParent = false;
                break;
              }
            }
            if (!hasCorrectParent || (nes && nes !== this.holder)) {
              if (child.elBefore) {
                this.domContainer.appendChild(child.elBefore);
              }
              this.domContainer.appendChild(child.el);
              if (child.elAfter) {
                this.domContainer.appendChild(child.elAfter);
              }
            }
            continue;
          }
          if (next.elBefore) {
            neAnchor = next.elBefore;
            nesShould = next.elBefore.previousElementSibling;
          } else {
            neAnchor = next.el;
            nesShould = next.el.previousElementSibling;
          }
          hasCorrectParent = true;
          ref7 = [child.el, child.elBefore, child.elAfter];
          for (p = 0, len6 = ref7.length; p < len6; p++) {
            el = ref7[p];
            if (!el) {
              continue;
            }
            if (el && el.parentElement !== this.domContainer) {
              hasCorrectParent = false;
              break;
            }
          }
          if (child.elAfter) {
            ctail = child.elAfter;
          } else {
            ctail = child.el;
          }
          if (!hasCorrectParent || nesShould !== ctail) {
            if (child.elBefore) {
              this.domContainer.insertBefore(child.elBefore, neAnchor);
            }
            if (child.el) {
              this.domContainer.insertBefore(child.el, neAnchor);
            }
            if (child.elAfter) {
              this.domContainer.insertBefore(child.elAfter, neAnchor);
            }
          } else if (child.elAfter) {
            Logger.error("cel pass");
          }
        }
        solved = true;
      }
      COMRichText.__super__.render.call(this, rc, {
        recursive: true,
        selfless: !modified || solved
      });
      if (this.holder.parentElement !== this.domContainer || this.holder.nextSibling) {
        return this.domContainer.appendChild(this.holder);
      }
    };

    COMRichText.prototype.compose = function() {
      var casted, changed, hasRunes, i, index, item, len, normalized, ref, retained;
      if (COMRichText.__super__.compose.call(this)) {
        return true;
      }
      retained = this.retainSpells();
      normalized = this.normalizeTexts();
      casted = this.castSpells();
      normalized = this.normalizeTexts();
      hasRunes = this.recoverRunes();
      this.computeDecoration();
      if (!this.disableTextHolder) {
        ref = this.children;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          item = ref[index];
          if (index !== this.children.length - 1) {
            item.withHolder = false;
          } else {
            item.withHolder = true;
          }
        }
      }
      changed = retained || normalized || casted;
      if (changed) {
        return true;
      }
      if (typeof this.acknowledge === "function") {
        this.acknowledge();
      }
      return false;
    };

    COMRichText.prototype.recoverRunes = function() {
      var after, children, i, item, len, once, reg, result, rune;
      children = this.children.slice();
      reg = new RegExp(COMRune.RunePlaceBegin + "([0-9]+)" + COMRune.RunePlaceEnd);
      for (i = 0, len = children.length; i < len; i++) {
        item = children[i];
        if (item.type !== "Text") {
          continue;
        }
        while (true) {
          result = item.contentString.match(reg);
          if (!result) {
            break;
          }
          if (this.mime !== "text/com-rich-text") {
            item.removeText(result.index, result[0].length);
            once = true;
            continue;
          }
          rune = this.context.runeCache.cloneByCid(result[1]);
          if (!rune) {
            break;
          }
          item.removeText(result.index, result[0].length);
          after = item.splitInPlace(result.index);
          if (result.index === 0) {
            item.before(rune);
          } else {
            item.after(rune);
          }
          if (!after) {
            break;
          }
          item = after;
          once = true;
        }
      }
      return once || false;
    };

    COMRichText.prototype.retainSpells = function() {
      var i, item, len, ref, result;
      result = false;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item instanceof COMSpell) {
          result = item.compose() || result;
        }
      }
      return result;
    };

    COMRichText.prototype.castSpells = function() {
      var Spell, after, before, candidate, content, cs, i, index, item, j, k, l, len, len1, len2, match, nexts, offsetStart, parts, ref, ref1, result, results, spell, spells, start, text, texts;
      this.reflow();
      cs = this.contentString;
      texts = [];
      start = 0;
      text = "";
      ref = this.children.slice(0);
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.sortOf("Text")) {
          if (!text) {
            start = item.startOffset;
          }
          text += item.contentString;
        } else {
          texts.push({
            content: text,
            start: start
          });
          text = "";
        }
      }
      if (text) {
        texts.push({
          content: text,
          start: start
        });
      }
      results = [];
      ref1 = this.availableSpells;
      for (j = ref1.length - 1; j >= 0; j += -1) {
        Spell = ref1[j];
        nexts = [];
        offsetStart = 0;
        for (index = k = 0, len1 = texts.length; k < len1; index = ++k) {
          text = texts[index];
          start = text.start;
          candidate = text.content;
          parts = [];
          while (candidate && (match = Spell.prototype.test(candidate, start, cs))) {
            if (match.start === match.end) {
              throw new Error("parse empty spell content");
            }
            before = candidate.slice(0, match.start);
            content = candidate.slice(match.start, match.end);
            after = candidate.slice(match.end);
            if (before) {
              parts.push({
                start: start,
                content: before
              });
            }
            start += before.length;
            results.push({
              Spell: Spell,
              start: start,
              content: content
            });
            start += content.length;
            candidate = after;
          }
          if (candidate) {
            parts.push({
              start: start,
              content: candidate
            });
          }
          nexts.push.apply(nexts, parts);
        }
        texts = nexts;
      }
      results.sort(function(a, b) {
        return a.start - b.start;
      });
      spells = this.children.slice(0).filter(function(item) {
        return item.sortOf("Spell");
      });
      if (results.length !== spells.length) {
        this.castAllSpells(results);
        return true;
      }
      for (index = l = 0, len2 = results.length; l < len2; index = ++l) {
        result = results[index];
        spell = spells[index];
        if (result.start === spell.startOffset && result.content.length === spell.length) {
          continue;
        }
        this.castAllSpells(results);
        return true;
      }
      return false;
    };

    COMRichText.prototype.castAllSpells = function(spells) {
      var end, endOffset, i, index, info, len, next, results1, spell, startOffset, target;
      if (spells.length === 0) {
        return;
      }
      this.reflow();
      results1 = [];
      for (i = 0, len = spells.length; i < len; i++) {
        info = spells[i];
        index = this.getChildTextIndexByOffset(info.start);
        target = this.children[index];
        end = info.start + info.content.length;
        while (end > target.endOffset) {
          next = this.children[index + 1];
          if (!next) {
            break;
          }
          target.mergeInPlace(next);
          target.endOffset += next.length;
        }
        spell = new info.Spell(this.context, {});
        startOffset = info.start - target.startOffset;
        endOffset = startOffset + info.content.length;
        results1.push(spell.castToText(target, startOffset, endOffset));
      }
      return results1;
    };

    COMRichText.prototype.castSpellsOld = function() {
      var Spell, contentString, i, j, len, ref, result, text, texts;
      contentString = this.contentString;
      result = null;
      ref = this.availableSpells;
      for (i = ref.length - 1; i >= 0; i += -1) {
        Spell = ref[i];
        texts = this.children.slice().filter(function(item) {
          return item.type === "Text";
        });
        for (j = 0, len = texts.length; j < len; j++) {
          text = texts[j];
          result = this.castSpellOn(Spell, text, contentString) || result;
          if (result) {
            Logger.error("cast spell on", [text.toString()], Spell, texts.length);
          }
        }
      }
      return result;
    };

    COMRichText.prototype.castSpellOnOld = function(Spell, text, contentString) {
      var last, result, spell, success;
      contentString = contentString || this.contentString;
      while (text && (result = Spell.prototype.test(text.contentString, text.startOffset, contentString))) {
        spell = new Spell(this.context, {
          match: result.match
        });
        last = spell.castToText(text, result.start, result.end);
        text = last;
        success = true;
      }
      return success;
    };

    COMRichText.prototype.normalizeTexts = function() {
      var canMerge, hasMerge, i, index, item, len, prev, retain, texts;
      if (this.noAutoMerge) {
        return false;
      }
      canMerge = function(a, b) {
        return a.type === "Text" && b.type === "Text";
      };
      if (this.children.length === 1) {
        return;
      }
      texts = this.children.slice();
      retain = false;
      prev = null;
      for (index = i = 0, len = texts.length; i < len; index = ++i) {
        item = texts[index];
        if (item.length === 0 && index !== texts.length - 1) {
          hasMerge = true;
          item.remove();
          continue;
        }
        if (!prev) {
          prev = item;
          continue;
        }
        if (canMerge(prev, item)) {
          prev.mergeInPlace(item);
          hasMerge = true;
        } else {
          prev = item;
        }
      }
      return hasMerge || false;
    };

    COMRichText.prototype.getBreakString = function(count, breakChar) {
      var pattern, result;
      if (breakChar == null) {
        breakChar = "\uE1F8";
      }
      pattern = breakChar;
      if (count < 1) {
        return "";
      }
      result = "";
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    };

    COMRichText.prototype.getDecorationString = function() {
      var behavior, i, item, len, ref, str;
      str = "";
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        behavior = item.decorationPolicy.behavior;
        if (behavior === "break") {
          str += this.getBreakString(item.length);
        } else if (behavior === "singular") {
          str += this.getBreakString(item.length, "X");
        } else {
          str += item.contentString || "";
        }
      }
      return str;
    };

    COMRichText.prototype.computeDecoration = function() {
      var backup, content, counter, dc, dec, decIndex, decorations, disIndex, disItem, disableRegions, fpdec, i, index, item, j, k, l, len, len1, len2, len3, maintainer, next, nextRound, ref, results1, targets, text, valid, validDecs;
      content = this.getDecorationString();
      decorations = [];
      ref = this.decorationMaintainers;
      for (i = 0, len = ref.length; i < len; i++) {
        maintainer = ref[i];
        decorations.push.apply(decorations, maintainer.compute(content));
      }
      decorations.sort(function(a, b) {
        var MAX_TEXTCOUNT;
        MAX_TEXTCOUNT = 1000001;
        return a.start - b.start + (a.end - b.end) / MAX_TEXTCOUNT;
      });
      valid = [];
      this.reflow();
      disableRegions = [];
      decIndex = 0;
      validDecs = decorations.slice();
      for (disIndex = j = 0, len1 = disableRegions.length; j < len1; disIndex = ++j) {
        disItem = disableRegions[disIndex];
        while (true) {
          dec = validDecs[decIndex];
          if (!dec) {
            break;
          }
          if (dec.start > disItem.end) {
            decIndex = decIndex;
            break;
          }
          if (dec.end < disItem.start) {
            decIndex += 1;
            continue;
          }
          if (dec.start <= disItem.start && dec.end > disItem.start) {
            if (disItem.allowWrapping) {
              decIndex += 1;
            } else {
              validDecs.splice(decIndex, 1);
            }
            continue;
          }
          if (dec.start >= disItem.start && dec.end <= disItem.end) {
            validDecs.splice(decIndex, 1);
            continue;
          }
          if (dec.start >= disItem.start && dec.start < disItem.end) {
            validDecs.splice(decIndex, 1);
            continue;
          }
          if (dec.start <= disItem.start && dec.end >= disItem.end) {
            validDecs.splice(decIndex, 1);
            continue;
          }
          break;
        }
      }
      decorations = validDecs;
      targets = this.children.slice();
      this.reflow();
      targets.forEach(function(item) {
        return item._decs = [];
      });
      backup = targets.slice();
      counter = 0;
      for (k = 0, len2 = decorations.length; k < len2; k++) {
        dec = decorations[k];
        nextRound = [];
        index = 0;
        while (true) {
          if (index >= targets.length) {
            break;
          }
          text = targets[index];
          if (text.startOffset >= dec.end) {
            break;
          }
          if (text.endOffset <= dec.start) {
            targets.splice(index, 1);
            continue;
          }
          if (dec.end <= text.endOffset) {
            text._decs.push(dec.shift(-text.startOffset));
            if (dec.start < 0) {
              Logger.error("INVALID DEC", dec, text.startOffset, text.contentString);
            }
          } else {
            next = dec.split(text.endOffset);
            text._decs.push(dec.shift(-text.startOffset));
            if (dec.start < 0) {
              Logger.error("INVALID DEC AFTER", dec);
            }
            dec = next;
          }
          index += 1;
        }
      }
      fpdec = function(decs) {
        return (decs.map(function(item) {
          return "" + item.mid + ":" + item.start + "~" + item.end;
        })).join("|");
      };
      dc = 0;
      results1 = [];
      for (l = 0, len3 = backup.length; l < len3; l++) {
        item = backup[l];
        if (item.ignoreDecoration && !item.allowWrapping) {
          item.setDecorations();
          continue;
        }
        if (item._decs.length !== item.decorations.length) {
          if (typeof item.setDecorations === "function") {
            item.setDecorations(item._decs);
          }
          dc += 1;
          continue;
        }
        results1.push((function() {
          var len4, m, ref1, results2;
          ref1 = item._decs;
          results2 = [];
          for (index = m = 0, len4 = ref1.length; m < len4; index = ++m) {
            dec = ref1[index];
            if (dec.equal(item.decorations[index])) {
              continue;
            } else {
              if (typeof item.setDecorations === "function") {
                item.setDecorations(item._decs);
              }
              dc += 1;
              break;
            }
          }
          return results2;
        })());
      }
      return results1;
    };

    COMRichText.prototype.insertText = function(start, value) {
      var anchor, i, inside, len, ref;
      if (!this._insertText(start, value)) {
        return false;
      }
      ref = this.anchors;
      for (i = 0, len = ref.length; i < len; i++) {
        anchor = ref[i];
        if (anchor.index >= start) {
          inside = anchor.inside;
          anchor.index += value.length;
          anchor.inside = inside;
        }
      }
      return true;
    };

    COMRichText.prototype._insertText = function(start, value) {
      var i, index, last, len, next, ref, text;
      this.reflow();
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        text = ref[index];
        last = text;
        next = this.children[index + 1];
        if (start >= text.startOffset && start < text.endOffset) {
          if (text.insertText(start - text.startOffset, value)) {
            this.pend();
            return true;
          } else {
            return false;
          }
        } else if (start === text.endOffset && text.sortOf("Text") && next && next.sortOf("Rune")) {
          if (text.insertText(start - text.startOffset, value)) {
            this.pend();
            return true;
          } else {
            return false;
          }
        } else if (start >= text.startOffset && start === text.endOffset && text instanceof COMSpell) {
          if (text.insertText(start - text.startOffset, value)) {
            this.pend();
            return true;
          } else {
            return false;
          }
        }
      }
      if (last && start === last.endOffset) {
        if (last.insertText(start - last.startOffset, value)) {
          this.pend();
          return true;
        }
      } else if (start === 0) {
        if (this.append(new COMText(this.context, {
          contentString: value
        }))) {
          this.pend();
          return true;
        }
      }
      return false;
    };

    COMRichText.prototype.insertRune = function(start, rune) {
      var anchor, i, inside, len, ref;
      if (!this._insertRune(start, rune)) {
        return false;
      }
      ref = this.anchors;
      for (i = 0, len = ref.length; i < len; i++) {
        anchor = ref[i];
        if (anchor.index === start) {
          anchor.index += rune.length;
        } else if (anchor.index >= start) {
          inside = anchor.inside;
          anchor.index += rune.length;
          anchor.inside = inside;
        }
      }
      return true;
    };

    COMRichText.prototype._insertRune = function(start, rune) {
      var anchor, i, inside, j, len, len1, offset, ref, ref1, text;
      offset = 0;
      this.reflow();
      if (start === this.contentString.length) {
        this.pend();
        return this.append(rune);
      }
      if (start === 0) {
        this.pend();
        return this.insert(0, rune);
      }
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        text = ref[i];
        if (text.endOffset < start) {
          continue;
        }
        if (text.startOffset === start) {
          text.before(rune);
        } else if (text.endOffset === start) {
          text.after(rune);
        } else if (text instanceof COMText) {
          text.splitInPlace(start - text.startOffset);
          text.after(rune);
        } else {
          text.after(rune);
        }
        this.pend();
        return true;
      }
      return false;
      ref1 = this.anchors;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        anchor = ref1[j];
        inside = anchor.inside;
        if (anchor.index < start) {
          return;
        }
        if (anchor.index >= start + length) {
          anchor.index -= length;
          anchor.inside = inside;
          continue;
        }
        if (anchor.index >= start) {
          anchor.index = start;
          anchor.inside = inside;
          continue;
        }
      }
      return true;
    };

    COMRichText.prototype.removeRune = function(rune) {
      if (rune.parent !== this) {
        return false;
      }
      return this.removeText(rune.startOffset, rune.length);
    };

    COMRichText.prototype.removeText = function(start, length) {
      var action, actions, anchor, cs, end, i, index, inside, j, k, len, len1, len2, offset, ref, ref1, text, textEnd, textStart;
      cs = this.contentString;
      if (length == null) {
        length = cs.length - start;
      }
      actions = [];
      offset = start;
      end = start + length;
      if (start > cs.length || start + length > cs.length) {
        return false;
      }
      this.reflow();
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        text = ref[index];
        if (text.startOffset >= end) {
          break;
        } else if (text.endOffset <= start) {
          continue;
        }
        textStart = offset - text.startOffset;
        textEnd = end - text.startOffset;
        if (textEnd >= text.length) {
          textEnd = text.length;
          if (textStart === 0) {
            actions.push({
              remove: true,
              text: text
            });
          } else {
            actions.push({
              start: textStart,
              text: text
            });
          }
          offset = text.endOffset;
        } else {
          actions.push({
            start: textStart,
            length: textEnd - textStart,
            text: text
          });
          break;
        }
      }
      for (index = j = 0, len1 = actions.length; j < len1; index = ++j) {
        action = actions[index];
        if (action.remove) {
          action.text.remove();
        } else {
          action.text.removeText(action.start, action.length || null);
        }
        if (index === 0 && action.text.sortOf("Rune")) {
          start = action.text.startOffset;
        }
        if (index === actions.length - 1 && action.text.sortOf("Rune")) {
          end = action.text.endOffset;
        }
      }
      length = end - start;
      ref1 = this.anchors;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        anchor = ref1[k];
        inside = anchor.inside;
        if (anchor.index < start) {
          continue;
        }
        if (anchor.index >= start + length) {
          anchor.index -= length;
          anchor.inside = inside;
          continue;
        }
        if (anchor.index >= start) {
          anchor.index = start;
          anchor.inside = inside;
          continue;
        }
      }
      if (this.children.length === 0) {
        this.contentString = "";
        this.pend();
        return;
      }
      if (actions.length > 0) {
        this.pend();
        return true;
      }
      return false;
    };

    COMRichText.prototype.getOffsetByDOM = function(node, offset) {
      var i, item, len, ref, result;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.isSpell) {
          result = item != null ? typeof item.getOffsetByDOM === "function" ? item.getOffsetByDOM(node, offset) : void 0 : void 0;
          if (result) {
            result.index += item.startOffset;
            return result;
          }
        }
      }
      return null;
    };

    COMRichText.prototype.getChildTextIndexByOffset = function(offset) {
      var i, index, len, ref, text;
      this.reflow();
      if (this.last() && this.last().endOffset === offset) {
        return this.last();
      }
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        text = ref[index];
        if (text.startOffset <= offset && text.endOffset > offset) {
          return index;
        }
      }
    };

    COMRichText.prototype.getChildTextByOffset = function(offset) {
      var i, index, len, ref, text;
      this.reflow();
      if (this.last() && this.last().endOffset === offset) {
        return this.last();
      }
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        text = ref[index];
        if (text.startOffset <= offset && text.endOffset > offset) {
          return text;
        }
      }
      return null;
    };

    COMRichText.prototype.mergeContentString = function(content) {
      if (!content) {
        return true;
      }
      return this.insertText(this.length, content);
    };

    COMRichText.prototype.toContentString = function(option) {
      if (option == null) {
        option = {};
      }
      if (!option.purify) {
        return this.contentString;
      } else {
        return COMRune.purifyContentString(this.contentString, option);
      }
    };

    COMRichText.prototype.hasRune = function(handler) {
      var i, item, len, ref;
      if (handler == null) {
        handler = function() {};
      }
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.sortOf("Rune")) {
          if (handler(item)) {
            return true;
          }
        }
      }
      return false;
    };

    COMRichText.prototype.filterRunes = function(handler) {
      var i, item, len, ref, result;
      if (handler == null) {
        handler = function() {};
      }
      result = [];
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.sortOf("Rune")) {
          if (handler(item)) {
            result.push(item);
          }
        }
      }
      return result;
    };

    COMRichText.prototype.fromJSON = function(option) {
      var child, find, i, len, ref, results1;
      if (option.children) {
        this.empty();
        ref = option.children;
        results1 = [];
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (!child) {
            continue;
          }
          if (child instanceof COMText) {
            results1.push(this.append(child));
          } else if (child.type === "Text") {
            results1.push(this.append(new COMText(this.context, child)));
          } else if (child.spell === true) {
            find = this.availableSpells.some((function(_this) {
              return function(Spell) {
                if (Spell.prototype.type === child.type) {
                  _this.append(new Spell(_this.context, child));
                  return true;
                }
                return false;
              };
            })(this));
            if (!find) {
              Logger.error("RichText:fail to build spell from json for ", child);
              Logger.error("fallback into normal texts.");
              results1.push(this.append(new COMText(this.context, child)));
            } else {
              results1.push(void 0);
            }
          } else if (child.sortOf && child.sortOf("Rune")) {
            results1.push(this.append(child));
          } else if (child.type && this.context.namespace.sortOf(child.type, "Rune")) {
            results1.push(this.append(this.context.createElement(child)));
          } else {
            this.append(this.context.createElement({
              type: "UnknownRune",
              detail: child
            }));
            results1.push(Logger.error("RichText: unsupported typeof child", child, this.context));
          }
        }
        return results1;
      }
    };

    COMRichText.prototype.runeAtIndex = function(index) {
      var child;
      this.reflow();
      if (typeof index !== "number") {
        return null;
      }
      child = this.getChildTextByOffset(index);
      if (child instanceof COMRune) {
        return child;
      }
      return null;
    };

    COMRichText.prototype.isRuneAt = function(index, option) {
      var child;
      if (option == null) {
        option = {};
      }
      this.reflow();
      child = this.getChildTextByOffset(index);
      if (option.strict) {
        return child instanceof COMRune && child.startOffset === index;
      }
      return child instanceof COMRune;
    };

    COMRichText.prototype.spellAtIndex = function(index) {
      var child;
      this.reflow();
      child = this.getChildTextByOffset(index);
      if (!child) {
        return null;
      }
      if (child instanceof COMSpell) {
        return child;
      }
      return null;
    };

    COMRichText.prototype.clone = function() {
      var children, i, item, len, ref;
      children = [];
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        children.push(item.toJSON());
      }
      return this.context.createElement(this.type, {
        children: children
      });
    };

    COMRichText.prototype.slice = function(option) {
      var child, children, clone, cs, end, i, index, isPartial, item, j, last, lastCs, left, leftAnchor, leftOffset, len, len1, ll, looseComplete, pointAt, ref, ref1, ref2, ref3, right, rightAnchor, rightOffset, rr, start, target, text;
      if (option == null) {
        option = {};
      }
      if (option.left) {
        left = option.left;
      } else {
        left = {
          leftMost: true
        };
      }
      if (option.right) {
        right = option.right;
      } else {
        right = {
          rightMost: true
        };
      }
      leftAnchor = this.anchor.clone();
      leftAnchor.head();
      rightAnchor = this.anchor.clone();
      rightAnchor.tail();
      if (leftAnchor.compare(right) === "after") {
        return null;
      }
      if (rightAnchor.compare(left) === "before") {
        return null;
      }
      if (((ref = leftAnchor.compare(left)) === "after" || ref === "identical") && ((ref1 = rightAnchor.compare(right)) === "before" || ref1 === "identical")) {
        return this.clone();
      }
      children = [];
      this.reflow();
      ll = leftAnchor.compare(left);
      rr = rightAnchor.compare(right);
      if (ll === "before") {
        if (left.node === leftAnchor.node) {
          leftAnchor.fromJSON(left.toJSON());
        } else {
          target = left.node;
          while (target && (target !== leftAnchor.node)) {
            pointAt = target;
            target = target.parent;
          }
          if (!pointAt) {
            throw new Errors.LogicError("since leftAnchor is before leftEdge and rightAnchor is after rightEdge, leftAnchor and leftEdge should have same ancester");
          }
          leftAnchor.pointAt(pointAt);
        }
      }
      pointAt = null;
      if (rr === "after") {
        if (right.node === rightAnchor.node) {
          rightAnchor.fromJSON(right.toJSON());
        } else {
          target = right.node;
          while (target && (target !== rightAnchor.node)) {
            pointAt = target;
            target = target.parent;
          }
          if (!pointAt) {
            throw new Errors.LogicError("since rightAnchor is before rightEdge and rightAnchor is after rightEdge, rightAnchor and rightEdge should have same ancester");
          }
          rightAnchor.pointAt(pointAt);
        }
      }
      if (leftAnchor.index === 0 && rightAnchor.index === this.contentString.length) {
        return this.clone();
      }
      ref2 = this.children;
      for (i = 0, len = ref2.length; i < len; i++) {
        item = ref2[i];
        if (item.endOffset <= leftAnchor.index) {
          continue;
        }
        if (item.startOffset >= rightAnchor.index && !rightAnchor.inside) {
          break;
        }
        if (item.sortOf("Rune")) {
          child = item.slice(option);
          if (child) {
            children.push(child);
          }
          continue;
        }
        leftOffset = Math.max(item.startOffset, leftAnchor.index);
        rightOffset = Math.min(item.endOffset, rightAnchor.index);
        if (rightOffset <= leftOffset) {
          continue;
        }
        start = leftOffset - item.startOffset;
        end = rightOffset - item.startOffset;
        cs = item.contentString.slice(start, end);
        text = new COMText(this.context, {
          contentString: cs
        });
        if (leftOffset !== item.startOffset || rightOffset !== item.endOffset && option.selection) {
          text.isPartial = true;
        }
        children.push(text);
      }
      isPartial = false;
      if (children.length !== this.children.length) {
        isPartial = true;
      }
      clone = this.context.createElement(this.type);
      clone.empty();
      last = this.last();
      lastCs = last.contentString;
      looseComplete = false;
      for (index = j = 0, len1 = children.length; j < len1; index = ++j) {
        item = children[index];
        if (item.isPartial) {
          if (index === this.children.length - 1 && (lastCs != null ? lastCs.length : void 0) - 1 === ((ref3 = item.contentString) != null ? ref3.length : void 0) && (lastCs != null ? lastCs[(lastCs != null ? lastCs.length : void 0) - 1] : void 0) === "\n") {
            isPartial = true;
            looseComplete = true;
          } else {
            isPartial = true;
          }
        }
        clone.append(item);
      }
      clone.isPartial = this.isPartial || isPartial;
      clone.looseComplete = looseComplete;
      return clone;
    };

    COMRichText.prototype.toJSON = function() {
      var json;
      json = COMRichText.__super__.toJSON.call(this);
      delete json.contentString;
      return json;
    };

    return COMRichText;

  })(COMContainer);

  module.exports = COMRichText;

}).call(this);

}
GlobalContext.setModule("vincent/com/richText.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/richTextAnchor.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMAnchor, COMNode, COMRichText, COMRichTextAnchor, COMVisualPosition, Errors, StringHelper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  COMNode = require("./node");

  COMRichText = require("./richText");

  StringHelper = require("./helper/string");

  COMAnchor = require("./anchor");

  Errors = require("./errors");

  COMVisualPosition = require("./visualPosition");

  COMRichTextAnchor = (function(superClass) {
    extend(COMRichTextAnchor, superClass);

    function COMRichTextAnchor(node1) {
      this.node = node1;
      COMRichTextAnchor.__super__.constructor.call(this);
      this.index = 0;
      this.rev = 0;
      this.__defineGetter__("index", (function(_this) {
        return function() {
          return _this._index;
        };
      })(this));
      this.__defineSetter__("index", (function(_this) {
        return function(value) {
          var change, length;
          if (value !== _this._index) {
            change = true;
          }
          if (value < 0) {
            value = 0;
          }
          length = _this.node.contentString.length;
          if (value > length) {
            value = length;
          }
          _this.rev += 1;
          _this._index = value;
          _this._inside = false;
          if (change) {
            _this.emit("move");
          }
          return _this._index;
        };
      })(this));
      this.__defineGetter__("inside", (function(_this) {
        return function() {
          return _this._inside;
        };
      })(this));
      this.__defineSetter__("inside", (function(_this) {
        return function(value) {
          var move;
          if (value !== _this._inside) {
            move = true;
          }
          _this._inside = value;
          if (move) {
            _this.emit("move");
          }
          return _this._inside;
        };
      })(this));
      this.index = 0;
      this.inside = false;
      return;
    }

    COMRichTextAnchor.prototype.getPath = function() {
      var path;
      path = this.node.getPath();
      path.anchor = this.toJSON();
      return path;
    };

    COMRichTextAnchor.prototype.activate = function(cursor) {
      var ref, target;
      this.cursor = cursor;
      if (indexOf.call(this.node.anchors, this) < 0) {
        this.node.anchors.push(this);
      }
      if (this.cursor.name) {
        target = "cursor-over-" + this.cursor.name;
        if (indexOf.call(this.node.appearance.classList, target) < 0) {
          this.node.appearance.classList.push(target);
        }
        return (ref = this.node.el) != null ? ref.classList.add(target) : void 0;
      }
    };

    COMRichTextAnchor.prototype.deactivate = function(arg) {
      var ref, ref1, replacementAnchor, replacementCursor, target;
      ref = arg != null ? arg : {}, replacementCursor = ref.replacementCursor, replacementAnchor = ref.replacementAnchor;
      if (this.cursor && this.cursor.name && (replacementCursor !== this.cursor || !this.equal(replacementAnchor))) {
        target = "cursor-over-" + this.cursor.name;
        if (indexOf.call(this.node.appearance.classList, target) >= 0) {
          this.node.appearance.classList = this.node.appearance.classList.filter(function(item) {
            return item !== target;
          });
        }
        if ((ref1 = this.node.el) != null) {
          ref1.classList.remove(target);
        }
      }
      this.cursor = null;
      return this.node.anchors = this.node.anchors.filter((function(_this) {
        return function(item) {
          return item !== _this;
        };
      })(this));
    };

    COMRichTextAnchor.prototype.toJSON = function() {
      return {
        index: this.index,
        inside: this.inside
      };
    };

    COMRichTextAnchor.prototype.fromJSON = function(json) {
      this.index = json.index;
      return this.inside = json.inside;
    };

    COMRichTextAnchor.prototype.forwardChar = function() {
      var rune;
      if (this.index < this.node.length) {
        rune = this.node.runeAtIndex(this.index);
        if (rune && this.cursor.trapIn(rune, {
          direction: "left"
        })) {
          return true;
        }
        if (rune) {
          if (rune.trigger && !this.inside) {
            this.inside = true;
          } else {
            this.index += rune.length;
          }
        } else {
          this.index += 1;
        }
        return true;
      }
      return false;
    };

    COMRichTextAnchor.prototype.backwardChar = function() {
      var rune;
      if (this.inside) {
        this.inside = false;
        return true;
      }
      if (this.index > 0) {
        rune = this.node.runeAtIndex(this.index - 1);
        if (rune && this.cursor.trapIn(rune, {
          direction: "right"
        })) {
          return true;
        }
        if (rune) {
          this.index -= rune.length;
          if (rune.trigger) {
            this.inside = true;
          }
        } else {
          this.index -= 1;
        }
        return true;
      }
      return false;
    };

    COMRichTextAnchor.prototype.trapRecover = function(rune, direction) {
      var i, len, ref, text;
      if (direction == null) {
        direction = "left";
      }
      this.node.reflow();
      ref = this.node.children;
      for (i = 0, len = ref.length; i < len; i++) {
        text = ref[i];
        if (text === rune) {
          if (direction === "left") {
            this.index = rune.startOffset;
          } else {
            this.index = rune.endOffset;
          }
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.backwardWord = function() {
      var contentString, find, last, length, maybe, results, rune, start;
      if (this.index === 0) {
        return false;
      }
      this.node.reflow();
      if (this.node.isRuneAt(this.index)) {
        rune = this.node.runeAtIndex(this.index);
        if (rune.startOffset === this.index) {
          rune = null;
        }
      } else if (this.node.isRuneAt(this.index - 1)) {
        rune = this.node.runeAtIndex(this.index - 1);
      }
      if (rune) {
        this.index = rune.startOffset;
        if (this.index !== 0) {
          return true;
        }
      }
      contentString = this.node.contentString;
      find = StringHelper.findJumpBreakBackward(contentString, this.index);
      if (find.index === this.index) {
        return false;
      }
      if (rune = this.node.runeAtIndex(find)) {
        if (rune.index !== find) {
          find = rune.endOffset;
        }
      }
      this.index = find;
      return true;
      contentString = this.node.contentString;
      maybe = contentString.slice(0, this.index);
      results = maybe.split(/\b/);
      last = results.pop() || "";
      if (/^\s+$/.test(last)) {
        last = (results.pop() || "") + last;
      }
      length = last.length;
      start = maybe.length - length;
      this.index = start;
      return true;
    };

    COMRichTextAnchor.prototype.forwardWord = function() {
      var MAX, contentString, find, first, maybe, results, rune, start;
      if (this.index > this.node.length) {
        return false;
      }
      this.node.reflow();
      if (this.node.isRuneAt(this.index)) {
        rune = this.node.runeAtIndex(this.index);
      }
      if (rune) {
        this.index = rune.endOffset;
        return true;
      }
      contentString = this.node.contentString;
      find = StringHelper.findJumpBreakForward(contentString, this.index);
      if (find.index === this.index) {
        return false;
      }
      if (rune = this.node.runeAtIndex(find)) {
        if (rune.index !== find) {
          find = rune.endOffset;
        }
      }
      this.index = find;
      return true;
      MAX = null;
      contentString = this.node.contentString;
      maybe = contentString.slice(this.index);
      if (maybe.length === 0) {
        return false;
      }
      results = maybe.split(/\b/);
      first = results.shift() || "";
      while (/^\s+$/.test(first)) {
        first = (results.shift() || "") + first;
        if (results.length === 0) {
          break;
        }
      }
      start = first.length;
      if (start === 0) {
        start = maybe.length;
      }
      this.index += start;
      return true;
    };

    COMRichTextAnchor.prototype.deleteLineBeforeAnchor = function() {
      var cs, hasNewLine, index;
      cs = this.node.contentString;
      index = this.index;
      if (cs[this.index] === "\n") {
        this.index -= 1;
      }
      while (cs[this.index] !== "\n" && this.index > 0) {
        this.index -= 1;
      }
      hasNewLine = cs[this.index] === "\n";
      if (this.index === 0) {
        this.node.removeText(0, index);
      } else {
        this.node.removeText(this.index, index - this.index);
      }
      if (this.index === 0 && !hasNewLine) {
        return false;
      } else {
        return true;
      }
      return true;
    };

    COMRichTextAnchor.prototype.deleteChar = function() {
      var rune;
      if (this.inside && (rune = this.node.runeAtIndex(this.index))) {
        rune.remove();
        this.inside = false;
        return true;
      }
      if (this.index === 0) {
        return false;
      }
      this.node.removeText(this.index - 1, 1);
      return true;
    };

    COMRichTextAnchor.prototype.deleteWord = function() {
      var contentString, index, rune, targetIndex;
      if (this.inside && (rune = this.node.runeAtIndex(this.index))) {
        rune.remove();
        this.inside = false;
        return true;
      }
      if (this.index === 0) {
        return false;
      }
      contentString = this.node.contentString;
      index = this.index;
      targetIndex = StringHelper.findJumpBreakBackward(this.node.contentString, index);
      if (targetIndex === index) {
        return false;
      }
      this.node.removeText(targetIndex, index - targetIndex);
      return true;
    };

    COMRichTextAnchor.prototype.startOfLine = function(option) {
      var contentString, index;
      if (option == null) {
        option = {};
      }
      index = this.index;
      contentString = this.node.contentString;
      if (contentString[this.index - 1] === "\n") {
        this.inside = false;
        return true;
      }
      while (index > 0) {
        if (contentString[index - 1] === "\n" && !this.node.isRuneAt(index - 1)) {
          this.index = index;
          return true;
        }
        index -= 1;
      }
      if (option.begin) {
        this.index = 0;
        return true;
      }
      return false;
    };

    COMRichTextAnchor.prototype.endOfLine = function() {
      var contentString, index, length;
      index = this.index;
      length = this.node.length;
      contentString = this.node.contentString;
      if (contentString[this.index] === "\n") {
        return true;
      }
      while (index < length) {
        if (contentString[index + 1] === "\n" && !this.node.isRuneAt(index + 1)) {
          this.index = index + 1;
          return true;
        }
        index += 1;
      }
      return false;
    };

    COMRichTextAnchor.prototype.isTail = function() {
      return this.index === this.node.length;
    };

    COMRichTextAnchor.prototype.isHead = function() {
      return this.index === 0;
    };

    COMRichTextAnchor.prototype.head = function() {
      this.index = 0;
      return true;
    };

    COMRichTextAnchor.prototype.tail = function() {
      this.index = this.node.length;
      return true;
    };

    COMRichTextAnchor.prototype.trigger = function(option) {
      if (this.triggerChild(option)) {
        return true;
      }
      if (this.triggerSelf(option)) {
        return true;
      }
      return false;
    };

    COMRichTextAnchor.prototype.triggerSelf = function(option) {
      var base;
      if (typeof (base = this.node).trigger === "function" ? base.trigger(option) : void 0) {
        return true;
      }
    };

    COMRichTextAnchor.prototype.triggerChild = function(option) {
      var item, result;
      if (option == null) {
        option = {};
      }
      item = this.node.getChildTextByOffset(this.index);
      if (!item) {
        return false;
      }
      if (item.sortOf("Rune")) {
        if (this.inside) {
          return typeof item.trigger === "function" ? item.trigger() : void 0;
        } else {
          return false;
        }
      }
      if (item.startOffset === this.index && !option.force) {
        return false;
      }
      if (item.endOffset === this.index && !option.force) {
        return false;
      }
      if (item.startOffset === this.index && !item.trigger) {
        item = item.previous();
        if (!item || !option.force) {
          return false;
        }
      }
      return result = (typeof item.trigger === "function" ? item.trigger() : void 0) || false;
    };

    COMRichTextAnchor.prototype.getVisualPosition = function() {
      var centerBorder, cs, end, i, index, item, itemIndex, lastChar, leftBorder, len, next, offset, only, previous, ref, ref1, ref2, rightBorder, start;
      index = this.index;
      previous = null;
      offset = 0;
      cs = this.node.contentString;
      if (index === 0 && cs.length === 0) {
        if ((only = this.node.children[0]) && only.getEmptyBorder) {
          return {
            left: only.getEmptyBorder(),
            right: only.getEmptyBorder(),
            center: null
          };
        } else {
          offset = ((ref = this.node.el) != null ? (ref1 = ref.children) != null ? ref1.length : void 0 : void 0) - 1;
          return {
            left: new COMVisualPosition.COMVisualBorder({
              node: this.node.holder.parentElement,
              offset: offset,
              position: "left"
            }),
            right: new COMVisualPosition.COMVisualBorder({
              node: this.node.holder.parentElement,
              offset: offset,
              position: "right"
            }),
            center: null
          };
        }
      }
      cs = this.node.contentString;
      lastChar = cs[cs.length - 1];
      ref2 = this.node.children || [];
      for (itemIndex = i = 0, len = ref2.length; i < len; itemIndex = ++i) {
        item = ref2[itemIndex];
        previous = this.node.children[itemIndex - 1];
        next = this.node.children[itemIndex + 1];
        start = offset;
        end = offset + item.length;
        if (this.inside && item.sortOf("Rune") && index >= start && index < end) {
          leftBorder = previous != null ? previous.getVisualBorder(previous != null ? previous.length : void 0, "left") : void 0;
          centerBorder = item != null ? item.getVisualBorder(index - start, "inside") : void 0;
          rightBorder = next != null ? next.getVisualBorder(0, "right") : void 0;
          break;
        }
        if (index === 0 && start === 0) {
          leftBorder = null;
          centerBorder = null;
          rightBorder = item.getVisualBorder(0, "right");
          break;
        }
        if (index === start && index === end && item.getEmptyBorder) {
          return {
            left: only.getEmptyBorder(),
            right: only.getEmptyBorder(),
            center: null
          };
        }
        if (index >= start && index < end) {
          leftBorder = item != null ? item.getVisualBorder(index - start, "left") : void 0;
          centerBorder = null;
          rightBorder = item != null ? item.getVisualBorder(index - start, "right") : void 0;
          break;
        }
        if (index === end && !this.inside) {
          if (next && next.isEmpty() && next.getEmptyBorder) {
            leftBorder = next.getEmptyBorder();
            rightBorder = next.getEmptyBorder();
            centerBorder = null;
          } else {
            leftBorder = item.getVisualBorder(item.length, "left");
            centerBorder = null;
            rightBorder = next != null ? next.getVisualBorder(0, "right") : void 0;
          }
          break;
        }
        offset += item.length;
      }
      return new COMVisualPosition({
        left: leftBorder,
        center: centerBorder,
        right: rightBorder
      });
    };

    COMRichTextAnchor.prototype.getCorrespondingBoundary = function() {
      var i, index, item, len, offset, ref, result;
      offset = this.index;
      ref = this.node.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        if (offset > item.length) {
          offset -= item.length;
        } else if (offset === item.length) {
          if (item.sortOf("Rune") || this.inside) {
            offset -= item.length;
          } else if (item.noTailingBoundary || this.node.childNoTailingBoundary) {
            offset -= item.length;
          } else {
            result = item.getCorrespondingBoundaryByOffset(offset, {
              right: true
            });
            if (result) {
              return result;
            } else {
              offset -= item.length;
            }
          }
        } else {
          if (offset === 0 && item.sortOf("Rune") && this.inside) {
            return {
              node: item.el,
              type: "include"
            };
          }
          return item.getCorrespondingBoundaryByOffset(offset, {
            right: true
          });
        }
      }
      if (offset === 0) {
        return {
          node: this.node.holder.textNode,
          offset: 0,
          type: "left"
        };
      }
      return null;
    };

    COMRichTextAnchor.prototype.IMEReplace = function(before, after) {
      var cs, index, offset, rune, shouldBe;
      if (this.inside && (rune = this.node.runeAtIndex(this.index))) {
        this.index += rune.contentString.length;
      }
      cs = this.node.contentString;
      shouldBe = cs.slice(this.index - before.length, this.index);
      if (shouldBe !== before) {
        return false;
      }
      offset = 0;
      while (before[offset] && before[offset] === after[offset]) {
        offset += 1;
        continue;
      }
      before = before.slice(offset);
      after = after.slice(offset);
      index = this.index;
      if (before) {
        this.node.removeText(index - before.length, before.length);
      }
      if (after) {
        this.node.insertText(index - before.length, after);
      }
      return true;
    };

    COMRichTextAnchor.prototype.getIMEAnchor = function(string) {
      var cs, end, start;
      cs = this.node.contentString;
      if (cs.slice(this.index - string.length, this.index) === string) {
        start = this.clone();
        start.index = this.index - string.length;
        end = this.clone();
        return {
          start: start,
          end: end
        };
      }
      return {};
    };

    COMRichTextAnchor.prototype.write = function(value) {
      var rune;
      if (value == null) {
        value = null;
      }
      if (!value) {
        return false;
      }
      this.node.reflow();
      if (this.inside && (rune = this.node.runeAtIndex(this.index))) {
        this.index = rune.endOffset;
      }
      if (value instanceof COMNode && value.sortOf("Rune")) {
        this.node.insertRune(this.index, value);
        return true;
      }
      if (typeof value === "string") {
        value = value.replace(/\t/g, "").replace(/\r\n/g, "\n").replace(/[\r\b\f\v\0]/g, "");
      }
      this.node.insertText(this.index, value);
      return true;
    };

    COMRichTextAnchor.prototype.setByDOM = function(node, offset) {
      var fix, i, last, len, ref, ref1, ref2, result, text;
      if (!(typeof node instanceof Text)) {
        node = node.childNodes[offset] || node;
      }
      if (!this.node.el.contains(node)) {
        return null;
      }
      this.node.reflow();
      if (result = (ref = this.node) != null ? ref.getOffsetByDOM(node, offset) : void 0) {
        if (result) {
          this.index = result.index;
          this.inside = result.inside;
          return true;
        }
      }
      if (node === this.node.holder.textNode) {
        last = this.node.last();
        if (last != null ? last.blockTail : void 0) {
          fix = -1;
        } else {
          fix = 0;
        }
        this.index = (((ref1 = this.node.last()) != null ? ref1.endOffset : void 0) || 0) + fix;
        return true;
      }
      ref2 = this.node.children;
      for (i = 0, len = ref2.length; i < len; i++) {
        text = ref2[i];
        result = text.detectTextOffset(node, offset);
        if (result) {
          if (text.sortOf("Rune")) {
            this.index = text.startOffset;
            this.inside = true;
            return true;
          }
          this.index = text.startOffset + result.offset;
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.deleteBetween = function(anchor) {
      var end, endInside, position, rune, start, startInside;
      if (!anchor) {
        return false;
      }
      if (anchor.node !== this.node) {
        return false;
      }
      position = this.compare(anchor);
      if (position === "after") {
        return anchor.deleteBetween(this);
      }
      if (position === "identical") {
        return false;
      }
      if (position === "under") {
        return false;
      }
      if (position === "contain") {
        return false;
      }
      if (position !== "before") {
        throw new Errors.LogicError("position should be before");
      }
      start = this.index;
      end = anchor.index;
      startInside = this.inside;
      endInside = anchor.inside;
      anchor.index = this.index;
      if (endInside) {
        rune = this.node.runeAtIndex(end);
        if (rune) {
          this.node.removeText(end, 1);
        }
      }
      if (end !== start) {
        this.node.removeText(start, end - start);
      }
      if (startInside) {
        rune = this.node.runeAtIndex(start);
        if (rune) {
          this.node.removeText(start, 1);
          this.index -= rune.contentString.length;
          anchor.index -= rune.contentString.length;
        }
      }
      return true;
    };

    COMRichTextAnchor.prototype.equal = function(target) {
      if (!target) {
        return false;
      }
      return target.node === this.node && target.index === this.index && target.inside === this.inside;
    };

    COMRichTextAnchor.prototype.clone = function() {
      var anchor;
      anchor = new COMRichTextAnchor(this.node);
      anchor.index = this.index;
      anchor.inside = this.inside;
      return anchor;
    };

    COMRichTextAnchor.prototype.split = function() {
      var after;
      if (this.index === this.node.length || this.index === 0) {
        return false;
      }
      after = this.node.contentString.slice(this.index);
      this.node.removeText(this.index, this.node.length - this.index);
      this.node.after(new COMRichText(this.node.context, {
        contentString: after
      }));
      return true;
    };

    COMRichTextAnchor.prototype.previousRune = function() {
      var i, item, ref, target;
      this.node.reflow();
      target = null;
      ref = this.node.children;
      for (i = ref.length - 1; i >= 0; i += -1) {
        item = ref[i];
        if (!item.sortOf("Rune")) {
          continue;
        }
        if (item.startOffset < this.index) {
          target = item;
          this.index = item.startOffset;
          this.inside = true;
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.nextRune = function(option) {
      var i, item, len, ref;
      this.node.reflow();
      ref = this.node.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (!item.trigger || item.noTriggerFocus) {
          continue;
        }
        if (item.startOffset > this.index || (item.startOffset === this.index && option.fresh)) {
          this.index = item.startOffset;
          if (item.sortOf("Rune")) {
            this.inside = true;
          }
          return true;
        } else if (item.startOffset === this.index && !this.inside && item.sortOf("Rune")) {
          this.inside = true;
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.previousRune = function() {
      var i, item, ref, target;
      this.node.reflow();
      target = null;
      ref = this.node.children;
      for (i = ref.length - 1; i >= 0; i += -1) {
        item = ref[i];
        if (!item.trigger || item.noTriggerFocus) {
          continue;
        }
        if (item.startOffset < this.index) {
          target = item;
          this.index = item.startOffset;
          if (item.sortOf("Rune")) {
            this.inside = true;
          }
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.afterRune = function(rune) {
      if (rune.parent !== this.node) {
        return false;
      }
      this.node.reflow();
      this.index = rune.startOffset + rune.length;
      return true;
    };

    COMRichTextAnchor.prototype.atRune = function(rune) {
      if (rune.parent !== this.node) {
        return false;
      }
      this.node.reflow();
      this.index = rune.startOffset;
      return this.inside = true;
    };

    COMRichTextAnchor.prototype.beforeRune = function(rune) {
      if (rune.parent !== this.node) {
        return false;
      }
      this.node.reflow();
      this.index = rune.startOffset;
      return true;
    };

    COMRichTextAnchor.prototype.compare = function(anchor) {
      var parentAnchor, position, target, targetAnchor;
      if (anchor instanceof COMAnchor && anchor.node === this.node) {
        if (this.index > anchor.index) {
          return "after";
        } else if (this.index < anchor.index) {
          return "before";
        } else if (this.index === anchor.index) {
          return "identical";
        }
        return null;
      } else if (!(anchor instanceof COMAnchor)) {
        if (anchor.leftMost) {
          if (this.leftMost) {
            return "identical";
          } else {
            return "after";
          }
        } else if (anchor.rightMost) {
          if (this.rightMost) {
            return "identical";
          } else {
            return "before";
          }
        }
        return null;
      }
      position = this.node.compareNodePosition(anchor.node);
      if (!position) {
        return null;
      }
      if (position === "before") {
        return "before";
      }
      if (position === "after") {
        return "after";
      }
      if (position === "identical") {
        throw new Errors.LogicError("can't have anchor has identical path but point to different node");
      }
      if (position === "under") {
        target = this.node;
        while (target.parent !== anchor.node && target) {
          target = target.parent;
        }
        if (!target) {
          throw new Errors.Logic("node.compare returns under but find no common parent");
        }
        parentAnchor = target.parent.anchor.clone();
        parentAnchor.pointAt(target);
        parentAnchor.inside = true;
        if (parentAnchor.index > anchor.index) {
          return "after";
        } else if (parentAnchor.index < anchor.index) {
          return "before";
        } else if (parentAnchor.inside && !anchor.index) {
          return "after";
        } else if (!parentAnchor.inside && anchor.inside) {
          return "before";
        } else {
          return "under";
        }
      }
      if (position === "contain") {
        target = anchor.node;
        while (target && target.parent !== this.node) {
          target = target.parent;
        }
        if (!target) {
          throw new Errors.LogicError("node.compare returns contain but find no common parent");
        }
        targetAnchor = target.parent.anchor.clone();
        targetAnchor.pointAt(target);
        targetAnchor.inside = true;
        if (this.index > targetAnchor.index) {
          return "after";
        } else if (this.index < targetAnchor.index) {
          return "before";
        } else if (this.inside && !targetAnchor.index) {
          return "after";
        } else if (!this.inside && targetAnchor.inside) {
          return "before";
        } else {
          return "contain";
        }
      } else {
        throw new Errros.LogicError("unexpected node compare turn " + position);
      }
    };

    COMRichTextAnchor.prototype.pointAt = function(target) {
      var i, item, len, ref;
      this.node.reflow();
      ref = this.node.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (target === item) {
          this.index = target.startOffset;
          if (target.sortOf("Rune")) {
            this.inside = true;
          }
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.getCaretStyle = function() {
      return this.node.caretStyle || null;
    };

    COMRichTextAnchor.prototype.matchingBeforeText = function(string) {
      var cs;
      cs = this.node.contentString;
      return cs.slice(this.index - string.length, this.index) === string;
    };

    COMRichTextAnchor.prototype.getSurroundingWord = function(count) {
      var afterContent, afterCount, beforeContent, beforeCount, char, charReg, cs, index;
      if (count == null) {
        count = 5;
      }
      if (this.inside) {
        return null;
      }
      cs = this.node.contentString;
      index = this.index;
      beforeCount = count;
      afterCount = count;
      charReg = /[a-z'"]/i;
      while (beforeCount > 0) {
        char = cs[index - 1];
        if (char === " ") {
          while (cs[index - 1] === " ") {
            index -= 1;
          }
          beforeCount -= 1;
          continue;
        }
        if (!char || !charReg.test(char)) {
          break;
        }
        index -= 1;
      }
      if (index < 0) {
        index = 0;
      }
      beforeContent = cs.slice(index, this.index);
      index = this.index;
      while (afterCount > 0) {
        char = cs[index];
        if (char === " ") {
          while (cs[index] === " ") {
            index -= 1;
          }
          afterCount -= 1;
          continue;
        }
        if (!char || !charReg.test(char)) {
          break;
        }
        index += 1;
      }
      afterContent = cs.slice(this.index, index);
      return {
        before: beforeContent,
        after: afterContent
      };
    };

    COMRichTextAnchor.prototype.getSurroundingText = function(count) {
      var after, before, cs, start;
      if (count == null) {
        count = 5;
      }
      if (this.inside) {
        return null;
      }
      cs = this.node.contentString;
      start = this.index - count;
      if (start < 0) {
        start = 0;
      }
      before = cs.slice(start, this.index);
      after = cs.slice(this.index, this.index + count);
      return {
        before: before,
        after: after
      };
    };

    return COMRichTextAnchor;

  })(COMAnchor);

  module.exports = COMRichTextAnchor;

}).call(this);

}
GlobalContext.setModule("vincent/com/richTextAnchor.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/root.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMComposer, COMContainer, COMRoot, RootAvoidEmpty,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMComposer = require("./composer");

  COMContainer = require("./container");

  COMRoot = (function(superClass) {
    extend(COMRoot, superClass);

    COMRoot.prototype.type = "Root";

    function COMRoot(context, data) {
      var ref;
      this.context = context;
      this.data = data;
      this.appearance = {
        tagName: "div",
        classList: ["com", "com-root"]
      };
      this.withContext = ((ref = this.data) != null ? ref.withContext : void 0) || false;
      this.isRoot = true;
      COMRoot.__super__.constructor.call(this, this.context);
      this.pend();
      this.root = this;
      this.fromJSON(this.data);
    }

    COMRoot.prototype.pend = function() {
      return COMRoot.__super__.pend.call(this);
    };

    COMRoot.prototype.contains = function(node) {
      return Util.topLevel(node) === this;
    };

    COMRoot.prototype.getChildByPath = function(path) {
      var index, node, routes;
      if (path == null) {
        path = null;
      }
      if (!path) {
        return null;
      }
      routes = path.getRoutes();
      if (routes.length === 0) {
        return this;
      }
      routes = routes.slice(0);
      node = this;
      while (true) {
        if (routes.length === 0) {
          return node;
        }
        index = routes.pop();
        if (node && node.children && node.children[index]) {
          node = node.children[index];
          continue;
        } else {
          return null;
        }
      }
    };

    COMRoot.prototype.render = function(rc) {
      COMRoot.__super__.render.call(this, rc, {
        recursive: true,
        selfless: true
      });
      rc.el = this.el;
      this.afterRender();
      if (!this.rc.interactive) {
        return this.el.classList.add("readonly");
      } else {
        return this.el.classList.remove("readonly");
      }
    };

    COMRoot.prototype._attach = function(node) {
      COMRoot.__super__._attach.call(this, node);
      return node.root = this;
    };

    COMRoot.prototype.toJSON = function(option) {
      var json;
      json = COMRoot.__super__.toJSON.call(this, option);
      if (!json) {
        return null;
      }
      json.type = "Root";
      return json;
    };

    COMRoot.prototype.fromJSON = function(json) {
      var result;
      if (json == null) {
        json = {};
      }
      if (json.type !== "Root") {
        return;
      }
      result = COMRoot.__super__.fromJSON.call(this, json);
      return result;
    };

    return COMRoot;

  })(COMContainer);

  RootAvoidEmpty = (function(superClass) {
    extend(RootAvoidEmpty, superClass);

    function RootAvoidEmpty() {
      return RootAvoidEmpty.__super__.constructor.apply(this, arguments);
    }

    RootAvoidEmpty.prototype.type = "Root";

    RootAvoidEmpty.prototype.exec = function() {
      var ct, ref;
      if (((ref = this.target.children) != null ? ref.length : void 0) > 0) {
        return false;
      }
      ct = this.context.createElement("Contents", {
        children: [
          this.context.createElement("RichText", {
            contentString: ""
          })
        ]
      });
      this.target.append(ct);
      return true;
    };

    return RootAvoidEmpty;

  })(COMComposer);

  COMRoot.RootAvoidEmpty = RootAvoidEmpty;

  module.exports = COMRoot;

}).call(this);

}
GlobalContext.setModule("vincent/com/root.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/rune.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMContainer, COMDecorationPolicy, COMRune, COMText, COMTrapPolicy, COMVisualPosition, Decoration, DraggableTrait, Trait,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMContainer = require("./container");

  COMTrapPolicy = require("./trapPolicy");

  COMDecorationPolicy = require("./decorationPolicy");

  Decoration = require("./decoration");

  Trait = require("./helper/trait");

  COMVisualPosition = require("./visualPosition");

  COMText = require("./text");

  COMRune = (function(superClass) {
    extend(COMRune, superClass);

    COMRune.RunePlaceBegin = "\uE1F5";

    COMRune.RunePlaceEnd = "\uE1F6";

    COMRune.RunePurifyHolder = "\uE1F7";

    COMRune.purifyContentString = function(string, option) {
      var replacement;
      if (option == null) {
        option = {};
      }
      replacement = " ";
      if (option.useHolder) {
        replacement = this.RunePurifyHolder;
      }
      return string.replace(new RegExp("\uE1F5[^\uE1F5\uE1F6]*\uE1F6", "g"), function(content) {
        return content.replace(/(?:.|\n)/ig, replacement);
      });
    };

    COMRune.prototype.type = "Rune";

    COMRune.prototype.isEmpty = function() {
      return false;
    };

    function COMRune(context, data) {
      this.context = context;
      this.data = data;
      COMRune.__super__.constructor.call(this, this.context, this.data);
      this.editor = this.context.editor;
      this.rightCaretPriority = 0;
      this.leftCaretPriority = 0;
      this.parentAppearance = [];
      this.decorations = [];
      this.trapPolicy = new COMTrapPolicy(this).behave({
        trap: "ignore"
      });
      this.decorationPolicy = new COMDecorationPolicy(this).behave({
        behavior: "singular"
      });
      this.context.runeCache.assign(this);
      this.__defineGetter__("length", function() {
        return this.cid.toString().length + 2;
      });
      this.__defineGetter__("contentString", function() {
        return COMRune.RunePlaceBegin + this.cid + COMRune.RunePlaceEnd;
      });
      this.triggerByClick = this.triggerByClick.bind(this);
      this.layout = "inline";
      new DraggableTrait(this);
    }

    COMRune.prototype.onRootDispel = function() {
      this.context.runeCache.release(this);
      return COMRune.__super__.onRootDispel.call(this);
    };

    COMRune.prototype.onRootAvailable = function() {
      this.context.runeCache.reuse(this);
      return COMRune.__super__.onRootAvailable.call(this);
    };

    COMRune.prototype.render = function(rc, option) {
      var dec, i, j, len, len1, ref, ref1;
      COMRune.__super__.render.call(this, rc, option);
      ref = this.previousDecorations || [];
      for (i = 0, len = ref.length; i < len; i++) {
        dec = ref[i];
        dec.cancel(this.el);
      }
      ref1 = this.decorations;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        dec = ref1[j];
        dec.apply(this.el);
      }
      return this.handleDragElement(this.el);
    };

    COMRune.prototype.triggerByClick = function(e) {
      if (this.trigger) {
        if (this.trigger()) {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
      }
    };

    COMRune.prototype.toProtocolDatas = function() {
      return [
        {
          type: this.type,
          data: this
        }
      ];
    };

    COMRune.prototype.setDecorations = function(decorations) {
      var ref;
      if (this.previousDecorations == null) {
        this.previousDecorations = [];
      }
      (ref = this.previousDecorations).push.apply(ref, this.decorations || []);
      return this.context.operate(new Decoration.ChangeDecorationOperation(this.context, this, {
        decorations: decorations
      }));
    };

    COMRune.prototype.detectTextOffset = function(el) {
      if (this.el.contains(el || this.el === el)) {
        return {
          offset: 0,
          part: this.el
        };
      }
    };

    COMRune.prototype.getVisualBorder = function(offset, relativeToCursor) {
      var i, index, item, len, position, priority, ref, targetIndex;
      targetIndex = 0;
      ref = this.el.parentElement.childNodes;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        if (item === this.el) {
          targetIndex = index;
          break;
        }
      }
      position = "left";
      if (offset === this.length || relativeToCursor === "left") {
        position = "right";
      }
      if (relativeToCursor === "inside") {
        position = "contain";
      }
      if (relativeToCursor === "right") {
        priority = this.leftCaretPriority || 0;
      } else if (relativeToCursor === "left") {
        priority = this.rightCaretPriority || 0;
      } else {
        priority = 0;
      }
      return new COMVisualPosition.COMVisualBorder({
        node: this.el.parentElement,
        offset: targetIndex,
        position: position,
        priority: priority
      });
    };

    COMRune.prototype.getCorrespondingBoundaryByOffset = function(offset, inside) {
      var i, index, item, len, ref, targetIndex;
      ref = this.el.parentElement.childNodes;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        if (item === this.el) {
          targetIndex = index;
          break;
        }
      }
      if (offset === 0) {
        return {
          node: this.el.parentElement,
          offset: targetIndex,
          via: "RuneBefore"
        };
      } else if (offset < this.length || inside) {
        return {
          node: this.el,
          type: "include",
          via: "RuneInclude"
        };
      } else {
        return {
          node: this.el.parentElement,
          offset: targetIndex + 1,
          via: "RuneAfter"
        };
      }
      return null;
    };

    COMRune.prototype.slice = function() {
      return this.clone();
    };

    COMRune.prototype.clone = function() {
      return this.context.createElement(this.type, this.toJSON());
    };

    COMRune.prototype.insertText = function(start, value) {
      if (start === 0) {
        return this.before(new COMText(this.context, {
          contentString: value
        }));
      }
      if (start > 0) {
        return this.after(new COMText(this.context, {
          contentString: value
        }));
      }
      return false;
    };

    COMRune.prototype.toHumanString = function() {
      return "";
    };

    COMRune.prototype.removeText = function(start, length) {
      this.remove();
      return true;
    };

    COMRune.prototype.toHumanString = function() {
      return "<Rune " + this.type + ">";
    };

    return COMRune;

  })(COMContainer);

  DraggableTrait = (function(superClass) {
    extend(DraggableTrait, superClass);

    function DraggableTrait() {
      return DraggableTrait.__super__.constructor.apply(this, arguments);
    }

    DraggableTrait.prototype.enableDragBehavior = function(option) {
      if (option == null) {
        option = {};
      }
      if (this.dragBehaviorRegistered) {
        return;
      }
      this.dragBehaviorRegistered = true;
      return this.dragOption = option;
    };

    DraggableTrait.prototype.handleDragElement = function(el) {
      if (!this.dragBehaviorRegistered) {
        return;
      }
      if (el.runeDragAdded) {
        return;
      }
      el.runeDragAdded = true;
      el.dragSupport = "support";
      el.dragBehavior = "auto";
      return el.addEventListener("user-draginit", (function(_this) {
        return function(e) {
          var i, item, len, ref, ref1, results;
          ref = _this.getDragProtocols();
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            results.push((ref1 = e.detail) != null ? typeof ref1.addProtocol === "function" ? ref1.addProtocol(item.type, item.data) : void 0 : void 0);
          }
          return results;
        };
      })(this));
    };

    DraggableTrait.prototype.getDragProtocols = function() {
      var base, extra, result;
      result = [
        {
          type: "Rune",
          data: this
        }
      ];
      extra = (typeof (base = this.dragOption).getDragProtocol === "function" ? base.getDragProtocol(this) : void 0) || [];
      return extra.concat(result);
    };

    return DraggableTrait;

  })(Trait);

  module.exports = COMRune;

}).call(this);

}
GlobalContext.setModule("vincent/com/rune.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/runeCache.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMRuneCache;

  COMRuneCache = (function() {
    function COMRuneCache(context) {
      var i, index, ref, zeros;
      this.context = context;
      this.cid = 0;
      this.cidWidth = 8;
      this.instances = {};
      this.prefixMap = {};
      zeros = "";
      for (index = i = 0, ref = this.cidWidth; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
        this.prefixMap[index] = zeros;
        zeros += "0";
      }
      this.trashes = {};
    }

    COMRuneCache.prototype.release = function(rune) {
      if (!this.trashes[rune.cid]) {
        return this.trashes[rune.cid] = rune;
      }
    };

    COMRuneCache.prototype.reuse = function(rune) {
      delete this.trashes[rune.cid];
      if (!this.instances[rune.cid]) {
        return this.instances[rune.cid] = rune;
      }
    };

    COMRuneCache.prototype.gc = function() {
      var prop, ref, results, rune;
      ref = this.trashes;
      results = [];
      for (prop in ref) {
        rune = ref[prop];
        delete this.instances[rune.cid];
        results.push(delete this.trashes[rune.cid]);
      }
      return results;
    };

    COMRuneCache.prototype.allocate = function() {
      var append, id;
      id = this.cid++;
      id = id.toString();
      append = this.cidWidth - 2 - id.length;
      id = this.prefixMap[append] + id;
      return id;
    };

    COMRuneCache.prototype.assign = function(node) {
      if (typeof node.cid !== "number") {
        node.cid = this.allocate();
      }
      this.instances[node.cid] = node;
      return node.cid;
    };

    COMRuneCache.prototype.cloneByCid = function(cid) {
      var item;
      if (!this.instances[cid]) {
        return null;
      }
      item = this.instances[cid];
      return item.clone();
    };

    return COMRuneCache;

  })();

  module.exports = COMRuneCache;

}).call(this);

}
GlobalContext.setModule("vincent/com/runeCache.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/selection.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMCursor, COMSelection, Errors, WalkerRootFirst,
    slice = [].slice;

  COMCursor = require("./cursor");

  WalkerRootFirst = (require("./helper/walker")).WalkerRootFirst;

  Errors = require("./errors");

  COMSelection = (function() {
    function COMSelection(context, cursor) {
      this.context = context;
      this.baseCursor = this.context.createCursor({
        isShadow: true,
        name: "baseCursor"
      });
      this.extentCursor = cursor;
      this.__defineGetter__("baseAnchor", function() {
        return this.baseCursor.anchor;
      });
      this.__defineGetter__("extentAnchor", function() {
        return this.extentCursor.anchor;
      });
    }

    COMSelection.prototype.fromAnchor = function(baseAnchor, extentAnchor) {
      this.baseCursor.pointAtAnchor(baseAnchor);
      this.extentCursor.pointAtAnchor(extentAnchor);
      if (!this.isActive) {
        this.collapseToCursor();
      }
      return true;
    };

    COMSelection.prototype.fromDOMRegion = function(base, extent) {
      if (!this.baseCursor.setCursorByDOMRegion(base)) {
        return false;
      }
      if (!this.extentCursor.setCursorByDOMRegion(extent)) {
        return false;
      }
      if (!this.isActive) {
        this.collapseToCursor();
      }
      return true;
    };

    COMSelection.prototype.activate = function() {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      return this.collapseToCursor();
    };

    COMSelection.prototype.deactivate = function() {
      if (!this.isActive) {
        return;
      }
      return this.isActive = false;
    };

    COMSelection.prototype.cancel = function() {
      this.collapseToCursor();
      return this.deactivate();
    };

    COMSelection.prototype.collapseToBegin = function() {
      var position, ref, swap;
      position = (ref = this.baseAnchor) != null ? ref.compare(this.extentAnchor) : void 0;
      if (!position) {
        return false;
      }
      if (position === "after") {
        swap = true;
      }
      if (swap) {
        return this.collapseToCursor(this.extentCursor);
      } else {
        return this.collapseToCursor(this.baseCursor);
      }
    };

    COMSelection.prototype.collapseToEnd = function() {
      var position, ref, swap;
      position = (ref = this.baseAnchor) != null ? ref.compare(this.extentAnchor) : void 0;
      if (!position) {
        return false;
      }
      if (position === "after") {
        swap = true;
      }
      if (swap) {
        return this.collapseToCursor(this.baseCursor);
      } else {
        return this.collapseToCursor(this.extentCursor);
      }
    };

    COMSelection.prototype.collapseToCursor = function(cursor) {
      if (cursor == null) {
        cursor = this.extentCursor;
      }
      if (!cursor || !cursor.anchor) {
        return false;
      }
      this.baseCursor.pointAtAnchor(cursor.anchor);
      if (cursor !== this.extentCursor) {
        this.extentCursor.pointAtAnchor(cursor.anchor);
      }
      return true;
    };

    COMSelection.prototype.baseAction = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.baseCursor).conduct.apply(ref, args);
    };

    COMSelection.prototype.extentAction = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.extentCursor).conduct.apply(ref, args);
    };

    COMSelection.prototype.clear = function() {
      this.baseAnchor = null;
      return this.extentAnchor = null;
    };

    COMSelection.prototype.isValid = function() {
      var ref, ref1;
      return (((ref = this.baseAnchor) != null ? ref.node.root : void 0) != null) && (((ref1 = this.extentAnchor) != null ? ref1.node.root : void 0) != null);
    };

    COMSelection.prototype.isCollapsed = function() {
      if (!this.baseAnchor || !this.extentAnchor) {
        return true;
      }
      return this.baseAnchor.node === this.extentAnchor.node && this.baseAnchor.index === this.extentAnchor.index && (this.baseAnchor.inside != null) === (this.extentAnchor.inside != null);
    };

    COMSelection.prototype.debug = function() {
      return this.baseAnchor.node.type + ":" + this.baseAnchor.index + "~" + this.extentAnchor.node.type + ":" + this.extentAnchor.index;
    };

    COMSelection.prototype.selectAll = function() {
      var first, last, walker;
      this.activate();
      walker = new WalkerRootFirst(this.context);
      if (!walker.first(function(item) {
        return item.anchor;
      })) {
        return false;
      }
      first = walker.node;
      if (!walker.last(function(item) {
        return item.anchor;
      })) {
        return false;
      }
      last = walker.node;
      this.fromAnchor(first.anchor, last.anchor);
      this.baseCursor.conduct("head");
      return this.extentCursor.conduct("tail");
    };

    COMSelection.prototype.getSelectedCollection = function() {
      var anchor, beginAnchor, beginAnchorOrigin, beginNode, beginPosition, endAnchor, endAnchorOrigin, endNode, endPosition, position, result, results, swap, walker;
      if (!this.isValid()) {
        return null;
      }
      position = this.baseAnchor.compare(this.extentAnchor);
      if (position === "after") {
        swap = true;
      }
      if (!swap) {
        beginNode = this.baseAnchor.node;
        endNode = this.extentAnchor.node;
        beginAnchor = this.baseAnchor.clone();
        endAnchor = this.extentAnchor.clone();
        beginAnchorOrigin = this.baseAnchor;
        endAnchorOrigin = this.extentAnchor;
      } else {
        beginNode = this.extentAnchor.node;
        endNode = this.baseAnchor.node;
        beginAnchor = this.extentAnchor.clone();
        endAnchor = this.baseAnchor.clone();
        beginAnchorOrigin = this.extentAnchor;
        endAnchorOrigin = this.baseAnchor;
      }
      walker = new WalkerRootFirst(this.context);
      walker.setNode(beginNode);
      results = [];
      while (true) {
        if (!walker.node) {
          break;
        }
        anchor = walker.node.anchor.clone();
        anchor.head();
        beginPosition = anchor.compare(endAnchor);
        anchor.tail();
        endPosition = anchor.compare(endAnchor);
        position = walker.node.compareNodePosition(endNode);
        if (beginPosition === "identical" || beginPosition === "after") {
          if (beginPosition === "identical") {
            results.push(walker.node);
          }
          break;
        }
        if (endPosition === "before") {
          results.push(walker.node);
          walker.skipChildOnce = true;
          if (!walker.next((function(item) {
            return item.anchor;
          }))) {
            break;
          }
          continue;
        }
        if (endPosition === "identical") {
          results.push(walker.node);
          break;
        }
        if (endPosition === "after") {
          results.push(walker.node);
          break;
        }
        if (endPosition === "under" || endPosition === "contain") {
          results.push(walker.node);
          break;
        }
        throw new Errors.LogicError("anchor compare returns unexpected value " + beginPosition + " " + endPosition);
      }
      result = {
        beginNode: beginNode,
        endNode: endNode,
        beginAnchor: beginAnchor,
        endAnchor: endAnchor,
        nodes: results,
        beginAnchorOrigin: beginAnchorOrigin,
        endAnchorOrigin: endAnchorOrigin
      };
      return result;
    };

    COMSelection.prototype.copySelectedNodes = function() {
      var collection, result;
      collection = this.getSelectedCollection();
      result = this.context.root.slice({
        left: collection.beginAnchor,
        right: collection.endAnchor,
        selection: true
      });
      return result;
    };

    COMSelection.prototype.cutSelectedNodes = function() {
      var result;
      result = this.copySelectedNodes();
      this.removeSelectedNodes();
      return result;
    };

    COMSelection.prototype.removeSelectedNodes = function() {
      var collection, head, i, len, node, ref, tail;
      collection = this.getSelectedCollection();
      if (collection.beginNode === collection.endNode) {
        collection.beginAnchor.deleteBetween(collection.endAnchor);
      } else {
        ref = collection.nodes;
        for (i = 0, len = ref.length; i < len; i++) {
          node = ref[i];
          if (node === collection.beginNode) {
            tail = collection.beginAnchor.clone();
            tail.tail();
            collection.beginAnchor.deleteBetween(tail);
          } else if (node === collection.endNode) {
            head = collection.endAnchor.clone();
            head.head();
            head.deleteBetween(collection.endAnchor);
          } else {
            node.remove();
          }
        }
      }
      collection.beginNode.anchor.fromJSON(collection.beginAnchor.toJSON());
      this.extentCursor.pointAtAnchor(collection.beginAnchor);
      this.collapseToCursor();
      this.cancel();
      return collection;
    };

    return COMSelection;

  })();

  module.exports = COMSelection;

}).call(this);

}
GlobalContext.setModule("vincent/com/selection.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/spell.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMSpell, COMText, Errors,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  COMText = require("./text");

  Errors = require("./errors");

  COMSpell = (function(superClass) {
    extend(COMSpell, superClass);

    COMSpell.prototype.test = function() {
      return false;
    };

    COMSpell.prototype.type = "Spell";

    COMSpell.prototype.isSpell = true;

    function COMSpell(context, option1) {
      this.context = context;
      this.option = option1 != null ? option1 : {};
      this.decorationMaintainers = [];
      COMSpell.__super__.constructor.call(this, this.context, this.option);
      this.decorationPolicy.behave({
        behavior: "singular"
      });
    }

    COMSpell.prototype.addDecorationMaintainer = function(maintainer) {
      return this.decorationMaintainers.push(maintainer);
    };

    COMSpell.prototype.toNormalTextInPlace = function() {
      return this.replaceBy(new COMText(this.context, {
        contentString: this.contentString
      }));
    };

    COMSpell.prototype.render = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return COMSpell.__super__.render.apply(this, args);
    };

    COMSpell.prototype.setDecorations = function(decs) {
      var _decs, cs, dm, i, len, ref;
      if (this.decorationPolicy.behavior === "break") {
        decs = [];
      }
      if (decs == null) {
        decs = [];
      }
      cs = this.contentString;
      ref = this.decorationMaintainers;
      for (i = 0, len = ref.length; i < len; i++) {
        dm = ref[i];
        _decs = dm.compute(cs);
        decs.push.apply(decs, _decs);
      }
      return COMSpell.__super__.setDecorations.call(this, decs);
    };

    COMSpell.prototype.castToText = function(text, start, end) {
      var last, middle, ref;
      if (end < start) {
        throw new Errors.LogicError("end should larger that start");
      }
      middle = text.splitInPlace(start);
      if (!middle) {
        middle = text;
      }
      last = middle.splitInPlace(end - start) || null;
      middle.replaceBy(this);
      this.contentString = middle.contentString;
      this.compose();
      this.dirty = true;
      if ((ref = this.parent) != null) {
        ref.dirty = true;
      }
      return last;
    };

    COMSpell.prototype.compose = function() {
      this.setDecorations();
      return false;
    };

    COMSpell.prototype.toJSON = function(option) {
      var json;
      json = COMSpell.__super__.toJSON.call(this, option);
      if (!json) {
        return null;
      }
      json.spell = true;
      return json;
    };

    return COMSpell;

  })(COMText);

  module.exports = COMSpell;

}).call(this);

}
GlobalContext.setModule("vincent/com/spell.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/text.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMDecorationPolicy, COMNode, COMText, COMVisualPosition, Decoration, InsertTextOperation, Operation, RemoveTextOperation,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMNode = require("./node");

  COMVisualPosition = require("./visualPosition");

  COMDecorationPolicy = require("./decorationPolicy");

  Decoration = require("./decoration");

  Operation = require("./operation");

  COMText = (function(superClass) {
    extend(COMText, superClass);

    COMText.prototype.type = "Text";

    COMText.prototype.toString = function() {
      return this.contentString;
    };

    COMText.prototype.isEmpty = function() {
      return this.contentString.length === 0;
    };

    COMText.prototype.toHumanString = function() {
      return this.toString();
    };

    function COMText(context, data) {
      var ref;
      this.context = context;
      this.data = data != null ? data : {};
      this.skipDirtyCheck = true;
      this.contentString = ((ref = this.data.contentString) != null ? typeof ref.toString === "function" ? ref.toString() : void 0 : void 0) || "";
      this.decorationPolicy = new COMDecorationPolicy(this).behave({
        behavior: "default"
      });
      this.decorationMaintainers = [];
      this.decorations = [];
      this.editIndex = 0;
      this.__defineGetter__("holder", function() {
        if (!this.cache) {
          return null;
        }
        if (!this.cache.holder) {
          this.cache.holder = document.createElement("span");
          this.cache.holder.innerHTML = " ";
          this.cache.holder.classList.add("com-text-holder");
        }
        return this.cache.holder;
      });
      this.__defineGetter__("partials", function() {
        return this.cache.partial || [];
      });
      this.__defineSetter__("partials", function(value) {
        return this.cache.partial = value;
      });
      if (this.appearance == null) {
        this.appearance = {
          tagName: "span",
          classList: ["com", "com-text"]
        };
      }
      this.__defineGetter__("withHolder", (function(_this) {
        return function() {
          return _this._withHolder;
        };
      })(this));
      this.__defineSetter__("withHolder", (function(_this) {
        return function(v) {
          if (v !== _this._withHolder) {
            _this.dirty = true;
          }
          _this._withHolder = v;
          return _this._withHolder;
        };
      })(this));
      this.withHolder = this.data.withHolder;
      COMText.__super__.constructor.call(this, this.context);
      this.__defineGetter__("length", function() {
        return this.contentString.length;
      });
    }

    COMText.prototype.mergeInPlace = function(target) {
      target.remove();
      this.insertText(this.contentString.length, target.contentString);
      return true;
    };

    COMText.prototype.splitInPlace = function(index, option) {
      var next;
      if (option == null) {
        option = {};
      }
      if (index >= this.contentString.length) {
        return null;
      }
      if (index === 0) {
        return null;
      }
      next = this.contentString.slice(index);
      this.removeText(index);
      next = new COMText(this.context, {
        contentString: next
      });
      this.after(next);
      return next;
    };

    COMText.prototype.render = function(rc) {
      var container, content, dec, frag, i, index, j, len, len1, partial, property, ref, ref1, ref2, ref3, value;
      COMText.__super__.render.call(this, rc, {
        force: true
      });
      this.computePartials();
      frag = document.createDocumentFragment();
      ref = this.partials;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        partial = ref[index];
        partial.el = document.createElement("span");
        partial.el.classList.add("com-text-part");
        partial.el.com = this;
        partial.el.comText = this;
        partial.el.comPartial = partial;
        content = partial.content;
        if (index === this.partials.length - 1 && this.blockTail && content.slice(-1) === "\n") {
          if (this.keepNewlineSpace) {
            content = content.slice(0, -1) + " ";
          } else {
            content = content.slice(0, -1) + "";
          }
        }
        partial.textNode = document.createTextNode(content.toString());
        partial.el.appendChild(partial.textNode);
        ref1 = partial.decorations;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          dec = ref1[j];
          dec.apply(partial.el);
        }
        frag.appendChild(partial.el);
      }
      if (this.withHolder) {
        frag.appendChild(this.holder);
      }
      ref2 = this.domProperty || {};
      for (property in ref2) {
        value = ref2[property];
        if ((ref3 = this.el) != null) {
          ref3.setAttribute(property, value);
        }
      }
      container = this.specifyTextContainer();
      container.innerHTML = "";
      return container.appendChild(frag);
    };

    COMText.prototype.specifyTextContainer = function() {
      return this.el;
    };

    COMText.prototype.computePartials = function() {
      var cut, cuts, dec, decorations, i, index, item, j, k, l, len, len1, len2, len3, len4, m, nextCut, nextDec, part, partials, ref;
      partials = [];
      cuts = [0, this.contentString.length];
      ref = this.decorations;
      for (i = 0, len = ref.length; i < len; i++) {
        dec = ref[i];
        for (index = j = 0, len1 = cuts.length; j < len1; index = ++j) {
          item = cuts[index];
          if (item === dec.start) {
            break;
          }
          if (item < dec.start) {
            continue;
          } else {
            cuts.splice(index, 0, dec.start);
            break;
          }
        }
        for (index = k = 0, len2 = cuts.length; k < len2; index = ++k) {
          item = cuts[index];
          if (item === dec.end) {
            break;
          }
          if (item < dec.end) {
            continue;
          } else {
            cuts.splice(index, 0, dec.end);
          }
        }
      }
      decorations = this.decorations.slice();
      for (index = l = 0, len3 = cuts.length; l < len3; index = ++l) {
        cut = cuts[index];
        nextCut = cuts[index + 1];
        if (!nextCut) {
          break;
        }
        part = {
          decorations: [],
          content: this.contentString.slice(cut, nextCut)
        };
        nextDec = [];
        for (m = 0, len4 = decorations.length; m < len4; m++) {
          dec = decorations[m];
          if (dec.end <= cut) {
            continue;
          }
          nextDec.push(dec);
          if (dec.start >= nextCut) {
            continue;
          }
          part.decorations.push(dec);
        }
        decorations = nextDec;
        partials.push(part);
      }
      this.partials = partials;
      return this.partials;
    };

    COMText.prototype.computePartialsBad = function() {
      var c, combination, decDirty, decRef, decorations, i, index, lastCombination, lastDecRef, partStart, partials, ref;
      partials = [];
      partStart = 0;
      decorations = this.decorations.slice();
      lastCombination = "";
      lastDecRef = [];
      for (index = i = 0, ref = this.contentString.length; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
        combination = "";
        decDirty = false;
        decRef = [];
        decorations = decorations.filter(function(dec, decIndex) {
          if (index < dec.start) {
            return true;
          } else if (index >= dec.end) {
            return false;
          }
          combination += dec.mid + "-";
          return decRef.push(dec);
        });
        if (combination !== lastCombination && index > 0) {
          c = this.contentString.slice(partStart, index);
          partials.push({
            content: this.contentString.slice(partStart, index),
            decorations: lastDecRef
          });
          partStart = index;
        }
        lastCombination = combination;
        lastDecRef = decRef;
      }
      if (partStart < this.contentString.length) {
        partials.push({
          content: this.contentString.slice(partStart, this.contentString.length),
          decorations: lastDecRef || []
        });
      }
      this.partials = partials;
      return this.partials;
    };

    COMText.prototype.insertText = function(start, value) {
      var result;
      if (typeof start !== "number") {
        Logger.error("cant insert text at " + start);
        return false;
      }
      if (!value) {
        Logger.error("insert text request value provided");
        return false;
      }
      result = this.context.operate(new InsertTextOperation(this.context, this, {
        start: start,
        value: value
      }));
      if (result) {
        this.pend();
        return true;
      }
      return false;
    };

    COMText.prototype.setDecorations = function(decorations) {
      return this.context.operate(new Decoration.ChangeDecorationOperation(this.context, this, {
        decorations: decorations
      }));
    };

    COMText.prototype.removeText = function(start, length) {
      var result;
      if (typeof start !== "number") {
        return false;
      }
      if (typeof length !== "number") {
        length = this.contentString.length - start;
      }
      if (start >= this.contentString.length) {
        return false;
      }
      if (start + length > this.contentString.length) {
        return false;
      }
      result = this.context.operate(new RemoveTextOperation(this.context, this, {
        start: start,
        length: length
      }));
      if (result) {
        this.pend();
        return true;
      }
      return false;
    };

    COMText.prototype.getVisualBorder = function(index, relativeToCursor) {
      var content, holderIndex, i, last, lastChar, len, nodes, offset, part, partIndex, partialOffset, position, previous, priority, ref, target;
      if (this.dirty && !this.skipDirtyCheck) {
        Logger.error("dirty query", this.root, this, this.dirty, this.context, this.rc.id, this.cache.rev, this.rev);
        throw new Error("shouldn't get caret position when dirty");
      }
      if (relativeToCursor !== "left" && relativeToCursor !== "right") {
        relativeToCursor = "left";
      }
      offset = 0;
      target = null;
      if (relativeToCursor !== "left" && relativeToCursor !== "right") {
        return true;
      }
      if (this.blockTail && index === this.contentString.length - 1) {
        part = this.partials[this.partials.length - 1];
        content = part.content;
        lastChar = content[content.length - 1];
        if (lastChar === "\n" && this.blockTail && this.withHolder) {
          if (relativeToCursor === "right") {
            nodes = [].slice.call(this.holder.parentElement.childNodes);
            holderIndex = nodes.indexOf(this.holder);
            return new COMVisualPosition.COMVisualBorder({
              node: this.holder.parentElement,
              offset: holderIndex,
              position: "left",
              priority: this.leftCaretPriority
            });
          }
        }
      }
      ref = this.partials;
      for (partIndex = i = 0, len = ref.length; i < len; partIndex = ++i) {
        part = ref[partIndex];
        if (offset === index) {
          if (relativeToCursor === "left") {
            previous = this.partials[partIndex - 1];
            if (previous) {
              target = previous;
              partialOffset = target.content.length - 1;
              position = "right";
              break;
            } else {
              target = part;
              partialOffset = 0;
              position = "left";
              break;
            }
          } else {
            target = part;
            partialOffset = 0;
            position = "left";
            break;
          }
        }
        if (offset + part.content.length > index) {
          partialOffset = index - offset;
          target = part;
          position = "left";
          break;
        }
        offset += part.content.length;
      }
      if (offset === index && !target) {
        if (offset === 0) {
          if (this.withHolder && this.holder && this.holder.parentElement) {
            nodes = [].slice.call(this.holder.parentElement.childNodes);
            holderIndex = nodes.indexOf(this.holder);
            return new COMVisualPosition.COMVisualBorder({
              node: this.holder.parentElement,
              offset: holderIndex,
              position: "left",
              priority: this.leftCaretPriority || 0
            });
          }
        }
        target = this.partials[this.partials.length - 1];
        if (relativeToCursor === "right") {
          if (target) {
            partialOffset = target.content.length - 1;
            position = "right";
          }
        } else if (relativeToCursor === "left") {
          if (this.holder && this.holder.parentElement && this.withHolder) {
            nodes = [].slice.call(this.holder.parentElement.childNodes);
            holderIndex = nodes.indexOf(this.holder);
            return new COMVisualPosition.COMVisualBorder({
              node: this.holder.parentElement,
              offset: holderIndex,
              position: "left",
              priority: this.leftCaretPriority || 0
            });
          } else {
            last = this.partials[this.partials.length - 1];
            return new COMVisualPosition.COMVisualBorder({
              node: last.textNode,
              offset: last.textNode.length - 1,
              position: "right",
              priority: this.leftCaretPriority || 0
            });
          }
        } else if (target) {
          partialOffset = target.content.length - 1;
          position = "right";
        }
      }
      if (!target) {
        return null;
      }
      if (position === "left") {
        priority = this.leftCaretPriority || 0;
      } else {
        priority = this.rightCaretPriority || 0;
      }
      return new COMVisualPosition.COMVisualBorder({
        node: target.textNode,
        offset: partialOffset,
        position: position,
        priority: priority
      });
    };

    COMText.prototype.getCorrespondingBoundaryByOffset = function(index, option) {
      var char, i, len, offset, part, partialOffset, ref, target;
      if (option == null) {
        option = {};
      }
      if (this.dirty && !this.skipDirtyCheck) {
        Logger.error("dirty query", this.root, this, this.dirty, this.context, this.rc.id, this.cache.rev, this.rev);
        throw new Error("shouldn't get caret position when dirty");
      }
      offset = 0;
      ref = this.partials;
      for (i = 0, len = ref.length; i < len; i++) {
        part = ref[i];
        offset += part.content.length;
        if (index < offset) {
          target = part;
          partialOffset = index - (offset - part.content.length);
          break;
        }
      }
      if (index === offset) {
        target = this.partials[this.partials.length - 1] || null;
        if (!target) {
          return null;
        }
        partialOffset = target.content.length;
        return {
          node: target.textNode,
          offset: partialOffset,
          via: "Text"
        };
      }
      if (!target) {
        return null;
      }
      char = target.textNode.textContent[partialOffset - 1];
      if (partialOffset > 0 && option.right && char !== "\n") {
        return {
          node: target.textNode,
          offset: partialOffset - 1,
          via: "Text",
          type: "right"
        };
      } else {
        return {
          node: target.textNode,
          offset: partialOffset,
          via: "Text"
        };
      }
      return null;
    };

    COMText.prototype.detectTextOffset = function(textNode, index) {
      var fix, i, len, offset, part, partIndex, ref, ref1;
      if (this.dirty && !this.skipDirtyCheck) {
        throw new Error("shouldn't detect textoffset when dirty");
      }
      offset = 0;
      if (textNode === ((ref = this.holder) != null ? ref.childNodes[0] : void 0)) {
        if (this.blockTail && this.contentString.slice(-1) === "\n") {
          return {
            offset: this.length - 1
          };
        } else {
          return {
            offset: this.length
          };
        }
      }
      ref1 = this.partials;
      for (partIndex = i = 0, len = ref1.length; i < len; partIndex = ++i) {
        part = ref1[partIndex];
        if (part.el.contains(textNode)) {
          fix = 0;
          if (this.blockTail && this.keepNewlineSpace && index === (textNode != null ? textNode.length : void 0) && part.content.slice(-1) === "\n" && partIndex === this.partials.length - 1) {
            fix -= 1;
          }
          return {
            offset: offset + index + fix,
            part: part
          };
        }
        offset += part.content.length;
      }
      if (this.el.contains(textNode)) {
        return {
          offset: this.length
        };
      }
      return null;
    };

    COMText.prototype.toJSON = function(option) {
      var json;
      json = COMText.__super__.toJSON.call(this, option);
      if (!json) {
        return null;
      }
      json.contentString = this.contentString;
      return json;
    };

    COMText.prototype.toHumanString = function() {
      return this.contentString;
    };

    return COMText;

  })(COMNode);

  InsertTextOperation = (function(superClass) {
    extend(InsertTextOperation, superClass);

    function InsertTextOperation() {
      return InsertTextOperation.__super__.constructor.apply(this, arguments);
    }

    InsertTextOperation.prototype.name = "InsertTextOperation";

    InsertTextOperation.prototype.invoke = function() {
      var ref, text;
      text = this.target || this.context.root.getChildByPath(this.path);
      if (typeof this.option.start !== "number" || this.option.start > text.length) {
        this.error("insert at " + this.option.start + " of text with length " + text.length);
        return false;
      }
      if (!this.option.value || typeof this.option.value !== "string") {
        this.error("insert value of " + this.option.value);
        return false;
      }
      if (!(text instanceof COMText)) {
        this.error("target not instanceof COMText");
        return;
      }
      text.contentString = text.contentString.slice(0, this.option.start) + this.option.value + text.contentString.slice(this.option.start);
      text.dirty = true;
      if ((ref = text.parent) != null) {
        ref.pend();
      }
      return true;
    };

    InsertTextOperation.prototype.revoke = function() {
      var ref, text;
      text = this.target || this.context.root.getChildByPath(this.path);
      if (!(text instanceof COMText)) {
        this.error("target not instanceof COMText");
        return;
      }
      if (typeof this.option.start !== "number" || this.option.start + this.option.value.length > text.length) {
        this.error("revoke insert at " + this.option.start + " of text with length " + text.length);
        return false;
      }
      if (!this.option.value) {
        this.error("revoke insert value of " + this.option.value);
        return false;
      }
      if (text.contentString.slice(this.option.start, this.option.start + this.option.value.length) !== this.option.value) {
        this.error("revoke insert value of " + this.option.value + " but the text in the corresponding area is " + (text.contentString.slice(this.option.start, this.option.start + this.option.value.length)));
        return false;
      }
      text.contentString = text.contentString.slice(0, this.option.start) + text.contentString.slice(this.option.start + this.option.value.length);
      text.dirty = true;
      if ((ref = text.parent) != null) {
        ref.pend();
      }
      return true;
    };

    InsertTextOperation.prototype.describe = function() {
      return this.name + ": insert text \"" + this.option.value + "\" at " + this.option.start;
    };

    return InsertTextOperation;

  })(Operation.EditOperation);

  RemoveTextOperation = (function(superClass) {
    extend(RemoveTextOperation, superClass);

    function RemoveTextOperation() {
      return RemoveTextOperation.__super__.constructor.apply(this, arguments);
    }

    RemoveTextOperation.prototype.name = "RemoveTextOperation";

    RemoveTextOperation.prototype.invoke = function() {
      var ref, text;
      text = this.target || this.context.root.getChildByPath(this.path);
      if (!(text instanceof COMText)) {
        this.error("target not instanceof COMText");
        return;
      }
      if (typeof this.option.start !== "number" || this.option.start > text.length) {
        this.error("remove at " + this.option.start + " of text with length " + text.length);
        return false;
      }
      if (!this.option.length) {
        this.option.length = text.contentString.length - this.option.start;
        return false;
      }
      if (this.option.start + this.option.length > text.length) {
        this.error("remove at " + this.option.start + " length " + this.option.length + " exceed the contentString length of " + text.length);
        return false;
      }
      this.option.removed = text.contentString.slice(this.option.start, this.option.start + this.option.length);
      text.contentString = text.contentString.slice(0, this.option.start) + text.contentString.slice(this.option.start + this.option.length);
      text.dirty = true;
      if ((ref = text.parent) != null) {
        ref.pend();
      }
      return true;
    };

    RemoveTextOperation.prototype.revoke = function() {
      var ref, text;
      text = this.target || this.context.root.getChildByPath(this.path);
      if (!(text instanceof COMText)) {
        this.error("target not instanceof COMText");
        return;
      }
      if (typeof this.option.start !== "number" || this.option.start > text.length) {
        this.error("revoke at start " + this.option.start + " but with text with length " + text.length);
        return false;
      }
      if (!this.option.removed) {
        this.error("revoke value of " + this.option.value);
        return false;
      }
      text.contentString = text.contentString.slice(0, this.option.start) + this.option.removed + text.contentString.slice(this.option.start);
      text.dirty = true;
      if ((ref = text.parent) != null) {
        ref.pend();
      }
      return true;
    };

    RemoveTextOperation.prototype.describe = function() {
      return this.name + ": remove text at " + this.option.start + "~" + (this.option.start + this.option.length);
    };

    return RemoveTextOperation;

  })(Operation.EditOperation);

  module.exports = COMText;

}).call(this);

}
GlobalContext.setModule("vincent/com/text.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/trapPolicy.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMPolicy, COMTrapPolicy,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMPolicy = require("./policy");

  COMTrapPolicy = (function(superClass) {
    extend(COMTrapPolicy, superClass);

    function COMTrapPolicy(node) {
      this.node = node;
      COMTrapPolicy.__super__.constructor.call(this, this.node);
    }

    COMTrapPolicy.prototype.trap = "ignore";

    COMTrapPolicy.prototype.trapOut = "ignore";

    COMTrapPolicy.prototype.trapIn = "ignore";

    COMTrapPolicy.prototype.behave = function(behavior) {
      var prop;
      for (prop in behavior) {
        if (behavior.hasOwnProperty(prop)) {
          this[prop] = behavior[prop];
        }
      }
      return this;
    };

    return COMTrapPolicy;

  })(COMPolicy);

  module.exports = COMTrapPolicy;

}).call(this);

}
GlobalContext.setModule("vincent/com/trapPolicy.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/travelPolicy.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMPolicy, COMTravelPolicy,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMPolicy = require("./policy");

  COMTravelPolicy = (function(superClass) {
    extend(COMTravelPolicy, superClass);

    function COMTravelPolicy(node) {
      this.node = node;
      COMTravelPolicy.__super__.constructor.call(this, this.node);
    }

    COMTravelPolicy.prototype.write = "ignore";

    COMTravelPolicy.prototype.forwardChar = "ignore";

    COMTravelPolicy.prototype.backwardChar = "ignore";

    COMTravelPolicy.prototype.deleteChar = "ignore";

    COMTravelPolicy.prototype.upwardChar = "ignore";

    COMTravelPolicy.prototype.downwardChar = "ignore";

    COMTravelPolicy.prototype.head = "ignore";

    COMTravelPolicy.prototype.tail = "ignore";

    COMTravelPolicy.prototype.startOfLine = "ignore";

    COMTravelPolicy.prototype.endOfLine = "ignore";

    COMTravelPolicy.prototype.forwardBypassed = "ignore";

    COMTravelPolicy.prototype.backwardBypassed = "ignore";

    COMTravelPolicy.prototype.deleteBypassed = "ignore";

    COMTravelPolicy.prototype.tailBoundary = "ignore";

    return COMTravelPolicy;

  })(COMPolicy);

  module.exports = COMTravelPolicy;

}).call(this);

}
GlobalContext.setModule("vincent/com/travelPolicy.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/unknownRune.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMRune, COMUnknownRune, i18n,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  i18n = require("./i18n");

  COMRune = require("./rune");

  COMUnknownRune = (function(superClass) {
    extend(COMUnknownRune, superClass);

    COMUnknownRune.prototype.type = "UnknownRune";

    function COMUnknownRune(context, data) {
      var ref;
      this.context = context;
      this.data = data != null ? data : {
        detail: null
      };
      COMUnknownRune.__super__.constructor.call(this, this.context, this.data);
      if ((ref = this.appearance.classList) != null) {
        ref.push("com-unknown-rune");
      }
    }

    COMUnknownRune.prototype.render = function() {
      var ref, ref1, ref2, title;
      COMUnknownRune.__super__.render.call(this);
      title = i18n.UnknownRuneTitle;
      if ((ref = this.el) != null) {
        ref.title = title;
      }
      if ((ref1 = this.el) != null) {
        ref1.setAttribute("title", title);
      }
      return (ref2 = this.el) != null ? ref2.onclick = (function(_this) {
        return function() {
          var ref3;
          return Logger.error("UnknownRuneDetail", JSON.stringify((ref3 = _this.data) != null ? ref3.detail : void 0, null, 4));
        };
      })(this) : void 0;
    };

    COMUnknownRune.prototype.toJSON = function() {
      return this.data.detail;
    };

    return COMUnknownRune;

  })(COMRune);

  module.exports = COMUnknownRune;

}).call(this);

}
GlobalContext.setModule("vincent/com/unknownRune.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/visualPosition.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMVisualBorder, COMVisualPosition;

  COMVisualPosition = (function() {
    function COMVisualPosition(option) {
      var pl, pr, ref, ref1;
      if (option == null) {
        option = {};
      }
      this.left = option.left || null;
      this.right = option.right || null;
      this.center = option.center || null;
      this.priority = "right";
      pl = ((ref = this.left) != null ? ref.priority : void 0) || 0;
      pr = ((ref1 = this.right) != null ? ref1.priority : void 0) || 0;
      if (pl > pr) {
        this.priority = "left";
      }
      return;
    }

    return COMVisualPosition;

  })();

  COMVisualBorder = (function() {
    function COMVisualBorder(option) {
      this.node = option.node || null;
      this.offset = option.offset || 0;
      this.position = option.position;
      this.priority = option.priority || 0;
      return;
    }

    COMVisualBorder.prototype.isElementBoundary = function() {
      return this.node && this.node.nodeType !== this.node.TEXT_NODE;
    };

    return COMVisualBorder;

  })();

  COMVisualPosition.COMVisualBorder = COMVisualBorder;

  module.exports = COMVisualPosition;

}).call(this);

}
GlobalContext.setModule("vincent/com/visualPosition.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/helper/compressor.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var compressMap, prop, reverseMap, value;

  compressMap = {
    "children": "$c",
    "contentString": "$s",
    "type": "$t",
    "spell": "$p",
    "state": "$t",
    "doneAt": "$a"
  };

  reverseMap = {};

  for (prop in compressMap) {
    value = compressMap[prop];
    reverseMap[value] = prop;
  }

  exports._compress = function(obj) {
    var result;
    if (obj instanceof Array) {
      return obj.map(this._compress.bind(this));
    }
    if (typeof obj === "object") {
      result = {};
      for (prop in obj) {
        value = obj[prop];
        if (value instanceof Array && value.length === 0) {
          continue;
        }
        if (compressMap[prop]) {
          result[compressMap[prop]] = this._compress(value);
        } else {
          result[prop] = this._compress(value);
        }
      }
      return result;
    }
    return obj;
  };

  exports.compress = function(obj) {
    var result;
    result = this._compress(obj);
    result.$v = 0;
    return result;
  };

  exports.extract = function(obj) {
    if (obj.$v !== 0) {
      return obj;
    }
    return this._extract(obj);
  };

  exports._extract = function(obj) {
    var result;
    if (obj instanceof Array) {
      return obj.map(this._extract.bind(this));
    }
    if (typeof obj === "object") {
      result = {};
      for (prop in obj) {
        value = obj[prop];
        if (prop[0] === "$") {
          result[reverseMap[prop]] = this._extract(value);
        } else {
          result[prop] = this._extract(value);
        }
      }
      return result;
    }
    return obj;
  };

}).call(this);

}
GlobalContext.setModule("vincent/com/helper/compressor.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/helper/nodeList.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMNodeList, EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  EventEmitter = (require("../events")).EventEmitter;

  COMNodeList = (function(superClass) {
    extend(COMNodeList, superClass);

    function COMNodeList() {
      COMNodeList.__super__.constructor.call(this);
      this.nodes = [];
      this.__defineGetter__("length", (function(_this) {
        return function() {
          return _this.nodes.length;
        };
      })(this));
    }

    COMNodeList.prototype.add = function() {
      var change, i, len, node, nodes;
      nodes = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      change = false;
      for (i = 0, len = nodes.length; i < len; i++) {
        node = nodes[i];
        if (indexOf.call(this.nodes, node) < 0) {
          (function(_this) {
            return (function(node) {
              _this.nodes.push(node);
              change = true;
              node.stopListenBy(_this);
              return node.listenBy(_this, "pend", function() {
                return _this.emit("pend", node);
              });
            });
          })(this)(node);
        }
      }
      if (change) {
        return this.emit("change");
      }
    };

    COMNodeList.prototype.remove = function() {
      var change, nodes;
      nodes = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      change = false;
      this.nodes = this.nodes.filter(function(item) {
        if (indexOf.call(nodes, item) >= 0) {
          change = true;
          item.stopListenBy(this);
          return false;
        }
        return true;
      });
      if (change) {
        return this.emit("change");
      }
    };

    COMNodeList.prototype.at = function(index) {
      return this.nodes[index];
    };

    COMNodeList.prototype.first = function() {
      return this.nodes[0] || null;
    };

    COMNodeList.prototype.sort = function() {
      return this.nodes.sort(function(a, b) {
        var position;
        position = a.compareNodePosition(b);
        if (position === "under" || position === "contain" || position === "identical") {
          return 0;
        } else if (position === "before") {
          return -1;
        } else {
          return 1;
        }
      });
    };

    COMNodeList.prototype.toArray = function() {
      return this.nodes.slice();
    };

    return COMNodeList;

  })(EventEmitter);

  module.exports = COMNodeList;

}).call(this);

}
GlobalContext.setModule("vincent/com/helper/nodeList.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/helper/sharedCallbacks.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = require("/component/sharedCallbacks");

}).call(this);

}
GlobalContext.setModule("vincent/com/helper/sharedCallbacks.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/helper/string.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module.exports = {
    ignorePhaseTypes: [],
    ignoreChar: [" "],
    findJumpBreakForward: function(string, index) {
      return this.findJumpBreak(string, index, 1, 0);
    },
    findJumpBreakBackward: function(string, index) {
      return this.findJumpBreak(string, index, -1, -1);
    },
    findJumpBreak: function(string, index, step, fix) {
      var char, phase, phase2Type, regret, type;
      phase = 0;
      type = null;
      index += fix;
      phase2Type = null;
      if (step < 0) {
        regret = 1;
      } else {
        regret = 0;
      }
      while (index < string.length && index >= 0) {
        char = string[index];
        type = this.detectCharType(char);
        if (phase === 0) {
          if (indexOf.call(this.ignorePhaseTypes, type) >= 0 || indexOf.call(this.ignoreChar, char) >= 0) {
            index += step;
            continue;
          } else {
            phase = 1;
          }
        }
        if (phase === 1) {
          if (type === phase2Type || !phase2Type) {
            index += step;
            phase2Type = type;
            continue;
          }
          index += regret;
          break;
        }
      }
      if (index < 0) {
        return 0;
      }
      if (index > string.length) {
        return string.length;
      }
      return index;
    },
    detectCharType: function(char) {
      if (/\s/.test(char)) {
        return "space";
      } else if (/[`\*~\s\.";\[\]\{\}:<>,\\\/\?`~!@#\$%\^&\(\)\|]/.test(char)) {
        return "delimeter";
      } else if (/[a-z_]/i.test(char)) {
        return "alphabet";
      } else {
        return "other";
      }
    }
  };

}).call(this);

}
GlobalContext.setModule("vincent/com/helper/string.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/helper/trait.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = Leaf.Trait;

}).call(this);

}
GlobalContext.setModule("vincent/com/helper/trait.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/com/helper/walker.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Walker, WalkerRootFirst;

  Walker = (function() {
    function Walker(context) {
      this.context = context;
      this.MAX = 1000 * 100;
      this.top = this.context.root;
      this.node = this.context.root;
    }

    Walker.prototype.setTop = function(top) {
      this.top = top;
    };

    Walker.prototype.setNode = function(node1) {
      this.node = node1;
    };

    Walker.prototype.stepIn = function() {
      var ref;
      if ((ref = this.node.children) != null ? ref[0] : void 0) {
        this.node = this.node.children[0];
        return true;
      }
      return false;
    };

    Walker.prototype.stepOver = function() {
      var node;
      node = this.node.next();
      if (node) {
        this.node = node;
        return true;
      }
      return false;
    };

    Walker.prototype.stepBack = function() {
      var node;
      node = this.node.previous();
      if (node) {
        this.node = node;
        return true;
      }
      return false;
    };

    Walker.prototype.stepOut = function() {
      if (this.top && this.node === this.top) {
        return false;
      }
      if (this.node.parent) {
        this.node = this.node.parent;
        return true;
      }
      return false;
    };

    return Walker;

  })();

  WalkerRootFirst = (function() {
    function WalkerRootFirst(context) {
      this.context = context;
      this.MAX = 1000 * 100;
      this.top = this.context.root;
    }

    WalkerRootFirst.prototype.isTop = function() {
      return this.node.isRoot;
    };

    WalkerRootFirst.prototype.setNode = function(node1) {
      this.node = node1;
    };

    WalkerRootFirst.prototype.setTop = function(top) {
      this.top = top;
    };

    WalkerRootFirst.prototype.next = function(judge) {
      var counter, next, node, parent, pnext;
      if (judge == null) {
        judge = function() {
          return true;
        };
      }
      counter = 0;
      while (true) {
        counter++;
        if (counter > this.MAX) {
          throw new Error("like to be recursive walking! walked node exceed max " + this.MAX);
        }
        if (this.node.children && this.node.children.length > 0 && this.node.child && !this.skipChildOnce) {
          this.node = this.node.child(0);
          if (judge(this.node)) {
            return true;
          }
          continue;
        }
        this.skipChildOnce = false;
        if (this.top && this.node === this.top) {
          this.skipBrotherOnce = false;
          return false;
        }
        next = this.node.next();
        if (next && !this.skipBrotherOnce) {
          this.node = next;
          if (judge(this.node)) {
            return true;
          }
          continue;
        }
        this.skipBrotherOnce = false;
        node = this.node;
        while (true) {
          parent = node.parent;
          if (!parent || parent === this.top) {
            return false;
          }
          pnext = parent.next();
          if (pnext) {
            this.node = pnext;
            if (judge(this.node)) {
              return true;
            }
            break;
          }
          node = parent;
        }
        continue;
      }
    };

    WalkerRootFirst.prototype.previous = function(judge) {
      var node, parent, pprevious, previous;
      if (judge == null) {
        judge = function() {
          return true;
        };
      }
      while (true) {
        if (this.node.children && this.node.children.length > 0 && this.node.last() && !this.skipChildOnce) {
          this.node = this.node.last();
          if (judge(this.node)) {
            return true;
          }
          continue;
        }
        this.skipChildOnce = false;
        if (this.top && this.node === this.top) {
          this.skipBrotherOnce = false;
          return false;
        }
        previous = this.node.previous();
        if (previous && !this.skipBrotherOnce) {
          this.node = previous;
          if (judge(this.node)) {
            return true;
          }
          continue;
        }
        this.skipBrotherOnce = false;
        node = this.node;
        while (true) {
          parent = node.parent;
          if (!parent || parent === this.top) {
            return false;
          }
          pprevious = parent.previous();
          if (pprevious) {
            this.node = pprevious;
            if (judge(this.node)) {
              return true;
            }
            break;
          }
          node = parent;
        }
        continue;
      }
    };

    WalkerRootFirst.prototype.last = function(judge) {
      if (judge == null) {
        judge = function() {
          return true;
        };
      }
      this.setNode(this.top || this.context.root);
      return this.previous(judge);
    };

    WalkerRootFirst.prototype.first = function(judge) {
      if (judge == null) {
        judge = function() {
          return true;
        };
      }
      this.setNode(this.top || this.context.root);
      return this.next(judge);
    };

    return WalkerRootFirst;

  })();

  module.exports = Walker;

  module.exports.WalkerRootFirst = WalkerRootFirst;

}).call(this);

}
GlobalContext.setModule("vincent/com/helper/walker.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/common/boundary.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DOMBoundary;

  DOMBoundary = (function() {
    DOMBoundary.createRangeBetween = function(b1, b2) {
      var b, fix, position, range, ref, startIndex, startTarget;
      b1 = new DOMBoundary(b1);
      b2 = new DOMBoundary(b2);
      range = document.createRange();
      position = b1.compare(b2);
      if (position === "identical") {
        if (b1.include || b2.include) {
          range.setStart(b1.getTargetParent(), b1.getTargetIndex());
          range.setEnd(b1.getTargetParent(), b1.getTargetIndex() + 1);
        } else {
          range.setStart(b1.getTargetParent(), b1.getTargetIndex());
          range.setEnd(b1.getTargetParent(), b1.getTargetIndex());
        }
        return range;
      }
      if (position === "after") {
        b = b2;
        b2 = b1;
        b1 = b;
      }
      startTarget = b1.getTargetParent();
      if (!startTarget) {
        Logger.error("no start target", b1);
        return null;
      }
      startIndex = Math.min(startTarget.length || ((ref = startTarget.children) != null ? ref.length : void 0) || 0, b1.getTargetIndex());
      range.setStart(startTarget, startIndex);
      if (b2.include) {
        fix = 1;
      } else {
        fix = 0;
      }
      range.setEnd(b2.getTargetParent(), b2.getTargetIndex() + fix);
      return range;
    };

    function DOMBoundary(option) {
      if (option == null) {
        option = {};
      }
      this.node = option.node;
      this.offset = option.offset || 0;
      this.type = option.type || "left";
      this.include = this.type === "include";
    }

    DOMBoundary.prototype.getAdjacentElement = function() {
      var result, target;
      result = {};
      if (!this.include) {
        if (this.offset === 0 && this.type === "left") {
          result.left = this.getPreviousElement(this.node.parentElement);
        }
        if (this.offset === this.node.length || (this.offset === this.node.length - 1 && this.type === "right")) {
          result.right = this.getNextElement(this.node.parentElement);
        }
      } else {
        target = this.node.childNodes[this.offset];
        result.left = this.getPreviousElement(target);
        result.right = this.getNextElement(target);
      }
      return result;
    };

    DOMBoundary.prototype.getNextElement = function(el) {
      while (el) {
        if (el.nextElementSibling) {
          return el.nextElementSibling;
        } else {
          el = el.parentElement;
        }
      }
      return null;
    };

    DOMBoundary.prototype.getPreviousElement = function(el) {
      while (el) {
        if (el.previousElementSibling) {
          return el.previousElementSibling;
        } else {
          el = el.parentElement;
        }
      }
      return null;
    };

    DOMBoundary.prototype.getTargetElement = function() {
      if (this.type === "include") {
        return this.node;
      }
      return this.node.childNodes && this.node.childNodes[this.offset || 0] || null;
    };

    DOMBoundary.prototype.getTargetParent = function() {
      if (this.type === "include") {
        return this.node.parentElement;
      } else {
        return this.node;
      }
    };

    DOMBoundary.prototype.getTargetIndex = function() {
      var child, fix, i, index, len, ref;
      if (this.type === "right") {
        fix = 1;
      } else {
        fix = 0;
      }
      if (this.type === "include") {
        ref = this.node.parentElement.childNodes;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          child = ref[index];
          if (child === this.node) {
            return index + fix;
          }
        }
      } else {
        return this.offset + fix;
      }
      return null;
    };

    DOMBoundary.prototype.compare = function(boundary) {
      var o1, o2, ref, ref1, ref2, result, subResult;
      result = (ref = this.getTargetParent()) != null ? ref.compareDocumentPosition(boundary.getTargetParent()) : void 0;
      o1 = this.getTargetIndex() || 0;
      o2 = boundary.getTargetIndex() || 0;
      if (result === 0) {
        if (o1 > o2) {
          return "after";
        } else if (o1 < o2) {
          return "before";
        } else {
          return "identical";
        }
      } else if ((result & 8) === 8) {
        subResult = (ref1 = this.getTargetParent()) != null ? ref1.compareDocumentPosition(boundary.getTargetElement()) : void 0;
        if ((subResult & 8) === 8) {
          return "after";
        } else if ((subResult & 2) === 2) {
          return "after";
        } else {
          return "before";
        }
      } else if ((result & 16) === 16) {
        subResult = (ref2 = this.getTargetElement()) != null ? ref2.compareDocumentPosition(boundary.getTargetParent()) : void 0;
        if ((subResult & 16) === 16) {
          return "before";
        } else if ((subResult & 2) === 2) {
          return "after";
        } else {
          return "before";
        }
      } else if ((result & 2) === 2) {
        return "after";
      } else {
        return "before";
      }
    };

    return DOMBoundary;

  })();

  module.exports = DOMBoundary;

}).call(this);

}
GlobalContext.setModule("vincent/common/boundary.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/common/char.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DOMChar;

  DOMChar = (function() {
    DOMChar.fromClientPoint = function(x, y) {
      var range, startOffset;
      range = document.caretRangeFromPoint(x, y);
      if (!range) {
        return null;
      }
      if (!(range.startContainer instanceof Text)) {
        startOffset = 0;
      } else {
        startOffset = range.startOffset;
      }
      return new DOMChar(range.startContainer, startOffset);
    };

    function DOMChar(textNode, index1) {
      var child, i, len, ref, target;
      this.textNode = textNode;
      this.index = index1;
      if ((!(this.textNode instanceof Text)) && (this.textNode instanceof HTMLElement) && typeof index === "number") {
        target = this.textNode;
        while (!(target instanceof Text)) {
          ref = target.childNodes;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            target = child;
            continue;
          }
          if (child.nextSibling) {
            target = child.nextSibling;
            continue;
          }
          while (child.parentElement !== this.textNode) {
            child = child.parentElement;
            if (child.nextSibling) {
              target = child.nextSibling;
              break;
            }
          }
        }
        if (target instanceof Text) {
          this.textNode = target;
          this.index = 0;
        } else {
          this.invalid = true;
        }
      }
      return;
    }

    DOMChar.prototype.isVisible = function() {
      var char;
      char = this.textNode.textContent[this.index];
      return (char !== "\n" && char !== " " && char !== "\r" && char !== "\t") && !this.isTailing();
    };

    DOMChar.prototype.isTailing = function() {
      return this.textNode.length <= this.index;
    };

    DOMChar.prototype.isChar = function() {
      return this.textNode instanceof Text;
    };

    DOMChar.prototype.getClientRect = function() {
      var content, e, error, holder, range, rect;
      if (!this.isChar()) {
        return this.textNode.getBoundingClientRect();
      }
      content = this.textNode.textContent;
      if (!this.isVisible()) {
        holder = "p";
        this.textNode.textContent = content.slice(0, this.index) + holder + content.slice(this.index);
      }
      range = document.createRange();
      if (!this.textNode || this.textNode.textContent.length < this.index) {
        Logger.error("invalid DOM char", this.textNode, this.index);
        return null;
      }
      try {
        range.setStart(this.textNode, this.index);
        range.setEnd(this.textNode, this.index + 1);
      } catch (error) {
        e = error;
        Logger.error("invalid DOM char", this.textNode, this.index, this.describe());
        return null;
      }
      rect = range.getBoundingClientRect();
      if (holder) {
        this.textNode.textContent = content;
      }
      return rect;
    };

    DOMChar.prototype.getRect = function(option) {
      var fix, rect, resolveScrollTopFix;
      if (option == null) {
        option = {};
      }
      rect = this.getClientRect();
      rect = {
        top: rect.top,
        left: rect.left,
        bottom: rect.bottom,
        right: rect.right,
        height: rect.height,
        width: rect.width
      };
      resolveScrollTopFix = function(el) {
        var fix;
        fix = 0;
        while (el) {
          fix += el.scrollTop || 0;
          if (el === option.top) {
            break;
          }
          el = el.parentElement;
        }
        return fix;
      };
      fix = resolveScrollTopFix(this.textNode);
      rect.top += fix;
      rect.bottom += fix;
      return rect;
    };

    DOMChar.prototype.describe = function() {
      var contentString, extending;
      if (this.textNode instanceof Text) {
        contentString = this.textNode.textContent;
        extending = 20;
        if (contentString.length === this.index) {
          return "Char: " + contentString + "[ ]";
        }
        return "Char: " + (contentString.slice(this.index - extending, this.index)) + "[" + contentString[this.index] + "]" + (contentString.slice(this.index + 1, this.index + extending));
      }
      return "Char: Element " + this.textNode + "," + this.index;
    };

    return DOMChar;

  })();

  module.exports = DOMChar;

}).call(this);

}
GlobalContext.setModule("vincent/common/char.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/common/errors.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = Leaf.ErrorDoc.create().define("UnexpectedInput").define("LogicError").define("OperationError").generate();

}).call(this);

}
GlobalContext.setModule("vincent/common/errors.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/common/events.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  exports.EventEmitter = Leaf.EventEmitter;

}).call(this);

}
GlobalContext.setModule("vincent/common/events.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/common/keyEvent.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var KeyEvent, clearCmdTimer, code, hasCommandKey, i, isMac, outputMap, ref, ref1,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Leaf.Key.home = 36;

  Leaf.Key.end = 35;

  Leaf.Key.quote = 222;

  Leaf.Key.openBracket = 219;

  Leaf.Key.closeBracket = 221;

  Leaf.Key.backSlash = 220;

  Leaf.Key.slash = 191;

  Leaf.Key.comma = 188;

  Leaf.Key.period = 190;

  Leaf.Key.dash = 189;

  Leaf.Key.semiColon = 186;

  Leaf.Key.graveAccent = 192;

  hasCommandKey = false;

  window.hasCommandKey = false;

  outputMap = {};

  for (code = i = 65; i < 90; code = ++i) {
    outputMap[code] = String.fromCharCode(code);
  }

  isMac = ((ref = window.navigator.platform) != null ? (ref1 = ref.toLowerCase()) != null ? ref1.indexOf("mac") : void 0 : void 0) >= 0;

  clearCmdTimer = null;

  window.addEventListener("keydown", function(e) {
    var ref2;
    if (((ref2 = e.which) === 224 || ref2 === 91 || ref2 === 93) && isMac) {
      hasCommandKey = true;
      window.hasCommandKey = true;
      clearTimeout(clearCmdTimer);
      return setTimeout((function(_this) {
        return function() {
          hasCommandKey = false;
          return window.hasCommandKey = false;
        };
      })(this), 5000);
    }
  });

  window.addEventListener("keyup", function(e) {
    var ref2;
    if (((ref2 = e.which) === 224 || ref2 === 91 || ref2 === 93) && isMac) {
      hasCommandKey = false;
      return window.hasCommandKey = false;
    }
  });

  window.addEventListener("blur", function(e) {
    hasCommandKey = false;
    return window.hasCommandKey = false;
  });

  window.addEventListener("focus", function(e) {
    hasCommandKey = false;
    return window.hasCommandKey = false;
  });

  module.exports = KeyEvent = (function() {
    function KeyEvent(raw) {
      var ref2;
      this.raw = raw;
      this.code = (ref2 = this.raw) != null ? ref2.which : void 0;
      this.ctrlKey = this.raw.ctrlKey;
      this.shiftKey = this.raw.shiftKey;
      this.altKey = this.raw.altKey;
      this.commandKey = hasCommandKey;
      this.simulateName = this.raw.simulateName;
      if (this.raw.type === "keydown") {
        this.keyDown = true;
      } else if (this.raw.type === "keyup") {
        this.keyUp = true;
      } else {
        this.keyDown = true;
      }
    }

    KeyEvent.prototype.capture = function() {
      var ref2, ref3;
      this.defaultPrevented = true;
      this.propagationStoped = true;
      if ((ref2 = this.raw) != null) {
        if (typeof ref2.preventDefault === "function") {
          ref2.preventDefault();
        }
      }
      return (ref3 = this.raw) != null ? typeof ref3.stopImmediatePropagation === "function" ? ref3.stopImmediatePropagation() : void 0 : void 0;
    };

    KeyEvent.prototype.isValid = function() {
      return !this.defaultPrevented && !this.propagationStoped;
    };

    KeyEvent.prototype.canOutput = function() {
      var j, ref2, results;
      return ref2 = this.code, indexOf.call([48, 49, 50, 51, 52, 53, 54, 55, 56, 57].concat((function() {
        results = [];
        for (j = 65; j <= 90; j++){ results.push(j); }
        return results;
      }).apply(this), [Leaf.Key.space, Leaf.Key.enter, Leaf.Key.quote, Leaf.Key.openBracket, Leaf.Key.closeBracket, Leaf.Key.backSlash, Leaf.Key.slash, Leaf.Key.comma, Leaf.Key.period, Leaf.Key.dash, Leaf.Key.graveAccent]), ref2) >= 0;
    };

    KeyEvent.prototype.getInputText = function() {
      var char;
      char = outputMap[this.code] || "";
      if (!this.shiftKey) {
        return char.toLowerCase();
      } else {
        return char.toUpperCase();
      }
    };

    KeyEvent.prototype.isKey = function(name) {
      if (this.simulateName === name) {
        return true;
      }
      return this.code && Leaf.Key[name] === this.code;
    };

    KeyEvent.prototype.isModified = function() {
      return this.ctrlKey || this.altKey;
    };

    KeyEvent.prototype.isMod = function() {
      return hasCommandKey || this.ctrlKey;
    };

    KeyEvent.prototype.isModMatch = function(ctrl, command, mod) {
      if (this.ctrlKey) {
        if (!ctrl && (isMac || mod !== true)) {
          return false;
        }
      } else {
        if (ctrl || (!isMac && (mod === true))) {
          return false;
        }
      }
      if (hasCommandKey) {
        if (!command && mod !== true) {
          return false;
        }
      } else {
        if (command || (isMac && mod === true)) {
          return false;
        }
      }
      return true;
      if (ctrl !== this.ctrlKey && (!isMac || mod !== this.ctrlKey)) {
        return false;
      }
      if (command !== hasCommandKey) {
        return false;
      }
      if (isMac && mod !== hasCommandKey) {
        if (command !== hasCommandKey) {
          return false;
        }
      }
      if (!isMac && mod !== this.ctrlKey) {
        if (ctrl !== this.ctrlKey) {
          return false;
        }
      }
      return true;
    };

    return KeyEvent;

  })();

}).call(this);

}
GlobalContext.setModule("vincent/common/keyEvent.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/common/range.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DOMRange;

  DOMRange = (function() {
    function DOMRange(range) {
      this.range = range;
    }

    return DOMRange;

  })();

  module.exports = DOMRange;

}).call(this);

}
GlobalContext.setModule("vincent/common/range.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/common/region.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DOMRegion;

  DOMRegion = (function() {
    DOMRegion.rangeFromPoint = function(x, y) {
      var position, range;
      if (document.caretRangeFromPoint) {
        range = document.caretRangeFromPoint(x, y);
        return range;
      } else if (document.caretPositionFromPoint) {
        position = document.caretPositionFromPoint(x, y);
        if (!position) {
          return null;
        }
        range = document.createRange();
        range.setStart(position.offsetNode, position.offset);
        range.setEnd(position.offsetNode, position.offset);
        return range;
      }
      return null;
    };

    DOMRegion.fromClientPoint = function(x, y) {
      var range;
      range = this.rangeFromPoint(x, y);
      if (!range) {
        return null;
      }
      return new DOMRegion(range.startContainer, range.startOffset);
    };

    DOMRegion.fromBoundary = function(b) {
      var i, index, len, node, ref;
      if (b.type === "include") {
        ref = b.node.parentElement.childNodes;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          node = ref[index];
          if (b.node === node) {
            return new DOMRegion(b.node.parentElement, index);
          }
        }
      } else {
        return new DOMRegion(b.node, b.offset);
      }
    };

    function DOMRegion(node1, index1) {
      this.node = node1;
      this.index = index1;
    }

    DOMRegion.prototype.isChar = function() {
      return this.node instanceof Text;
    };

    DOMRegion.prototype.isVisibleText = function() {
      var char;
      char = this.node.textContent[this.index];
      return char !== "\n";
    };

    DOMRegion.prototype.isNewLine = function() {
      var char;
      char = this.node.textContent[this.index];
      return char === "\n";
    };

    DOMRegion.prototype.char = function() {
      var char;
      return char = this.node.textContent[this.index];
    };

    DOMRegion.prototype.nextChar = function() {
      return this.node.textContent[this.index + 1];
    };

    DOMRegion.prototype.previousChar = function() {
      return this.node.textContent[this.index - 1];
    };

    DOMRegion.prototype.selectRectByChar = function(rects) {
      if (rects.length === 1) {
        return rects[0];
      }
      if (this.previousChar() === "\n") {
        return rects[1];
      }
      if (rects.length > 1 && rects[0].width === 0 && rects[1].top === rects[0].top && rects[1]) {
        return rects[1];
      }
      return rects[0];
    };

    DOMRegion.prototype.isTailing = function() {
      return this.node.length <= this.index;
    };

    DOMRegion.prototype.getContainerElement = function() {
      if (this.node.type === this.node.ELEMENT_NODE) {
        return this.node;
      } else {
        return this.node.parentElement;
      }
    };

    DOMRegion.prototype.getIncludeElement = function() {
      var ref;
      if (((ref = this.node.childNodes[this.index]) != null ? ref.type : void 0) === this.node.ELEMENT_NODE) {
        return this.node.childNodes[this.index];
      }
      return null;
    };

    DOMRegion.prototype.getClientRect = function() {
      var el, rect;
      if (this.isChar()) {
        rect = this.getCharClientRect();
        return rect;
      } else {
        el = this.node.childNodes[this.index];
        if (!el) {
          return null;
        }
        if (el.innerRegionElement) {
          return el.innerRegionElement.getBoundingClientRect();
        }
        return el.getBoundingClientRect();
      }
    };

    DOMRegion.prototype.getRect = function(option) {
      var fix, fixRect, rect, resolveScrollTopFix;
      rect = this.getClientRect();
      if (!rect) {
        return null;
      }
      rect = {
        top: rect.top,
        left: rect.left,
        bottom: rect.bottom,
        right: rect.right,
        height: rect.height,
        width: rect.width
      };
      resolveScrollTopFix = function(el) {
        var fix;
        fix = 0;
        while (el) {
          fix += el.scrollTop || 0;
          if (el === option.top) {
            break;
          }
          el = el.parentElement;
        }
        return fix;
      };
      if (option.top) {
        fixRect = option.top.getBoundingClientRect();
      }
      if (this.isChar()) {
        fix = resolveScrollTopFix(this.node);
      } else {
        fix = resolveScrollTopFix(this.node.childNodes[this.index]);
      }
      rect.top += fix;
      rect.bottom += fix;
      if (fixRect) {
        rect.left -= fixRect.left;
        rect.right -= fixRect.left;
        rect.top -= fixRect.top;
        rect.bottom -= fixRect.top;
      }
      return rect;
    };

    DOMRegion.prototype.tryGetLeftCharClientRect = function() {
      var leftOne, range, rect;
      if (this.index < 1) {
        return null;
      }
      leftOne = this.node.textContent[this.index - 1];
      if (leftOne === "\n") {
        return null;
      }
      range = document.createRange();
      range.setStart(this.node, this.index - 1);
      range.setEnd(this.node, this.index);
      rect = range.getBoundingClientRect();
      if (!rect) {
        return null;
      }
      return Object.seal({
        left: rect.right,
        right: rect.right,
        width: 0,
        height: rect.height,
        top: rect.top,
        bottom: rect.bottom
      });
    };

    DOMRegion.prototype.getCharClientRect = function() {
      var content, holder, range, rect, rects, useHolder;
      content = this.node.textContent;
      range = document.createRange();
      if (!this.node || this.node.textContent.length < this.index) {
        return null;
      }
      if (this.node.textContent.length === 0 || this.isTailing()) {
        useHolder = true;
      }
      if (this.node.textContent[this.index] === "\n" && this.node.textContent.length - 1 === this.index && this.previousChar() === "\n") {
        useHolder = true;
      }
      if (useHolder) {
        holder = " ";
        this.node.textContent = content.slice(0, this.index) + holder + content.slice(this.index);
      }
      if (!this.node) {
        return null;
      }
      range.setStart(this.node, this.index);
      range.setEnd(this.node, this.index + 1);
      rects = range.getClientRects();
      rect = this.selectRectByChar(rects);
      if (useHolder) {
        this.node.textContent = content;
      }
      return rect;
    };

    DOMRegion.prototype.describe = function() {
      if (this.isChar()) {
        return this.describeChar();
      } else {
        return this.describeElement();
      }
    };

    DOMRegion.prototype.describeElement = function() {
      return this.node.childNodes[this.index];
    };

    DOMRegion.prototype.describeChar = function() {
      var contentString, extending;
      contentString = this.node.textContent;
      extending = 20;
      if (contentString.length === this.index) {
        return "Char: " + contentString + "[ ]";
      }
      return "Char: " + (contentString.slice(this.index - extending, this.index)) + "[" + contentString[this.index] + "]" + (contentString.slice(this.index + 1, this.index + extending));
    };

    return DOMRegion;

  })();

  module.exports = DOMRegion;

}).call(this);

}
GlobalContext.setModule("vincent/common/region.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/common/states.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = Leaf.States;

}).call(this);

}
GlobalContext.setModule("vincent/common/states.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/common/traverse.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DOMWalker;

  DOMWalker = (function() {
    function DOMWalker(node1, begin1, end1) {
      this.node = node1;
      this.begin = begin1;
      this.end = end1;
    }

    DOMWalker.prototype.traverse = function(handler) {
      var next, node, pn, results, top;
      top = this.node;
      if (!top.childNodes || top.childNodes.length === 0) {
        if (top && this.begin === top || this.end === top) {
          handler(top);
        }
        return;
      }
      node = this.begin || top.childNodes[0];
      results = [];
      while (true) {
        if (!node) {
          break;
        }
        if (handler(node)) {
          break;
        }
        if (node === top) {
          break;
        }
        if (node === this.end) {
          break;
        }
        if (node.childNodes && node.childNodes.length > 0) {
          node = node.childNodes[0];
          continue;
        }
        next = node.nextSibling;
        if (next) {
          node = next;
          continue;
        }
        results.push((function() {
          var results1;
          results1 = [];
          while (node = node.parentElement) {
            pn = node.nextSibling;
            if (node === top) {
              break;
            }
            if (pn) {
              node = pn;
              break;
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    };

    return DOMWalker;

  })();

  exports.traverse = function(node, handler) {
    var walker;
    walker = new DOMWalker(node);
    return walker.traverse(handler);
  };

  exports.traverseRange = function(range, handler) {
    var begin, end, top, walker;
    top = range.commonAncestorContainer;
    if (range.startContainer instanceof window.Text) {
      begin = range.startContainer;
    } else {
      begin = range.startContainer.children[range.startOffset];
    }
    if (range.endContainer instanceof window.Text) {
      end = range.endContainer;
    } else {
      end = range.endContainer.children[range.endOffset];
    }
    walker = new DOMWalker(top, begin, end);
    return walker.traverse(handler);
  };

}).call(this);

}
GlobalContext.setModule("vincent/common/traverse.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/DNDProtocol.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DNDProtocol;

  DNDProtocol = (function() {
    DNDProtocol.prototype.type = "Void";

    DNDProtocol.prototype.data = null;

    function DNDProtocol(type, data, event) {
      this.type = type;
      this.data = data;
      this.event = event;
    }

    return DNDProtocol;

  })();

  module.exports = DNDProtocol;

}).call(this);

}
GlobalContext.setModule("vincent/facility/DNDProtocol.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/buffer.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Buffer, BufferDropHandler, BufferHintManager, BufferManager, COMContext, COMCursor, COMSelection, DOMSelection, EventEmitter, Highlighter, IMEHint, ManagerDragCapableTrait, Properties, RichBuffer, SearchSession, SelectSession, SelectionHighlight, SharedCallbacks, Trait, ViewPort,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMContext = require("../com/context");

  Trait = require("../com/helper/trait");

  COMSelection = require("../com/selection");

  COMCursor = require("../com/cursor");

  DOMSelection = require("./selection");

  ViewPort = require("./viewPort");

  SelectSession = require("./selectSession");

  SelectionHighlight = require("./selectionHighlight");

  Highlighter = require("./highlighter");

  SearchSession = require("./searchSession");

  EventEmitter = (require("../common/events")).EventEmitter;

  BufferHintManager = require("/view/bufferHintManager");

  IMEHint = require("./imeHint");

  Properties = require("/component/properties");

  SharedCallbacks = require("/component/sharedCallbacks");

  Buffer = (function(superClass) {
    extend(Buffer, superClass);

    Buffer.index = 0;

    Buffer.prototype.type = "Buffer";

    function Buffer(editor, option) {
      this.editor = editor;
      if (option == null) {
        option = {};
      }
      this.id = (Buffer.index++).toString();
      Buffer.__super__.constructor.call(this);
      this.hintManager = new BufferHintManager(this.editor, this);
      this.isActive = false;
      this.name = option.name || ("<buffer " + this.id + ">");
      this.properties = new Properties(this);
    }

    Buffer.prototype.focus = function() {
      if (this.isFocusing) {
        return;
      }
      if (!this.isActive) {
        return false;
      }
      this.isFocusing = true;
      return this.emit("focus");
    };

    Buffer.prototype.blur = function() {
      if (!this.isFocusing) {
        return;
      }
      if (!this.isActive) {
        return false;
      }
      this.isFocusing = false;
      return this.emit("blur");
    };

    Buffer.prototype.activate = function() {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      return this.emit("active");
    };

    Buffer.prototype.deactivate = function() {
      if (!this.isActive) {
        return;
      }
      this.blur();
      this.isActive = false;
      return this.emit("deactive");
    };

    Buffer.prototype.render = function() {
      return false;
    };

    Buffer.prototype.destroy = function() {
      this.emit("destroy");
    };

    return Buffer;

  })(Leaf.Widget);

  RichBuffer = (function(superClass) {
    extend(RichBuffer, superClass);

    RichBuffer.renderConfig = {};

    RichBuffer.setRenderConfig = function(config) {
      var prop, results, value;
      results = [];
      for (prop in config) {
        value = config[prop];
        results.push(this.renderConfig[prop] = value);
      }
      return results;
    };

    RichBuffer.prototype.type = "RichBuffer";

    function RichBuffer(editor, option) {
      var prop, ref1, value;
      this.editor = editor;
      if (option == null) {
        option = {};
      }
      if (this.template == null) {
        this.template = "<div class=\"buffer\" data-class=\"focusState\">\n  <div data-id=\"viewPort\" class=\"com-view-port needsclick\">\n      <div data-id=\"wrapper\" class=\"wrapper\"></div>\n  </div>\n</div>";
      }
      RichBuffer.__super__.constructor.call(this, this.editor, option);
      this.viewPort = new ViewPort(this, this.UI.viewPort);
      this.context = option.context;
      this.cursor = this.context.createCursor({
        name: "master"
      });
      this.selection = new COMSelection(this.context, this.cursor);
      this.selectSession = new SelectSession(this);
      this.selectionHighlight = new SelectionHighlight(this);
      this.nextRenderCallback = SharedCallbacks.create();
      this.dropHandler = new BufferDropHandler(this);
      this.imeHint = new IMEHint(this);
      this.viewPort.listenBy(this, "scroll", (function(_this) {
        return function() {
          return _this.emit("reflow");
        };
      })(this));
      if (this.highlighter == null) {
        this.highlighter = new Highlighter(this);
      }
      this.searchSession = new SearchSession(this);
      if (this.renderContext == null) {
        this.renderContext = this.context.allocateRenderContext();
      }
      this.__defineGetter__("rootElement", (function(_this) {
        return function() {
          return _this.renderContext.rootElement;
        };
      })(this));
      this.renderContext.buffer = this;
      ref1 = RichBuffer.renderConfig;
      for (prop in ref1) {
        value = ref1[prop];
        this.renderContext.renderConfig[prop] = value;
      }
      this.renderContext.listenBy(this, "resize", (function(_this) {
        return function() {
          return _this.emit("resize");
        };
      })(this));
      this.interactive = false;
      this.lockUserInput = false;
      this.node.addEventListener("click", (function(_this) {
        return function() {
          return _this.ensureFocus();
        };
      })(this));
      this.node.addEventListener("touchend", (function(_this) {
        return function() {
          return _this.ensureFocus();
        };
      })(this));
      this.renderContext.buffer = this;
      this.renderContext.cursor = this.cursor;
      this.__defineGetter__("interactive", (function(_this) {
        return function() {
          return _this.renderContext.interactive;
        };
      })(this));
      this.__defineSetter__("interactive", (function(_this) {
        return function(value) {
          _this.renderContext.interactive = value;
          return _this.emit("interactiveChange", value);
        };
      })(this));
      this.__defineGetter__("renderOption", (function(_this) {
        return function(value) {
          return _this.renderContext.renderConfig;
        };
      })(this));
      this.viewPort.init();
    }

    RichBuffer.prototype.activate = function() {
      return RichBuffer.__super__.activate.call(this);
    };

    RichBuffer.prototype.deactivate = function() {
      return RichBuffer.__super__.deactivate.call(this);
    };

    RichBuffer.prototype.ensureFocus = function() {
      if (this.lockUserInput) {
        return;
      }
      return this.editor.bufferManager.focusAt(this);
    };

    RichBuffer.prototype.ensureRenderContext = function() {
      if (this.context.currentRenderContext !== this.renderContext) {
        return this.context.setRenderContext(this.renderContext);
      }
    };

    RichBuffer.prototype.focus = function() {
      RichBuffer.__super__.focus.call(this);
      this.selectSession.activate();
      return this.VM.focusState = "buffer-focus";
    };

    RichBuffer.prototype.blur = function() {
      RichBuffer.__super__.blur.call(this);
      this.selectSession.deactivate();
      return this.VM.focusState = "buffer-blur";
    };

    RichBuffer.prototype.nextRender = function(callback) {
      return this.nextRenderCallback.push(callback);
    };

    RichBuffer.prototype.render = function() {
      this.context.render(this.renderContext);
      if (this.name === "debug") {
        Logger.debug("render debug", this);
      }
      this.viewPort.setRoot(this.renderContext.el);
      this.selectionHighlight.render();
      return this.nextRenderCallback();
    };

    RichBuffer.prototype.setContentString = function(contentString) {
      this.context.transact((function(_this) {
        return function() {
          var p;
          _this.context.root.empty();
          p = _this.context.createElement("Contents", {
            children: [
              (_this.context.createElement("RichText", {
                contentString: contentString
              })).toJSON()
            ]
          });
          _this.context.root.append(p);
          _this.cursor.pointAt(p.children[0]);
          return _this.context.history.fromNow();
        };
      })(this));
      return true;
    };

    RichBuffer.prototype.markAsReadonly = function() {
      this.emit("readonly");
      return this.context.isReadonly = true;
    };

    RichBuffer.prototype.unmarkAsReadonly = function() {
      this.emit("readwrite");
      return this.context.isReadonly = false;
    };

    RichBuffer.prototype.destroy = function() {
      var ref1;
      if ((ref1 = this.context) != null) {
        ref1.destroyRenderContext(this.renderContext);
      }
      this.selectionHighlight.destroy();
      return RichBuffer.__super__.destroy.call(this);
    };

    return RichBuffer;

  })(Buffer);

  BufferManager = (function(superClass) {
    extend(BufferManager, superClass);

    function BufferManager(editor) {
      this.editor = editor;
      BufferManager.__super__.constructor.call(this);
      this.buffers = [];
      this.focusStack = [];
      new ManagerDragCapableTrait(this);
    }

    BufferManager.prototype.render = function() {
      var SLOW_RENDER, buffer, endRender, i, len, ref1, start;
      SLOW_RENDER = 10;
      start = Date.now();
      ref1 = this.buffers;
      for (i = 0, len = ref1.length; i < len; i++) {
        buffer = ref1[i];
        if (!buffer.isActive || !buffer.interactive) {
          continue;
        }
        buffer.render();
        buffer.emit("afterRender");
        if (buffer.isFocusing) {
          buffer.selectSession.syncSelection();
        }
      }
      endRender = Date.now();
      if (endRender - start > SLOW_RENDER) {
        return Logger.debug("SLOW_RENDER", endRender - start, "ms", ">", SLOW_RENDER, "ms");
      }
    };

    BufferManager.prototype.allocate = function(context, option) {
      var buffer;
      if (option == null) {
        option = {};
      }
      if (context instanceof Buffer) {
        buffer = context;
      } else {
        option.context = context;
        buffer = new RichBuffer(this.editor, option);
      }
      buffer.manager = this;
      this.buffers.push(buffer);
      buffer.listenBy(this, "active", (function(_this) {
        return function() {
          return _this.emit("active", buffer);
        };
      })(this));
      buffer.listenBy(this, "deactive", (function(_this) {
        return function() {
          return _this.emit("deactive", buffer);
        };
      })(this));
      return buffer;
    };

    BufferManager.prototype.recover = function(buffer) {
      buffer.stopListenBy(this);
      return buffer.destroy();
    };

    BufferManager.prototype.focusAt = function(buffer) {
      if (this.currentFocus) {
        this.currentFocus.blur();
      }
      this.currentFocus = buffer;
      buffer.focus();
      if (!buffer.isActive) {
        Logger.warn("Focus at none active buffer doesn't make sense.", buffer);
      }
      return this.emit("focus", buffer);
    };

    BufferManager.prototype.pushFocus = function(buffer) {
      if (this.currentFocus) {
        this.focusStack.push(this.currentFocus);
      }
      return this.focusAt(buffer);
    };

    BufferManager.prototype.popFocus = function(buffer) {
      if (this.currentFocus === buffer) {
        if (this.focusStack.length > 0) {
          return this.focusAt(this.focusStack.pop());
        }
      } else {
        return this.focusStack = this.focusStack.filter(function(item) {
          return item === buffer;
        });
      }
    };

    return BufferManager;

  })(EventEmitter);

  ManagerDragCapableTrait = (function(superClass) {
    extend(ManagerDragCapableTrait, superClass);

    function ManagerDragCapableTrait() {
      return ManagerDragCapableTrait.__super__.constructor.apply(this, arguments);
    }

    ManagerDragCapableTrait.prototype.initialize = function() {
      return this.registerDropHandler((function(_this) {
        return function(e, buffer) {
          var i, len, protocol, ref1, results;
          ref1 = e.detail.protocols;
          results = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            protocol = ref1[i];
            if (protocol.type === "Rune") {
              _this.transferRune(buffer, protocol.data);
              e.preventDefault();
              results.push(e.stopImmediatePropagation());
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
      })(this));
    };

    ManagerDragCapableTrait.prototype.transferRune = function(buffer, origin) {
      var ref, ref1;
      if (buffer.cursor.target.mime !== "text/com-rich-text") {
        return false;
      }
      if (origin.context !== buffer.context) {
        ref = buffer.context.createElement(origin.type, origin.toJSON());
      } else {
        ref = origin;
      }
      if (origin === buffer.cursor.target.runeAtIndex(buffer.cursor.anchor.index)) {
        return true;
      }
      origin.context.transact((function(_this) {
        return function() {
          if (origin.parent) {
            origin.parent.reflow();
            return origin.parent.removeText(origin.startOffset, origin.length);
          }
        };
      })(this));
      buffer.context.transact((function(_this) {
        return function() {
          buffer.cursor.conduct("write", ref);
          return ref.dirty = true;
        };
      })(this));
      return (ref1 = buffer.viewPort.controller) != null ? ref1.reform() : void 0;
    };

    ManagerDragCapableTrait.prototype.registerDropHandler = function(handler) {
      if (handler == null) {
        handler = function() {};
      }
      if (this.dropHandlers == null) {
        this.dropHandlers = [];
      }
      return this.dropHandlers.push(handler);
    };

    return ManagerDragCapableTrait;

  })(Trait);

  BufferDropHandler = (function() {
    function BufferDropHandler(buffer1) {
      this.buffer = buffer1;
      this.editor = this.buffer.editor;
      this.viewPort = this.buffer.viewPort;
      this.viewPort.el.addEventListener("user-drop", (function(_this) {
        return function(e) {
          var handler, i, j, len, len1, ref1, ref2;
          ref1 = _this.dropHandlers || [];
          for (i = 0, len = ref1.length; i < len; i++) {
            handler = ref1[i];
            handler(e);
            if (e.defaultPrevented) {
              return;
            }
          }
          ref2 = _this.editor.bufferManager.dropHandlers;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            handler = ref2[j];
            handler(e, _this.buffer);
            if (e.defaultPrevented) {
              return;
            }
          }
        };
      })(this));
    }

    BufferDropHandler.prototype.registerDropHandler = function(handler) {
      if (handler == null) {
        handler = function() {};
      }
      if (this.dropHandlers == null) {
        this.dropHandlers = [];
      }
      return this.dropHandlers.push(handler);
    };

    return BufferDropHandler;

  })();

  Buffer.RichBuffer = RichBuffer;

  Buffer.BufferManager = BufferManager;

  module.exports = Buffer;

}).call(this);

}
GlobalContext.setModule("vincent/facility/buffer.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/cancelStack.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var CancelEvent, CancelStack,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  CancelStack = (function(superClass) {
    extend(CancelStack, superClass);

    function CancelStack(editor) {
      this.editor = editor;
      CancelStack.__super__.constructor.call(this);
      this.stack = [];
      this.emptyHandlers = [];
      this.editor.commands.register({
        name: "cancel-stack-cancel-top",
        handler: (function(_this) {
          return function() {
            return _this.cancelTop();
          };
        })(this)
      });
      this.editor.hotkeys.registerCommandHotkey("editor:escape", "cancel-stack-cancel-top");
      this.historyHandler = this.historyHandler.bind(this);
    }

    CancelStack.prototype.handleEmpty = function() {
      var callback, e, i, len, ref;
      ref = this.emptyHandlers;
      for (i = 0, len = ref.length; i < len; i++) {
        callback = ref[i];
        callback(e = new CancelEvent);
        if (e.isCaptured) {
          return true;
        }
      }
      return false;
    };

    CancelStack.prototype.registerEmptyHandler = function(handlers) {
      return this.emptyHandlers.push(handlers);
    };

    CancelStack.prototype.bindHistory = function(history) {
      this.history = history;
      return this.registerHistory();
    };

    CancelStack.prototype.registerHistory = function() {
      if (!this.history) {
        return;
      }
      this.history.remove(this);
      return this.history.unshift(this, this.historyHandler);
    };

    CancelStack.prototype.historyHandler = function() {
      this.cancelTop();
      return this.registerHistory();
    };

    CancelStack.prototype.cancelTop = function() {
      var item;
      if (this.stack.length > 0) {
        item = this.stack.pop();
        item.callback();
        if (this.stack.length === 0) {
          this.emit("empty");
        }
        return true;
      } else if (this.handleEmpty()) {
        return true;
      } else {
        this.history.remove(this);
      }
      return false;
    };

    CancelStack.prototype.push = function(id, callback) {
      this.registerHistory();
      this.stack.push({
        id: id,
        callback: callback
      });
      if (this.stack.length === 1) {
        return this.emit("occupied");
      }
    };

    CancelStack.prototype.isEmpty = function() {
      return this.stack.length === 0;
    };

    CancelStack.prototype.remove = function(id) {
      var change;
      change = false;
      this.stack = this.stack.filter(function(item) {
        if (item.id === id) {
          change = true;
          return false;
        }
        return true;
      });
      if (this.stack.length === 0 && change) {
        return this.emit("empty");
      }
    };

    return CancelStack;

  })(Leaf.EventEmitter);

  CancelEvent = (function() {
    function CancelEvent() {}

    CancelEvent.prototype.capture = function() {
      return this.isCaptured = true;
    };

    return CancelEvent;

  })();

  module.exports = CancelStack;

}).call(this);

}
GlobalContext.setModule("vincent/facility/cancelStack.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/caret.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var BoundaryEffectTracer, Caret, CaretActionTrait, CaretBlinkableTrait, CaretLayout, CaretPosition, CaretViewPortPoserTrait, CaretWritableTrait, DOMBoundary, DOMRegion, EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DOMRegion = require("../common/region");

  DOMBoundary = require("../common/boundary");

  EventEmitter = (require("../common/events")).EventEmitter;

  Caret = (function(superClass) {
    extend(Caret, superClass);

    function Caret(editor, option) {
      this.editor = editor;
      if (option == null) {
        option = {};
      }
      this.template = "<div class=\"caret\" data-class=\"caretName,visibleState\"><div data-id=\"shape\" class=\"shape\"></div></div>";
      Caret.__super__.constructor.call(this);
      this.name = option.name || "master";
      this.VM.caretName = "caret-" + this.name;
      this.shape = this.UI.shape;
      this.shape$ = this.UI.shape$;
      this.__defineGetter__("dirty", (function(_this) {
        return function() {
          return _this._dirty;
        };
      })(this));
      this.__defineSetter__("dirty", (function(_this) {
        return function(value) {
          return _this._dirty = value;
        };
      })(this));
      this.boundaryEffectTracer = new BoundaryEffectTracer(this);
    }

    Caret.prototype.init = function() {
      window.addEventListener("resize", (function(_this) {
        return function() {
          return _this.dirty = true;
        };
      })(this));
      this.node.addEventListener("mousedown", (function(_this) {
        return function(e) {
          return _this.onClick(e);
        };
      })(this));
      if (this.editor.platform.isMobile()) {
        this.editor.inputMethod.listenBy(this, "key", (function(_this) {
          return function(e) {
            if (e.simulateName) {
              return setTimeout(function() {
                _this.isScrolling = false;
                return _this.dirty = true;
              }, 0);
            }
          };
        })(this));
      }
      this.keyHandlers = {};
      new CaretViewPortPoserTrait(this);
      new CaretActionTrait(this);
      return new CaretBlinkableTrait(this);
    };

    Caret.prototype.destroy = function() {
      var ref, ref1, ref2, ref3;
      this.editor.inputMethod.stopListenBy(this);
      if ((ref = this.cursor) != null) {
        ref.stopListenBy(this);
      }
      if ((ref1 = this.context) != null) {
        ref1.stopListenBy(this);
      }
      if ((ref2 = this.currentBuffer) != null) {
        ref2.stopListenBy(this);
      }
      return (ref3 = this.node.parentElement) != null ? ref3.removeChild(this.node) : void 0;
    };

    Caret.prototype.dirtyConfirm = function() {
      clearTimeout(this.dirtyConfirmTimer);
      return this.dirtyConfirmTimer = setTimeout((function(_this) {
        return function() {
          return _this.dirty = true;
        };
      })(this), 10);
    };

    Caret.prototype.attachTo = function(buffer, cursor) {
      if (!buffer.interactive) {
        return false;
      }
      if (this.cursor) {
        this.cursor.stopListenBy(this);
      }
      if (this.context) {
        this.context.stopListenBy(this);
      }
      if (this.currentBuffer) {
        this.currentBuffer.stopListenBy(this);
      }
      this.dirty = true;
      this.viewPort = buffer.viewPort;
      this.currentBuffer = buffer;
      buffer.ensureRenderContext();
      this.cursor = cursor || buffer.cursor;
      this.cursor.listenBy(this, "move", (function(_this) {
        return function() {
          _this.currentBuffer.disableSaveBestPosition = false;
          _this.isScrolling = false;
          if (_this.name === "master") {
            _this.requestScroll = true;
          }
          return _this.dirty = true;
        };
      })(this));
      this.cursor.listenBy(this, "trigger", (function(_this) {
        return function() {
          return _this.forceBump = true;
        };
      })(this));
      this.context = buffer.context;
      this.context.listenBy(this, "change", (function(_this) {
        return function() {
          _this.dirty = true;
          if (_this.name === "master") {
            _this.requestScroll = true;
          }
          if (_this.node.parentElement !== _this.currentBuffer.viewPort.el) {
            _this.currentBuffer.viewPort.el.appendChild(_this.node);
          }
          return _this.dirtyConfirm();
        };
      })(this));
      this.currentBuffer.listenBy(this, "interactiveChange", function(change) {
        return this.update();
      });
      this.currentBuffer.listenBy(this, "resize", (function(_this) {
        return function() {
          return _this.dirty = true;
        };
      })(this));
      this.currentBuffer.listenBy(this, "reflow", (function(_this) {
        return function() {
          _this.emit("bufferReflow");
          if (!_this.editor.platform.isMobile()) {
            return;
          }
          _this.isScrolling = true;
          clearTimeout(_this._scrollTimer);
          return _this._scrollTimer = setTimeout(function() {
            return _this.isScrolling = false;
          }, 350);
        };
      })(this));
      this.switchingBuffer = true;
      if (this.isShow) {
        this.isShow = false;
        this.show();
        return this.update();
      }
    };

    Caret.prototype.onClick = function(e) {
      if (e.which !== 1) {
        return;
      }
      if (this.editor.conduct("trigger")) {
        e.preventDefault();
        e.stopImmediatePropagation();
        return;
      }
      return false;
    };

    Caret.prototype.compareRect = function(a, b) {
      var i, len, prop, props;
      props = ["left", "right", "top", "bottom"];
      for (i = 0, len = props.length; i < len; i++) {
        prop = props[i];
        if (parseInt(a[prop]) !== parseInt(b[prop])) {
          return false;
        }
      }
      return true;
    };

    Caret.prototype.bump = function() {
      this.forceBump = true;
      return this.update();
    };

    Caret.prototype.update = function(option) {
      var e, error;
      if (option == null) {
        option = {};
      }
      if (this.isScrolling) {
        return;
      }
      this._update();
      this.applyBlink();
      return;
      try {
        return this._update();
      } catch (error) {
        e = error;
        Logger.error("fail to update caret");
        return Logger.error(e);
      }
    };

    Caret.prototype._update = function(option) {
      var boudnary, boundary, caretLayout, ref, ref1, style, visualPosition;
      if (option == null) {
        option = {};
      }
      if (!this.cursor) {
        return;
      }
      if (!this.currentBuffer.isActive) {
        this.lastActive = false;
        return;
      }
      if (!this.currentBuffer.interactive) {
        this.hide();
        return;
      } else {
        this.show();
      }
      if (!((ref = this.currentBuffer) != null ? ref.selection.isCollapsed() : void 0) && ((ref1 = this.currentBuffer) != null ? ref1.selection.isActive : void 0)) {
        this.node.classList.add("selecting");
      } else {
        this.node.classList.remove("selecting");
      }
      if (this.currentBuffer.lockUserInput) {
        this.shape.classList.add("lock");
      } else {
        this.shape.classList.remove("lock");
      }
      if (this.lastBuffer !== this.currentBuffer || !this.lastActive || this.forceBump) {
        clearTimeout(this.bumpTimer);
        clearTimeout(this.clearTimer);
        this.shape.classList.remove("bump");
        this.shape.classList.remove("bump-minor");
        this.bumpTimer = setTimeout((function(_this) {
          return function() {
            var ref2;
            if (_this.lastRenderDetail && ((ref2 = _this.lastRenderDetail) != null ? ref2.height : void 0) > 48) {
              _this.shape.classList.add("bump-minor");
            } else {
              _this.shape.classList.add("bump");
            }
            return _this.clearTimer = setTimeout(function() {
              _this.shape.classList.remove("bump");
              return _this.shape.classList.remove("bump-minor");
            }, 100);
          };
        })(this), 10);
      }
      this.forceBump = false;
      this.lastBuffer = this.currentBuffer;
      this.lastActive = true;
      if (this.animating) {
        this.animateFrame();
      }
      if (!option.force && !this.dirty) {
        return false;
      }
      this.currentBuffer.ensureRenderContext();
      boundary = this.cursor.getBoundary();
      visualPosition = this.cursor.getVisualPosition();
      if (visualPosition) {
        while (this.dirty) {
          caretLayout = new CaretLayout(this, visualPosition);
          boudnary = caretLayout.toBoundary();
          if (boundary) {
            this.boundaryEffectTracer.updateEffect(boundary);
          }
          this.updatePosition(caretLayout);
          this.dirty = false;
        }
      }
      style = this.cursor.getStyle();
      this.applyStyle(style);
      if (this.animating) {
        return this.animateFrame();
      }
    };

    Caret.prototype.updatePosition = function(layout) {
      var renderDetail, visualPosition;
      if (!this.isActive) {
        return false;
      }
      if (!layout) {
        this.hide();
        return;
      } else {
        this.show();
      }
      visualPosition = layout.visualPosition;
      renderDetail = layout.getRenderDetail();
      if (!renderDetail) {
        return;
      }
      this.lastRenderDetail = renderDetail;
      this.currentBuffer.lastCaretRenderDetail = this.lastRenderDetail;
      if (renderDetail.type === "cover") {
        this.shape.classList.add("cover");
      } else {
        this.shape.classList.remove("cover");
      }
      this.showType = renderDetail.type;
      this.setAnimateTo(renderDetail);
      this.emit("move", renderDetail);
      this.saveBestPosition(layout);
      if (this.requestScroll && !this.editor.platform.isMobile()) {
        this.scrollViewPortToComfortable();
        this.requestScroll = false;
      }
      return this.switchingBuffer = false;
    };

    Caret.prototype.applyNodePosition = function() {
      var ps;
      ps = this.nodePosition;
      this.shape$.css({
        width: ps.width,
        height: ps.height
      });
      return this.node$.css({
        transform: "translateX(" + (Math.round(ps.left)) + "px) translateY(" + (Math.round(ps.top)) + "px)"
      });
    };

    Caret.prototype.setAnimateTo = function(targetPosition) {
      var distance, type, x, y;
      type = targetPosition.type;
      if (type === "cover@disable") {
        this.node.classList.remove("jump");
      } else {
        if (!this.nodePosition) {
          this.node.classList.add("jump");
        } else {
          x = Math.abs(targetPosition.left - this.nodePosition.left);
          y = Math.abs(targetPosition.top - this.nodePosition.top);
          distance = Math.sqrt(x * x + y * y);
          if (distance > 100 || this.switchingBuffer) {
            this.node.classList.add("jump");
          } else {
            this.node.classList.remove("jump");
          }
        }
      }
      this.nodePosition = targetPosition;
      this.applyNodePosition();
    };

    Caret.prototype.saveBestPosition = function(layout) {
      var bestX;
      if (this.currentBuffer.disableSaveBestPosition) {
        return;
      }
      bestX = layout.getCenterX();
      if (this.lastBestX !== bestX) {
        this.currentBuffer.bestCaretOffset = bestX;
        return this.lastBestX = bestX;
      }
    };

    Caret.prototype.show = function() {
      var ref;
      if (this.isShow) {
        return;
      }
      this.isShow = true;
      if (((ref = this.currentBuffer) != null ? ref.viewPort : void 0) && this.node.parentElement !== this.currentBuffer.viewPort.el) {
        this.currentBuffer.viewPort.el.appendChild(this.node);
      }
      this.VM.visibleState = "shown";
      return this.activate();
    };

    Caret.prototype.cloak = function() {
      this.show();
      return this.VM.visibleState = "cloaked";
    };

    Caret.prototype.hide = function() {
      if (!this.isShow) {
        return;
      }
      this.isShow = false;
      this.deactivate();
      return this.VM.visibleState = "hidden";
    };

    Caret.prototype.activate = function() {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      return this.applyBlink();
    };

    Caret.prototype.deactivate = function() {
      if (!this.isActive) {
        return;
      }
      this.isActive = false;
      return clearTimeout(this.blinkTimer);
    };

    Caret.prototype.applyStyle = function(style) {
      var className;
      if (style == null) {
        style = {};
      }
      className = style.className;
      if (className === this.currentClassName) {
        return false;
      }
      this.shape.classList.remove(this.currentClassName);
      this.shape.classList.add(className);
      this.currentClassName = className;
      return true;
    };

    return Caret;

  })(Leaf.Widget);

  CaretBlinkableTrait = (function(superClass) {
    extend(CaretBlinkableTrait, superClass);

    function CaretBlinkableTrait() {
      return CaretBlinkableTrait.__super__.constructor.apply(this, arguments);
    }

    CaretBlinkableTrait.prototype.initialize = function() {
      this.blinkStart = Date.now();
      return this.listenBy(CaretBlinkableTrait, "move", (function(_this) {
        return function() {
          return _this.resetBlink();
        };
      })(this));
    };

    CaretBlinkableTrait.prototype.resetBlink = function() {
      return this.blinkStart = Date.now();
    };

    CaretBlinkableTrait.prototype.shouldBlinkShow = function() {
      var hideTime, left, showTime;
      showTime = 800;
      hideTime = 500;
      left = (Date.now() - this.blinkStart) % (showTime + hideTime);
      if (left > showTime) {
        return false;
      }
      return true;
    };

    CaretBlinkableTrait.prototype.applyBlink = function() {
      if (!this.shouldBlinkShow()) {
        return this.shape.classList.add("blink-off");
      } else {
        return this.shape.classList.remove("blink-off");
      }
    };

    return CaretBlinkableTrait;

  })(Leaf.Trait);

  CaretWritableTrait = (function(superClass) {
    extend(CaretWritableTrait, superClass);

    function CaretWritableTrait() {
      return CaretWritableTrait.__super__.constructor.apply(this, arguments);
    }

    CaretWritableTrait.prototype.initialize = function() {
      return this.applyWritableListener();
    };

    CaretWritableTrait.prototype.markAsWritable = function() {
      this.unwritable = false;
      return this.shape.classList.remove("unwritable");
    };

    CaretWritableTrait.prototype.unmarkAsWritable = function() {
      this.unwritable = true;
      return this.shape.classList.add("unwritable");
    };

    CaretWritableTrait.prototype.applyWritableListener = function() {
      return this.editor.bufferManager.listenBy(this, "focus", (function(_this) {
        return function(buffer) {
          var Buffer;
          Buffer = require("./buffer");
          if (buffer instanceof Buffer.RichBuffer) {
            return _this.markAsWritable();
          } else {
            return _this.unmarkAsWritable();
          }
        };
      })(this));
    };

    return CaretWritableTrait;

  })(Leaf.Trait);

  CaretActionTrait = (function(superClass) {
    extend(CaretActionTrait, superClass);

    function CaretActionTrait() {
      return CaretActionTrait.__super__.constructor.apply(this, arguments);
    }

    CaretActionTrait.prototype.forwardChar = function() {
      var ref;
      if (!this.isActive) {
        return false;
      }
      return (ref = this.cursor) != null ? ref.conduct("forwardChar") : void 0;
    };

    CaretActionTrait.prototype.backwardChar = function() {
      var ref;
      if (!this.isActive) {
        return false;
      }
      return (ref = this.cursor) != null ? ref.conduct("backwardChar") : void 0;
    };

    CaretActionTrait.prototype.vertical = function(step) {
      var MAX, bestCursorData, bestRegion, bestX, breakDy, canBreak, counter, currentPoint, cursor, dx, dy, lastDx, moveOnce, next, previous, rd, result, startPoint, topStart, vp;
      if (!this.isActive) {
        return false;
      }
      this.currentBuffer.render();
      if (step > 0) {
        next = this.forwardChar.bind(this);
        previous = this.backwardChar.bind(this);
      } else {
        previous = this.forwardChar.bind(this);
        next = this.backwardChar.bind(this);
      }
      cursor = this.cursor;
      bestRegion = null;
      bestX = this.currentBuffer.bestCaretOffset;
      vp = this.cursor.getVisualPosition();
      if (!vp) {
        return false;
      }
      rd = CaretLayout.getRenderDetail(this, vp);
      topStart = rd.top;
      startPoint = rd.center;
      if (typeof bestX === "number") {
        startPoint.x = bestX;
      }
      lastDx = null;
      counter = 0;
      MAX = 1000;
      this.cursor.startTeleport();
      while (true) {
        if (counter > MAX) {
          Logger.error("Unlimited caret move");
          return true;
        }
        result = next();
        if (!result) {
          break;
        }
        counter += 1;
        moveOnce = true;
        vp = this.cursor.getVisualPosition();
        if (!vp) {
          continue;
        }
        rd = CaretLayout.getRenderDetail(this, vp);
        if (!rd) {
          continue;
        }
        if ((rd.top - topStart) * step <= 0) {
          continue;
        }
        currentPoint = rd.center;
        dy = currentPoint.y - startPoint.y;
        if (dy * step > 0 && Math.abs(dy) - Math.abs(step) > 0) {
          if (!canBreak) {
            breakDy = dy;
            canBreak = true;
          } else {
            if (Math.abs(dy - breakDy) > Math.abs(step) && bestCursorData) {
              break;
            }
          }
        }
        if (canBreak) {
          dx = Math.abs(currentPoint.x - startPoint.x);
          if (typeof lastDx !== "number") {
            bestCursorData = this.cursor.getData();
            lastDx = dx;
          } else if (dx <= lastDx) {
            bestCursorData = this.cursor.getData();
            lastDx = dx;
          } else if (dx > lastDx) {
            break;
          }
        }
      }
      if (!bestCursorData) {
        this.cursor.endTeleport();
        return moveOnce;
      }
      this.cursor.pointAtAnchor(bestCursorData.anchor);
      this.cursor.endTeleport();
      return true;
    };

    CaretActionTrait.prototype.verticalJump = function(step) {
      var bestRegion, bestX, boundary, charCount, counter, currentPoint, cursor, dy, estimate, estimation, getDist, greedy, greedyLimit, lastDy, lastEstimation, method, minVerticalChange, moveOnce, rect, ref, region, startPoint, topStart;
      if (!this.isActive) {
        return false;
      }
      if (step > 0) {
        method = "forwardChar";
      } else {
        method = "backwardChar";
      }
      cursor = this.cursor;
      boundary = cursor.getBoundary();
      region = DOMRegion.fromBoundary(boundary);
      rect = region.getClientRect();
      topStart = rect.top;
      bestRegion = null;
      greedy = true;
      greedyLimit = 10;
      minVerticalChange = 12;
      lastEstimation = 9999999;
      bestX = this.currentBuffer.bestCaretOffset;
      if (boundary.type === "include") {
        startPoint = {
          x: typeof bestX === "number" && bestX || (rect.left + rect.right) / 2,
          y: (rect.top + rect.bottom) / 2
        };
      } else {
        startPoint = {
          x: typeof bestX === "number" && bestX || rect.left,
          y: (rect.top + rect.bottom) / 2
        };
      }
      counter = 0;
      estimate = function(base, current) {
        var dx, dy;
        dx = current.x - base.x;
        dy = current.y - base.y;
        if (Math.abs(dy) < minVerticalChange) {
          return 999999999;
        }
        return dx * dx + dy * dy;
      };
      charCount = 0;
      while (this[method]()) {
        moveOnce = true;
        boundary = this.cursor.getBoundary();
        if (!boundary) {
          break;
        }
        region = DOMRegion.fromBoundary(boundary);
        rect = region.getRect({
          top: (ref = this.viewPort) != null ? ref.el : void 0
        });
        if (!rect) {
          break;
        }
        if ((rect.top - topStart) * step <= 0) {
          continue;
        }
        getDist = function(x, y) {
          return x * x + y * y;
        };
        if (boundary.type === "include") {
          currentPoint = {
            x: (rect.left + rect.right) / 2,
            y: (rect.top + rect.bottom) / 2
          };
        } else {
          currentPoint = {
            x: rect.left,
            y: (rect.top + rect.bottom) / 2
          };
        }
        estimation = estimate(startPoint, currentPoint);
        if (estimation < lastEstimation) {
          bestRegion = region;
          lastEstimation = estimation;
          continue;
        }
        dy = currentPoint.y - startPoint.y;
        if (typeof lastDy === "number") {
          charCount += 1;
          if (charCount > 80 && bestRegion) {
            break;
          }
        }
        if (typeof lastDy !== "number") {
          if ((dy - lastDy) * step > 0) {
            counter += 1;
            lastDy = dy;
          }
        }
        if (counter > greedyLimit) {
          greedy = false;
        }
        if (!greedy && bestRegion) {
          break;
        }
      }
      if (!bestRegion) {
        return moveOnce;
      }
      cursor.setCursorByDOMRegion(bestRegion);
      return true;
    };

    CaretActionTrait.prototype.downwardChar = function() {
      var ref, result;
      if (!this.isActive) {
        return false;
      }
      if ((ref = this.cursor) != null ? ref.conduct("downwardChar") : void 0) {
        return true;
      }
      result = this.vertical(12);
      this.currentBuffer.disableSaveBestPosition = true;
      return result;
    };

    CaretActionTrait.prototype.upwardChar = function() {
      var ref, result;
      if (!this.isActive) {
        return false;
      }
      if ((ref = this.cursor) != null ? ref.conduct("upwardChar") : void 0) {
        return true;
      }
      result = this.vertical(-12);
      return this.currentBuffer.disableSaveBestPosition = true;
    };

    CaretActionTrait.prototype.write = function(value) {
      var ref, result;
      if (!this.isActive) {
        return false;
      }
      if (!this.lastWrite) {
        this.lastWrite = Date.now();
      }
      if (this.historyInterval == null) {
        this.historyInterval = 1000 * 5;
      }
      this.lastWrite = Date.now();
      result = (ref = this.cursor) != null ? ref.conduct("write", value) : void 0;
      return result;
    };

    CaretActionTrait.prototype.begin = function() {
      return this.cursor.begin();
    };

    CaretActionTrait.prototype.end = function() {
      return this.cursor.end();
    };

    return CaretActionTrait;

  })(Leaf.Trait);

  CaretViewPortPoserTrait = (function(superClass) {
    extend(CaretViewPortPoserTrait, superClass);

    function CaretViewPortPoserTrait() {
      return CaretViewPortPoserTrait.__super__.constructor.apply(this, arguments);
    }

    CaretViewPortPoserTrait.prototype.getViewPortComfortableRelation = function() {
      var bottom, rd, top;
      rd = this.currentBuffer.lastCaretRenderDetail;
      if (!rd) {
        return 0;
      }
      top = this.viewPort.scrollable.scrollTop;
      bottom = top + this.viewPort.height;
      if (rd.top - this.viewPort.comfortableMargin < top && top > 0) {
        return rd.top - this.viewPort.comfortableMargin - this.viewPort.scrollable.scrollTop;
      }
      if (rd.bottom + this.viewPort.comfortableMargin > bottom) {
        return rd.bottom + this.viewPort.comfortableMargin - this.viewPort.height - this.viewPort.scrollable.scrollTop;
      }
      return 0;
    };

    CaretViewPortPoserTrait.prototype.inViewPortComfortableZone = function() {
      var bottom, rd, top;
      rd = this.currentBuffer.lastCaretRenderDetail;
      if (!rd) {
        return false;
      }
      top = this.viewPort.scrollable.scrollTop;
      bottom = top + this.viewPort.height;
      return rd.top - this.viewPort.comfortableMargin < top && rd.bottom + this.viewPort.comfortableMargin > bottom;
    };

    CaretViewPortPoserTrait.prototype.moveToViewPortCenter = function(option) {
      var center, change, left, lr, notIncludeCenter, rect, scrollTop, top;
      if (option == null) {
        option = {};
      }
      rect = this.viewPort.el.getBoundingClientRect();
      if (!rect) {
        return;
      }
      left = (this.viewPort.buffer.bestCaretOffset || 0) + rect.left;
      top = this.viewPort.height / 2;
      change = false;
      notIncludeCenter = false;
      scrollTop = this.viewPort.scrollable.scrollTop;
      if (!this.viewPort.buffer.lastCaretRenderDetail) {
        change = true;
        notIncludeCenter = true;
      } else {
        lr = this.viewPort.buffer.lastCaretRenderDetail;
        center = scrollTop + rect.height / 2;
        if (lr.bottom < center || lr.top > center) {
          notIncludeCenter = true;
        } else {
          notIncludeCenter = false;
        }
        if (Math.abs(this.viewPort.buffer.lastCaretRenderDetail.top - (top + scrollTop)) > 30) {
          change = true;
        }
      }
      if ((notIncludeCenter && change) || option.force) {
        this.viewPort.setCursorByClientPoint(left, top);
      }
      return this.viewPort.buffer.disableSaveBestPosition = true;
    };

    CaretViewPortPoserTrait.prototype.moveToViewPortComfortableZoneLazy = function() {
      var left, move, top;
      move = this.getViewPortComfortableRelation();
      if (move === 0) {
        return false;
      }
      left = this.currentBuffer.bestCaretOffset || 0;
      if (move > 0) {
        top = this.viewPort.height - this.viewPort.comfortableMargin;
      } else {
        top = this.viewPort.comfortableMargin;
      }
      this.viewPort.setCursorByClientPoint(left, top + 10);
      return true;
    };

    CaretViewPortPoserTrait.prototype.scrollViewPortToComfortable = function(arg) {
      var center, rd, rect, ref;
      center = (arg != null ? arg : {}).center;
      rd = (ref = this.currentBuffer) != null ? ref.lastCaretRenderDetail : void 0;
      if (!rd) {
        return;
      }
      rect = {
        width: rd.width,
        height: rd.height,
        left: rd.left,
        top: rd.top,
        right: rd.left + rd.width,
        bottom: rd.top + rd.height
      };
      return this.viewPort.scrollToRectComfortableZone(rect, {
        forceCenter: rd.height > this.viewPort.height / 2 || center
      });
    };

    return CaretViewPortPoserTrait;

  })(Leaf.Trait);

  BoundaryEffectTracer = (function() {
    function BoundaryEffectTracer(caret1) {
      this.caret = caret1;
      this.name = this.caret.name || "master";
      this.affected = [];
      this.__defineSetter__("dirty", function(value) {
        if (this.caret.dirty !== value) {
          this.caret.dirty = value;
        }
        if (value) {
          return this.sessionDirty = true;
        }
      });
      this.__defineGetter__("dirty", function() {
        return this.caret.dirty;
      });
    }

    BoundaryEffectTracer.prototype.getAffectedNode = function(boundary) {
      var cDecPart, cDecs, cText, className, i, j, left, len, len1, match, next, oldAffected, prev, previous, ref, ref1, result, right;
      if (boundary.type === "include") {
        return oldAffected = [boundary.node];
      } else if (boundary.node.nodeType === boundary.node.TEXT_NODE) {
        cDecPart = boundary.node.parentElement;
        cDecs = [cDecPart];
        if (boundary.offset === 0 && (boundary.type === "left" || !boundary.type)) {
          prev = cDecPart.previousElementSibling;
          if (prev) {
            cDecs.unshift(prev);
          }
        } else if ((boundary.offset === boundary.node.length && boundary.type === "left") || (boundary.offset === boundary.node.length - 1 && boundary.type === "right")) {
          next = cDecPart.nextElementSibling;
          if (next) {
            cDecs.push(next);
          }
        }
        cText = cDecPart != null ? cDecPart.parentElement : void 0;
        if (cDecPart != null ? cDecPart.classList.contains("com-holder") : void 0) {
          return [];
        }
        if (!cText || !cText.classList.contains("com-text")) {
          return [];
        }
        result = [cDecPart];
        previous = cDecPart;
        left = cDecs[0];
        right = cDecs[cDecs.length - 1];
        while (previous = previous.previousElementSibling) {
          match = false;
          ref = previous.classList;
          for (i = 0, len = ref.length; i < len; i++) {
            className = ref[i];
            if (className.indexOf("com-inline") !== 0 && className.indexOf("com-group") !== 0) {
              continue;
            }
            if (left.classList.contains(className)) {
              match = true;
              break;
            }
            if (match) {
              break;
            }
          }
          if (!match) {
            break;
          }
          result.unshift(previous);
        }
        next = cDecPart;
        while (next = next.nextElementSibling) {
          match = false;
          ref1 = next.classList;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            className = ref1[j];
            if (className.indexOf("com-inline") !== 0) {
              continue;
            }
            if (right.classList.contains(className)) {
              match = true;
              break;
            }
            if (match) {
              break;
            }
          }
          if (!match) {
            break;
          }
          result.push(next);
        }
        return result;
      } else {
        return [];
      }
    };

    BoundaryEffectTracer.prototype.updateEffect = function(boundary) {
      var d1, d2, d3, d4, ref;
      this.sessionDirty = false;
      this.updateOverEffect(boundary);
      d1 = this.dirty;
      this.updateAdjacentEffect(boundary);
      d2 = this.dirty;
      this.updateNearbyEffect(boundary);
      d3 = this.dirty;
      this.updateKeyPathEffect(boundary);
      d4 = this.dirty;
      if (this.sessionDirty) {
        return (ref = this.caret.currentBuffer) != null ? ref.emit("resize") : void 0;
      }
    };

    BoundaryEffectTracer.prototype.updateKeyPathEffect = function(b) {
      var drop, el, i, index, item, j, k, kps, len, len1, len2, offset, ref, ref1;
      if (this.keyPathElements == null) {
        this.keyPathElements = [];
      }
      kps = [];
      b = new DOMBoundary(b);
      el = b.getTargetParent();
      while (el && el.parentElement && el.parentElement !== this.caret.currentBuffer.viewPort.el) {
        if (el.classList) {
          kps.unshift(el);
        }
        el = el.parentElement;
      }
      index = -1;
      ref = this.keyPathElements;
      for (offset = i = 0, len = ref.length; i < len; offset = ++i) {
        item = ref[offset];
        if (kps[offset] !== item) {
          break;
        }
        index = offset;
      }
      index += 1;
      drop = this.keyPathElements.splice(index);
      for (j = 0, len1 = drop.length; j < len1; j++) {
        item = drop[j];
        item.classList.remove(this.name + "-caret-key-path");
        this.dirty = true;
      }
      kps = kps.slice(index);
      for (k = 0, len2 = kps.length; k < len2; k++) {
        item = kps[k];
        this.dirty = true;
        item.classList.add(this.name + "-caret-key-path");
      }
      (ref1 = this.keyPathElements).push.apply(ref1, kps);
      return true;
    };

    BoundaryEffectTracer.prototype.updateAdjacentEffect = function(b) {
      var adjacent, ref, ref1, ref2, ref3;
      b = new DOMBoundary(b);
      adjacent = b.getAdjacentElement();
      if (adjacent.left !== this.leftAdjacent) {
        if ((ref = this.leftAdjacent) != null) {
          ref.classList.remove(this.name + "-caret-right");
        }
        if ((ref1 = adjacent.left) != null) {
          ref1.classList.add(this.name + "-caret-right");
        }
        this.leftAdjacent = adjacent.left;
        this.dirty = true;
      }
      if (adjacent.right !== this.rightAdjacent) {
        if ((ref2 = this.rightAdjacent) != null) {
          ref2.classList.remove(this.name + "-caret-left");
        }
        if ((ref3 = adjacent.right) != null) {
          ref3.classList.add(this.name + "-caret-left");
        }
        this.rightAdjacent = adjacent.right;
        return this.dirty = true;
      }
    };

    BoundaryEffectTracer.prototype.updateOverEffect = function(b) {
      var base1, base2, maxParent, node, ref, ref1, ref2, ref3;
      maxParent = 5;
      node = b.node;
      while ((node = node.parentElement) && maxParent > 0) {
        maxParent -= 1;
        if (((ref = node.classList) != null ? typeof ref.contains === "function" ? ref.contains("com-text") : void 0 : void 0) || ((ref1 = node.classList) != null ? typeof ref1.contains === "function" ? ref1.contains("com-holder") : void 0 : void 0)) {
          break;
        }
      }
      if (typeof (base1 = node.classList).contains === "function" ? base1.contains("com-holder") : void 0) {
        node = node.previousElementSibling || null;
      }
      if (!node || !(typeof (base2 = node.classList).contains === "function" ? base2.contains("com-text") : void 0)) {
        if (this.overText) {
          if ((ref2 = this.overText) != null) {
            ref2.classList.remove(this.name + "-caret-over");
          }
          this.overText = null;
          this.dirty = true;
        }
        return;
      }
      if (node === this.overText && this.overText) {
        return;
      }
      this.dirty = true;
      if ((ref3 = this.overText) != null) {
        ref3.classList.remove(this.name + "-caret-over");
      }
      this.overText = node;
      return this.overText.classList.add(this.name + "-caret-over");
    };

    BoundaryEffectTracer.prototype.updateNearbyEffect = function(boundary) {
      var i, index, item, j, k, len, len1, len2, modified, newAffected, oldAffected, results;
      oldAffected = this.affected.slice(0);
      newAffected = this.getAffectedNode(boundary);
      modified = true;
      if (oldAffected.length === newAffected.length) {
        modified = false;
        for (index = i = 0, len = newAffected.length; i < len; index = ++i) {
          item = newAffected[index];
          if (item !== oldAffected[index]) {
            modified = true;
            break;
          }
        }
      }
      this.affected = newAffected;
      if (!modified) {
        return false;
      }
      this.dirty = true;
      for (j = 0, len1 = oldAffected.length; j < len1; j++) {
        item = oldAffected[j];
        item.classList.remove(this.name + "-caret-nearby");
      }
      results = [];
      for (k = 0, len2 = newAffected.length; k < len2; k++) {
        item = newAffected[k];
        results.push(item.classList.add(this.name + "-caret-nearby"));
      }
      return results;
    };

    return BoundaryEffectTracer;

  })();

  CaretPosition = (function() {
    function CaretPosition(caret1, boundary) {
      this.caret = caret1;
      this.editor = this.caret.editor;
      this.node = boundary != null ? boundary.node : void 0;
      this.index = (boundary != null ? boundary.index : void 0) || (boundary != null ? boundary.offset : void 0);
      this.char = boundary != null ? boundary.char : void 0;
      this.boundary = boundary;
      this.type = this.boundary.type;
      this.viewPort = this.caret.viewPort || null;
    }

    CaretPosition.prototype.getRect = function(right) {
      var rect, ref;
      if (this.region == null) {
        this.region = DOMRegion.fromBoundary(this.boundary);
      }
      rect = this.region.getRect({
        top: (ref = this.viewPort) != null ? ref.el : void 0
      });
      this.caret.viewPort.resolveRect(rect);
      return rect;
    };

    return CaretPosition;

  })();

  CaretLayout = (function() {
    CaretLayout.getRenderDetail = function(caret, vp) {
      var layout;
      layout = new CaretLayout(caret, vp);
      return layout.getRenderDetail();
    };

    function CaretLayout(caret1, visualPosition1) {
      var heightExpand, widthExpand;
      this.caret = caret1;
      this.visualPosition = visualPosition1;
      widthExpand = 0;
      heightExpand = 0;
    }

    CaretLayout.prototype.getRenderDetail = function() {
      var height, heightExpand, i, item, left, leftFix, len, orders, rd, rect, top, topFix, type, valid, vp, width, widthExpand;
      vp = this.visualPosition;
      widthExpand = 0;
      heightExpand = 0;
      topFix = 0;
      leftFix = 0;
      width = 2;
      if (vp.center) {
        orders = ["center"];
      } else if (vp.right && vp.priority === "right") {
        orders = ["right", "left"];
      } else {
        orders = ["left", "right"];
      }
      valid = false;
      for (i = 0, len = orders.length; i < len; i++) {
        item = orders[i];
        if (item === "center") {
          if (!vp.center) {
            continue;
          }
          rect = this.getCenterRect();
          if (!rect) {
            continue;
          }
          width = rect.width;
          height = rect.height;
          top = rect.top;
          left = rect.left;
          heightExpand = 4;
          widthExpand = 4;
          type = "cover";
          valid = true;
          break;
        } else if (item === "right") {
          if (!vp.right) {
            continue;
          }
          rect = this.getRightRect();
          if (!rect) {
            continue;
          }
          height = rect.height;
          heightExpand = Math.min(height * 0.3, 4);
          if (vp.right.position === "right") {
            left = rect.right;
          } else {
            left = rect.left;
          }
          top = rect.top;
          type = "caret";
          valid = true;
          break;
        } else if (item === "left") {
          if (!vp.left) {
            continue;
          }
          rect = this.getLeftRect();
          if (!rect) {
            continue;
          }
          height = rect.height;
          heightExpand = Math.min(height * 0.3, 4);
          if (vp.left.position === "right") {
            left = rect.right;
          } else {
            left = rect.left;
          }
          top = rect.top;
          type = "caret";
          valid = true;
          break;
        }
      }
      if (!valid) {
        return null;
      }
      leftFix = -widthExpand / 2;
      topFix = -heightExpand / 2;
      rd = {
        height: height + heightExpand,
        width: width + widthExpand,
        top: top + topFix,
        left: left + leftFix,
        type: type
      };
      rd.bottom = rd.top + rd.height;
      rd.right = rd.left + rd.width;
      rd.__defineGetter__("center", (function(_this) {
        return function() {
          return rd.center = {
            y: (rd.top + rd.bottom) / 2,
            x: (rd.left + rd.right) / 2
          };
        };
      })(this));
      return rd;
    };

    CaretLayout.prototype.getCenterX = function() {
      var ref, ref1;
      return (ref = this.getRenderDetail()) != null ? (ref1 = ref.center) != null ? ref1.x : void 0 : void 0;
    };

    CaretLayout.prototype.equalTo = function(target) {
      return this.rectIdentical(this.getCenterRect(), target.getCenterRect()) && this.rectIdentical(this.getLeftRect(), target.getLeftRect()) && this.rectIdentical(this.getRightRect(), target.getRightRect());
    };

    CaretLayout.prototype.rectIdentical = function(a, b) {
      var i, len, prop, props;
      if (!a && !b) {
        return true;
      }
      if (a && b) {
        props = ["left", "right", "top", "bottom"];
        for (i = 0, len = props.length; i < len; i++) {
          prop = props[i];
          if (parseInt(a[prop]) !== parseInt(b[prop])) {
            return false;
          }
        }
        return true;
      }
      return false;
    };

    CaretLayout.prototype.getCenterRect = function() {
      var vp;
      vp = this.visualPosition;
      if (!vp.center) {
        return null;
      }
      return this.centerRect || (this.centerRect = this._getBorderRect(vp.center));
    };

    CaretLayout.prototype.getLeftRect = function() {
      var vp;
      vp = this.visualPosition;
      if (!vp.left) {
        return null;
      }
      return this.leftRect || (this.leftRect = this._getBorderRect(vp.left));
    };

    CaretLayout.prototype.getRightRect = function() {
      var vp;
      vp = this.visualPosition;
      if (!vp.right) {
        return null;
      }
      return this.rightRect || (this.rightRect = this._getBorderRect(vp.right));
    };

    CaretLayout.prototype._getBorderRect = function(border) {
      var rect, ref, region;
      region = new DOMRegion(border.node, border.offset);
      rect = region.getRect({
        top: (ref = this.caret.viewPort) != null ? ref.el : void 0
      });
      if (!rect) {
        return null;
      }
      return rect;
    };

    CaretLayout.prototype.toBoundary = function() {
      var vp;
      vp = this.visualPosition;
      if (vp.center) {
        return new DOMBoundary({
          node: vp.center.node,
          offset: vp.center.offset,
          type: "include"
        });
      } else if (vp.left) {
        return new DOMBoundary({
          node: vp.left.node,
          offset: vp.left.offset,
          type: "right"
        });
      } else if (vp.right) {
        return new DOMBoundary({
          node: vp.right.node,
          offset: vp.right.offset,
          type: "left"
        });
      }
    };

    return CaretLayout;

  })();

  Caret.CaretPosition = CaretPosition;

  module.exports = Caret;

}).call(this);

}
GlobalContext.setModule("vincent/facility/caret.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/clipboard.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMConverter, COMFlattenLevel1, Clip, Clipboard, html2markdown,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  html2markdown = require("/component/html2markdown");

  COMConverter = require("./comConverter");

  Clipboard = (function() {
    function Clipboard(editor) {
      this.editor = editor;
      this.mime = "application/json";
      window.addEventListener("paste", (function(_this) {
        return function(e) {
          var error, i, item, len, ref, type;
          ref = e.clipboardData.items || {};
          for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            type = item.type || "";
          }
          if (!_this.editor.buffer || !_this.editor.buffer.selection) {
            return;
          }
          if (_this.editor.buffer.selection.isActive && !_this.editor.buffer.selection.isCollapsed()) {
            _this.editor.context.transact(function() {
              return _this.editor.buffer.selection.removeSelectedNodes();
            });
          }
          if (!_this.isActive) {
            return;
          }
          _this.editor.userIsWriting = true;
          try {
            _this.pasteClipboardData(e);
          } catch (error) {
            e = error;
            Logger.error("past failure");
            Logger.error(e);
          }
          return _this.editor.userIsWriting = false;
        };
      })(this), true);
      window.addEventListener("copy", (function(_this) {
        return function(e) {
          var com, cursor, err, error, readonly, ref, ref1, ref2, ref3, ref4, ref5, result, rune, text, wrapper;
          _this.context = _this.editor.context;
          readonly = (ref = _this.context) != null ? ref.isReadonly : void 0;
          try {
            if ((ref1 = _this.context) != null) {
              ref1.isReadonly = false;
            }
            if (!_this.isActive) {
              return;
            }
            cursor = _this.editor.buffer.cursor;
            if (((ref2 = _this.editor.buffer.selection) != null ? ref2.isActive : void 0) && !_this.editor.buffer.selection.isCollapsed()) {
              com = _this.editor.buffer.selection.copySelectedNodes();
              result = _this.extractPasteCOM(com);
              text = com.toHumanString();
              _this.setClipboardData(e, {
                com: result,
                text: text
              });
            } else if ((cursor != null ? cursor.anchor.inside : void 0) && (rune = cursor.target.runeAtIndex(cursor.anchor.index))) {
              wrapper = _this.editor.context.createElement("RichText", {
                contentString: ""
              });
              wrapper.insertRune(0, rune.clone());
              result = _this.extractPasteCOM(wrapper);
              _this.setClipboardData(e, {
                com: result,
                text: (typeof rune.toHumanString === "function" ? rune.toHumanString() : void 0) || ""
              });
            } else {

            }
            _this.context.isReadonly = readonly;
          } catch (error) {
            err = error;
            Logger.error(e, err, "fail to copy things");
          }
          if (_this.editor.platform.isMobile() && ((ref3 = (ref4 = document.activeElement) != null ? ref4.type : void 0) !== "textarea" && ref3 !== "input")) {
            if ((ref5 = document.activeElement) != null) {
              if (typeof ref5.blur === "function") {
                ref5.blur();
              }
            }
            return _this.editor.inputMethod.showVirtualKeyboard();
          }
        };
      })(this), true);
      window.addEventListener("cut", (function(_this) {
        return function(e) {
          var clone, cursor, error, readonly, ref, ref1, ref2, ref3, ref4, ref5, result, rune, wrapper;
          if (!_this.isActive) {
            return;
          }
          _this.context = _this.editor.context;
          readonly = (ref = _this.context) != null ? ref.isReadonly : void 0;
          if (readonly) {
            return;
          }
          _this.editor.userIsWriting = true;
          try {
            if ((ref1 = _this.context) != null) {
              ref1.isReadonly = false;
            }
            cursor = _this.editor.buffer.cursor;
            if (((ref2 = _this.editor.buffer.selection) != null ? ref2.isActive : void 0) && !_this.editor.buffer.selection.isCollapsed()) {
              _this.editor.context.transact(function() {
                var com, result, text;
                com = _this.editor.buffer.selection.cutSelectedNodes();
                result = _this.extractPasteCOM(com);
                text = com.toHumanString();
                return _this.setClipboardData(e, {
                  com: result,
                  text: text
                });
              });
            } else if ((cursor != null ? cursor.anchor.inside : void 0) && (rune = cursor.target.runeAtIndex(cursor.anchor.index))) {
              clone = rune.clone();
              _this.editor.context.transact(function() {
                rune.parent.reflow();
                cursor.anchor.index = rune.startOffset;
                return rune.parent.removeText(rune.startOffset, rune.length);
              });
              wrapper = _this.editor.context.createElement("RichText", {
                contentString: ""
              });
              wrapper.insertRune(0, clone);
              result = _this.extractPasteCOM(wrapper);
              _this.setClipboardData(e, {
                com: result,
                text: (typeof rune.toHumanString === "function" ? rune.toHumanString() : void 0) || ""
              });
            }
            _this.context.isReadonly = readonly;
          } catch (error) {
            e = error;
            Logger.error(e, "fail to copy things");
          }
          if (_this.editor.platform.isMobile() && ((ref3 = (ref4 = document.activeElement) != null ? ref4.type : void 0) !== "textarea" && ref3 !== "input")) {
            if ((ref5 = document.activeElement) != null) {
              if (typeof ref5.blur === "function") {
                ref5.blur();
              }
            }
            _this.editor.inputMethod.showVirtualKeyboard();
          }
          return _this.editor.userIsWriting = false;
        };
      })(this), true);
    }

    Clipboard.prototype.extractPasteCOM = function(value) {
      var results, target;
      value = value.toJSON();
      results = [];
      target = value;
      return value;
    };

    Clipboard.prototype.enable = function() {
      return this.isActive = true;
    };

    Clipboard.prototype.disable = function() {
      return this.isActive = false;
    };

    Clipboard.prototype.extractPasteCOM = function(value) {
      var parser;
      parser = new COMFlattenLevel1(this.editor, value);
      parser.parse();
      if (parser.results.length === 0) {
        return null;
      }
      if (parser.results) {
        return {
          version: "v1",
          type: "com",
          contents: parser.results
        };
      }
      return null;
    };

    Clipboard.prototype.setClipboardData = function(e, json) {
      var clip;
      clip = new Clip(e);
      return clip.setClipboardData({
        text: json.text,
        com: json.com
      });
    };

    Clipboard.prototype.insertCOM = function(value) {
      if (value.version === "v0" || !value.version) {
        return this.pasteCOMV0(value);
      } else if (value.version === "v1") {
        return this.pasteCOMV1(value);
      }
    };

    Clipboard.prototype.insertText = function(text) {
      return this.editor.conduct("write", text);
    };

    Clipboard.prototype.pasteClipboardData = function(e) {
      var clip, data, ref, target, url;
      if ((ref = this.editor.buffer.selection) != null ? ref.isActive : void 0) {
        this.editor.buffer.selection.cancel();
      }
      if (this.editor.buffer.type !== "RichBuffer") {
        return;
      }
      clip = new Clip(e);
      data = clip.getClipboardData();
      target = this.editor.buffer.cursor.target;
      if (!target || !target.mime) {
        return;
      }
      e.preventDefault();
      e.stopImmediatePropagation();
      if (data.image) {
        this.editor.inputMethod.emit("image", data.image);
        return;
      }
      if (data.com) {
        if (target.mime === "text/com-rich-text") {
          this.insertCOM(data.com);
          return;
        } else {
          this.insertText(data.text);
          return;
        }
      } else if (data.html && !data.com && (!html2markdown.isHTMLSimple(data.html) || window.forcePasteHTML)) {
        this.editor.conduct("write", this.editor.buffer.context.createElement("HTMLPortion", {
          html: data.html
        }));
        return;
      } else if (data.markdown) {
        this.editor.conduct("write", data.markdown);
        return;
      }
      if (!data.text) {
        return;
      }
      if (data.text && (url = this.extractAppUrl(data.text))) {
        e.preventDefault();
        this.editor.conduct("write", url);
        return true;
      } else if (data.text) {
        return this.editor.conduct("write", data.text);
      }
    };

    Clipboard.prototype.extractAppUrl = function(text) {
      var _, currentMatch, currentUser, domain, domains, match, path, protocol, protocols, reg, reservedKeyword, username;
      if (!text) {
        return null;
      }
      protocols = ["https", "http"];
      domains = ["miku\\.jitaku\\.io", "jitaku\\.io", "vuvu:9999"];
      reg = new RegExp("^\\s*(" + (protocols.join("|")) + ")://(" + (domains.join("|")) + ")/([a-z0-9_-]*)/(.*)$", "i");
      match = text.trim().match(reg);
      if (!match) {
        return null;
      }
      _ = match[0], protocol = match[1], domain = match[2], username = match[3], path = match[4];
      reservedKeyword = ["s", "share"];
      if (indexOf.call(reservedKeyword, username) >= 0) {
        return null;
      }
      currentMatch = window.location.toString().match(reg);
      currentUser = (currentMatch != null ? currentMatch[3] : void 0) || null;
      if (currentUser === username) {
        return "jtk://" + path;
      } else {
        return "jtk:///" + username + "/" + path;
      }
    };

    Clipboard.prototype.pasteCOMV0 = function(value) {
      return this.editor.context.transact((function(_this) {
        return function() {
          var node, ref, split, temp;
          split = (ref = _this.editor.buffer.cursor.anchor) != null ? ref.split() : void 0;
          temp = _this.editor.context.createElement("RichText", {
            contentString: ""
          });
          node = _this.editor.context.createElement(value);
          if (split || _this.editor.buffer.cursor.anchor.isTail()) {
            _this.editor.buffer.cursor.target.after(temp);
            _this.editor.buffer.cursor.target.after(node);
          } else {
            _this.editor.buffer.cursor.target.before(node);
            _this.editor.buffer.cursor.target.before(temp);
          }
          _this.editor.buffer.cursor.pointAt(temp);
          _this.editor.buffer.cursor.anchor.head();
          return _this.editor.caret.scrollViewPortToComfortable();
        };
      })(this));
    };

    Clipboard.prototype.pasteCOMV1_2 = function(value) {
      return this.editor.context.transact((function(_this) {
        return function() {
          var contents, cs, cursor, i, item, len, ref, rt, rune, split, target;
          contents = value.contents.slice();
          cursor = _this.editor.buffer.cursor;
          target = cursor.target;
          target.reflow();
          if (rune = target.runeAtIndex(cursor.anchor.index)) {
            cursor.anchor.index = rune.endOffset;
          }
          split = (ref = _this.editor.buffer.cursor.anchor) != null ? ref.split() : void 0;
          cs = "";
          for (i = 0, len = contents.length; i < len; i++) {
            item = contents[i];
            rt = _this.editor.context.createElement(item);
            if (!rt.sortOf("RichText")) {
              Logger.error("Unexpected clip item", rt);
              continue;
            }
            cs += rt.contentString;
          }
          _this.editor.buffer.cursor.target.insertText(_this.editor.buffer.cursor.anchor.index, cs);
          _this.editor.buffer.cursor.anchor.index += cs.length;
          return _this.editor.caret.scrollViewPortToComfortable();
        };
      })(this));
    };

    Clipboard.prototype.pasteCOMV1 = function(value) {
      return this.editor.context.transact((function(_this) {
        return function() {
          var contents, cs, cursor, i, index, item, j, last, len, len1, node, ref, rt, rune, split, target, temp;
          contents = value.contents.slice();
          cursor = _this.editor.buffer.cursor;
          target = cursor.target;
          target.reflow();
          if (rune = target.runeAtIndex(cursor.anchor.index)) {
            if (target.anchor.inside) {
              cursor.anchor.index = rune.endOffset;
            }
          }
          split = (ref = _this.editor.buffer.cursor.anchor) != null ? ref.split() : void 0;
          if (contents.length !== 1 || contents[0].collapseListItems || contents[0].collapseHeadContents) {
            temp = _this.editor.context.createElement("RichText", {
              contentString: ""
            });
            if (split || _this.editor.buffer.cursor.anchor.isTail()) {
              _this.editor.buffer.cursor.target.after(temp);
              contents.reverse();
              for (index = i = 0, len = contents.length; i < len; index = ++i) {
                item = contents[index];
                node = _this.editor.context.createElement(item);
                _this.editor.buffer.cursor.target.after(node);
                if (index === 0) {
                  last = node;
                }
              }
            } else {
              for (index = j = 0, len1 = contents.length; j < len1; index = ++j) {
                item = contents[index];
                node = _this.editor.context.createElement(item);
                _this.editor.buffer.cursor.target.before(node);
                last = node;
              }
              _this.editor.buffer.cursor.target.before(temp);
            }
            _this.editor.buffer.cursor.pointAt(last);
            _this.editor.buffer.cursor.anchor.tail();
          } else {
            rt = _this.editor.context.createElement(contents[0]);
            cs = rt.contentString;
            _this.editor.buffer.cursor.target.insertText(_this.editor.buffer.cursor.anchor.index, cs);
            _this.editor.buffer.cursor.anchor.index += cs.length;
          }
          cursor = _this.editor.buffer.cursor;
          return _this.editor.caret.scrollViewPortToComfortable();
        };
      })(this));
    };

    return Clipboard;

  })();

  COMFlattenLevel1 = (function() {
    function COMFlattenLevel1(editor, value1) {
      this.editor = editor;
      this.value = value1;
      this.context = this.editor.context;
      this.version = 1;
    }

    COMFlattenLevel1.prototype.parse = function() {
      this.target = this.value;
      this.parents = [];
      this.results = [];
      return this.findTopRichText();
    };

    COMFlattenLevel1.prototype.father = function() {
      return this.parents[this.parents.length - 1];
    };

    COMFlattenLevel1.prototype.findTopRichText = function() {
      var parser, ref, ref1, results1, rt;
      if (!this.target) {
        return;
      }
      if (this.context.namespace.sortOf(this.target.type, "RichText")) {
        this.results.push(this.target);
        return;
      }
      if (!this.target.children || this.target.children.length === 0) {
        this.skipChildOnce = true;
        return this.stepOver();
      }
      if (this.context.namespace.sortOf(this.target.children[0].type, "RichText")) {
        this.skipChildOnce = true;
        if (this.target.children.length > 1) {
          (ref = this.results).push.apply(ref, this.target.children);
          return;
        }
        rt = this.target.children[0];
        if (!rt.isPartial) {
          this.results.push(rt);
          return;
        }
        if (rt.children && (rt.children.length > 1 || rt.children.length === 0)) {
          this.results.push(rt);
          return;
        }
        if (this.context.namespace.sortOf(rt.children[0].type, "Text")) {
          this.results.push(rt);
          return;
        }
        if (!rt.children[0].isPartial) {
          this.results.push(rt);
          return;
        }
        parser = new COMFlattenLevel1(this.editor, rt.children[0]);
        parser.parse();
        if (parser.results.length > 0) {
          (ref1 = this.results).push.apply(ref1, parser.results);
        }
        return;
      }
      results1 = [];
      while (this.stepOver()) {
        results1.push(this.findTopRichText());
      }
      return results1;
    };

    COMFlattenLevel1.prototype.stepOver = function() {
      var father, grand, index;
      if (this.target.children && this.target.children[0] && !this.skipChildOnce) {
        this.parents.push(this.target);
        this.target = this.target.children[0];
        return true;
      }
      this.skipChildOnce = false;
      father = this.father();
      if (!father) {
        return false;
      }
      index = father.children.indexOf(this.target);
      if (index < father.children.length - 1) {
        this.target = father.children[index + 1];
        return true;
      }
      while (father = this.parents.pop()) {
        grand = this.father();
        if (!grand) {
          return false;
        }
        index = grand.children.indexOf(father);
        if (index < grand.children.length - 1) {
          this.target = grand.children[index + 1];
          return true;
        }
      }
      return false;
    };

    return COMFlattenLevel1;

  })();

  Clip = (function() {
    function Clip(e1) {
      this.e = e1;
    }

    Clip.prototype.setClipboardData = function(data) {
      var comString, e;
      e = this.e;
      if (data.text) {
        e.clipboardData.setData("text/plain", data.text);
      }
      if (data.com) {
        comString = JSON.stringify(data.com);
        e.clipboardData.setData("application/json", comString);
        e.clipboardData.setData("text/html", this.encodeHTMLCOM(comString, data.text));
      }
      return e.preventDefault();
    };

    Clip.prototype.getClipboardData = function() {
      var blob, e, error, error1, error2, html, i, item, json, len, markdown, ref, result, text, type;
      e = this.e;
      text = e.clipboardData.getData("text/plain");
      json = e.clipboardData.getData("application/json");
      html = e.clipboardData.getData("text/html");
      result = {
        text: text
      };
      ref = e.clipboardData.items || {};
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        type = item.type || "";
        if (type.indexOf("image/") === 0) {
          blob = item.getAsFile();
          if (blob instanceof Blob) {
            result.image = {
              blob: blob,
              related: {
                text: text,
                json: json,
                html: html
              }
            };
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        }
      }
      e.preventDefault();
      if (json) {
        try {
          result.com = JSON.parse(json);
        } catch (error) {
          e = error;
          result.com = null;
        }
      }
      if (html) {
        result.html = html;
      }
      if (html && !result.com) {
        try {
          result.com = JSON.parse(this.decodeHTMLCOM(html));
        } catch (error1) {
          e = error1;
          result.com = null;
        }
      }
      if (html && !result.com) {
        try {
          markdown = html2markdown(html);
          result.markdown = markdown;
        } catch (error2) {
          e = error2;
          Logger.error(e);
        }
      }
      return result;
    };

    Clip.prototype.decodeHTMLCOM = function(htmlComString) {
      var content, div, pre;
      div = document.createElement("div");
      div.innerHTML = htmlComString;
      pre = div.querySelector("[com]");
      content = decodeURIComponent((pre != null ? pre.getAttribute("com") : void 0) || "");
      return content || null;
    };

    Clip.prototype.encodeHTMLCOM = function(comString, text) {
      return "<pre com=\"" + (encodeURIComponent(comString)) + "\" style=\"\">" + text + "</pre>";
    };

    return Clip;

  })();

  module.exports = Clipboard;

}).call(this);

}
GlobalContext.setModule("vincent/facility/clipboard.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/comConverter.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMConverter, HTMLEntity, HTMLTag, HTMLTag2Flatten, HTMLTagParser, Property, TableRuneParser, UlFlatter,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  HTMLEntity = require("/component/htmlEntity");

  Property = require("/component/property");

  HTMLTag = require("./htmlTag");

  COMConverter = (function() {
    function COMConverter() {}

    COMConverter.prototype.html2com = function(context, html) {
      var com, flatten, i, item, j, len, len1, parser, ref, results, richText;
      parser = new HTMLTagParser(html);
      flatten = new HTMLTag2Flatten(parser.contents);
      results = [];
      ref = flatten.result;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (typeof item === "string") {
          results.push(context.createElement("Text", {
            contentString: item
          }));
        } else {
          com = context.createElement(item);
          if (com) {
            results.push(com);
          }
        }
      }
      richText = context.createElement("RichText", {});
      for (j = 0, len1 = results.length; j < len1; j++) {
        item = results[j];
        richText.append(item);
      }
      return richText;
    };

    return COMConverter;

  })();

  HTMLTagParser = (function() {
    function HTMLTagParser(html) {
      var doc, parser;
      this.contents = new HTMLTag("!contents", [], {});
      this.tagStack = [this.contents];
      new Property(this, "currentTag").atGet((function(_this) {
        return function() {
          return _this.tagStack[_this.tagStack.length - 1] || null;
        };
      })(this));
      parser = new DOMParser();
      doc = parser.parseFromString(html, "text/html");
      this.contents.addChild(this.parse(doc));
    }

    HTMLTagParser.prototype.parse = function(el) {
      var child, i, item, j, len, len1, node, props, ref, ref1, tag;
      if (el.nodeType === el.TEXT_NODE) {
        return new HTMLTag("TEXT", el.textContent);
      }
      props = {};
      if (el.attributes) {
        ref = el.attributes;
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          props[item.name] = item.value;
        }
      }
      tag = new HTMLTag((el.tagName || "Unknown").toLowerCase(), [], props);
      if (el.childNodes) {
        ref1 = el.childNodes;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          node = ref1[j];
          child = this.parse(node);
          if (child) {
            tag.addChild(child);
          }
        }
      }
      return tag;
    };

    return HTMLTagParser;

  })();

  HTMLTag2Flatten = (function() {
    function HTMLTag2Flatten(htmlTag) {
      var fn, heading, i, level;
      this.htmlTag = htmlTag;
      this.acceptTags = ["h1", "h2", "h3", "h4", "h5", "h6", "code", "a", "img", "ul", "ol", "li", "table", "tbody", "tr", "td", "th", "strong", "pre", "b"];
      this.inlineTags = ["a", "img", "table", "strong", "bold", "b"];
      this.blockTag = ["p", "br"];
      this.elementType = ["headline", "list"];
      this.inlines = {};
      this.inlineId = 1000;
      this.inlineReg = new RegExp("\{\{\{\{[0-9]{4,8}\}\}\}\}");
      this.inlineRegG = new RegExp("\{\{\{\{[0-9]{4,8}\}\}\}\}", "g");
      heading = "";
      fn = (function(_this) {
        return function(level, heading) {
          return _this["h" + level + "Flatten"] = function(tag) {
            return "\n" + heading + " " + _this.getChildrenTextStream(tag) + "\n";
          };
        };
      })(this);
      for (level = i = 1; i <= 6; level = ++i) {
        heading += "#";
        fn(level, heading);
      }
      this.flatText = this.toFlatten(this.normalize(this.htmlTag));
      this.result = this.resolveInlineResource(this.flatText);
    }

    HTMLTag2Flatten.prototype.createTagInlineText = function(tag) {
      var id;
      id = this.inlineId++;
      this.inlines[id] = {
        id: id,
        detail: tag
      };
      return "{{{{" + id + "}}}}";
    };

    HTMLTag2Flatten.prototype.mergeTextArray = function(children) {
      var child, currentText, i, len, result;
      result = [];
      currentText = null;
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        if (child.isText()) {
          if (currentText) {
            currentText.text += child.text;
          } else {
            currentText = child;
          }
        } else {
          if (currentText) {
            currentText = this.normalizeText(currentText);
            if (currentText.text.length !== 0) {
              result.push(currentText);
            }
            result.push(child);
            currentText = null;
          } else {
            result.push(child);
          }
        }
      }
      if (currentText) {
        result.push(currentText);
      }
      return result;
    };

    HTMLTag2Flatten.prototype.normalizeText = function(tag) {
      tag.text = tag.text.replace(/\s*\n\s*\n\s*/g, "\n\n").replace(/\n\n+/g, "\n\n");
      return tag;
    };

    HTMLTag2Flatten.prototype.getChildrenTextStream = function(tag, plain) {
      var child, i, j, len, len1, plainText, ref, ref1, ref2, ref3, text;
      if (plain == null) {
        plain = false;
      }
      if (!tag.isText) {
        return "";
      }
      if (tag.isText()) {
        return tag.text;
      }
      if (ref = tag.name, indexOf.call(this.inlineTags, ref) >= 0) {
        if (plain) {
          plainText = "";
          ref1 = tag.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            plainText += this.getChildrenTextStream(child, true);
          }
          return plainText;
        }
        return this.createTagInlineText(tag);
      }
      text = "";
      ref2 = tag.children;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        child = ref2[j];
        if (child.isText()) {
          text += child.text;
        } else if (ref3 = child.name, indexOf.call(this.inlineTags, ref3) >= 0) {
          if (plain) {
            return this.getChildrenTextStream(child, plain);
          }
          text += this.createTagInlineText(tag);
        } else {
          text += this.getChildrenTextStream(child, plain);
        }
      }
      return text;
    };

    HTMLTag2Flatten.prototype.normalize = function(tag) {
      var child, i, item, j, k, len, len1, len2, ref, ref1, ref2, ref3, ref4, result;
      result = [];
      if (!(tag.children instanceof Array)) {
        return tag;
      }
      if (ref = tag.name, indexOf.call(this.acceptTags, ref) < 0) {
        ref1 = tag.children;
        for (i = 0, len = ref1.length; i < len; i++) {
          item = ref1[i];
          child = this.normalize(item);
          if (child instanceof Array) {
            result.push.apply(result, child);
          } else {
            result.push(child);
          }
        }
        if (ref2 = tag.name, indexOf.call(this.blockTag, ref2) >= 0) {
          result.push(new HTMLTag("TEXT", "\n\n"));
        }
        return this.mergeTextArray(result);
      } else if (ref3 = tag.name, indexOf.call(this.acceptTags, ref3) >= 0) {
        ref4 = tag.children;
        for (j = 0, len1 = ref4.length; j < len1; j++) {
          item = ref4[j];
          child = this.normalize(item);
          if (child instanceof Array) {
            result.push.apply(result, child);
          } else {
            result.push(child);
          }
        }
        result = this.mergeTextArray(result);
        tag.children.length = 0;
        for (k = 0, len2 = result.length; k < len2; k++) {
          child = result[k];
          tag.addChild(child);
        }
        return tag;
      }
    };

    HTMLTag2Flatten.prototype.toFlatten = function(arr) {
      var child, flatter, i, len, text;
      if (arr instanceof HTMLTag) {
        arr = [arr];
      }
      text = "";
      for (i = 0, len = arr.length; i < len; i++) {
        child = arr[i];
        if (flatter = this[child.name + "Flatten"]) {
          text += flatter.call(this, child);
        } else {
          text += this.getChildrenTextStream(child);
        }
      }
      return text;
    };

    HTMLTag2Flatten.prototype.ulFlatten = function(tag) {
      return new UlFlatter(this, tag).text;
    };

    HTMLTag2Flatten.prototype.olFlatten = function(tag) {
      return new UlFlatter(this, tag).text;
    };

    HTMLTag2Flatten.prototype.codeFlatten = function(tag) {
      return "\n```\n" + (this.escapeChar(this.getChildrenTextStream(tag), "`")) + "\n```\n";
    };

    HTMLTag2Flatten.prototype.preFlatten = function(tag) {
      return "\n```\n" + (this.escapeChar(this.getChildrenTextStream(tag), "`")) + "\n```\n";
    };

    HTMLTag2Flatten.prototype.escapeChar = function(text, char, replacement) {
      return text.replace(new RegExp(char, "g"), replacement || ("\\" + char));
    };

    HTMLTag2Flatten.prototype.resolveInlineResource = function(text) {
      var code, l, left, match, result, rune, solver, tag;
      this.inlineReg.lastIndex = 0;
      left = text;
      result = [];
      while (match = left.match(this.inlineReg)) {
        result.push(left.slice(0, match.index));
        left = left.slice(match.index + match[0].length);
        code = match[0].slice(4).slice(0, -4);
        l = this.inlines[code];
        tag = l.detail;
        if (solver = this[tag.name + "InlineSolve"]) {
          rune = solver.call(this, tag);
          if (rune) {
            result.push(rune);
            continue;
          }
        }
        result.push(this.getChildrenTextStream(tag, true));
      }
      result.push(left);
      return this.mergeSolvedResult(result);
    };

    HTMLTag2Flatten.prototype.escapeMarkdownUrl = function(string) {
      var _map, result;
      if (string == null) {
        string = "";
      }
      _map = {
        "(": "\\(",
        ")": "\\)",
        "\\": "\\\\"
      };
      result = string.replace(/\(|\)|\\/g, function(match) {
        return _map[match] || match;
      });
      return result;
    };

    HTMLTag2Flatten.prototype.mergeSolvedResult = function(arr) {
      var i, item, len, results, text;
      results = [];
      text = null;
      for (i = 0, len = arr.length; i < len; i++) {
        item = arr[i];
        if (typeof item === "string") {
          if (text) {
            text += item;
          } else {
            text = item;
          }
        } else {
          if (text) {
            results.push(text);
            text = null;
          }
          results.push(item);
        }
      }
      if (text) {
        results.push(text);
      }
      return results;
    };

    HTMLTag2Flatten.prototype.tableInlineSolve = function(tag) {
      return new TableRuneParser(this, tag).rune;
    };

    HTMLTag2Flatten.prototype.imgInlineSolve = function(tag) {
      var ref;
      return "![](" + (this.escapeMarkdownUrl((ref = tag.props) != null ? ref.src : void 0)) + ")";
    };

    HTMLTag2Flatten.prototype.bInlineSolve = function(tag) {
      return "**" + (this.getChildrenTextStream(tag, true)) + "**";
    };

    HTMLTag2Flatten.prototype.boldInlineSolve = function(tag) {
      return "**" + (this.getChildrenTextStream(tag, true)) + "**";
    };

    HTMLTag2Flatten.prototype.strongInlineSolve = function(tag) {
      return "**" + (this.getChildrenTextStream(tag, true)) + "**";
    };

    HTMLTag2Flatten.prototype.aInlineSolve = function(tag) {
      var link, title;
      link = tag.props.href;
      title = this.getChildrenTextStream(tag, true);
      return {
        type: "LinkRune",
        link: link,
        title: title
      };
    };

    return HTMLTag2Flatten;

  })();

  UlFlatter = (function() {
    function UlFlatter(flatter1, tag1) {
      var normalizedTag;
      this.flatter = flatter1;
      this.tag = tag1;
      this.items = [];
      this.acceptTags = ["ul", "li", "ol"];
      this.inlineTags = ["a", "img", "table", "strong", "bold"];
      this.blockTag = [];
      this.indentStep = 4;
      normalizedTag = this.normalize(this.tag);
      this.text = this.flatten(normalizedTag) + "\n";
    }

    UlFlatter.prototype.normalize = function(tag) {
      var child, i, item, j, k, len, len1, len2, ref, ref1, ref2, ref3, ref4, ref5, ref6, result, t;
      result = [];
      if (!(tag.children instanceof Array)) {
        return tag;
      }
      if ((ref = tag.name, indexOf.call(this.acceptTags, ref) < 0) && (ref1 = tag.name, indexOf.call(this.inlineTags, ref1) < 0)) {
        ref2 = tag.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          item = ref2[i];
          child = this.normalize(item);
          if (child instanceof Array) {
            result.push.apply(result, child);
          } else {
            result.push(child);
          }
        }
        if (ref3 = tag.name, indexOf.call(this.blockTag, ref3) >= 0) {
          result.push(new HTMLTag("TEXT", "\n"));
        }
        return this.flatter.mergeTextArray(result);
      } else if (ref4 = tag.name, indexOf.call(this.acceptTags, ref4) >= 0) {
        ref5 = tag.children;
        for (j = 0, len1 = ref5.length; j < len1; j++) {
          item = ref5[j];
          child = this.normalize(item);
          if (child instanceof Array) {
            result.push.apply(result, child);
          } else {
            result.push(child);
          }
        }
        result = this.flatter.mergeTextArray(result);
        tag.children.length = 0;
        for (k = 0, len2 = result.length; k < len2; k++) {
          child = result[k];
          tag.addChild(child);
        }
        return tag;
      } else if (ref6 = tag.name, indexOf.call(this.inlineTags, ref6) >= 0) {
        t = new HTMLTag("TEXT", this.flatter.createTagInlineText(tag));
        return t;
      }
    };

    UlFlatter.prototype.flatten = function(tag, indent) {
      var child, i, index, j, k, len, len1, previousText, ref, ref1, ref2, ref3, ref4, space, t, tailing, text;
      if (indent == null) {
        indent = 0;
      }
      space = "";
      for (index = i = 0, ref = indent; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
        space += " ";
      }
      if (tag.name === "li") {
        text = space + " * ";
        tailing = true;
        ref1 = tag.children;
        for (j = 0, len = ref1.length; j < len; j++) {
          child = ref1[j];
          if (child.isText()) {
            text += this.singleline(child.text);
          } else if ((ref2 = child.name) === "ul" || ref2 === "ol") {
            tailing = false;
            text += "\n" + this.flatten(child, indent + this.indentStep);
          } else if (child.name === "li") {
            text += this.flatter.getChildrenTextStream(child);
          } else {
            Logger.error("Unexpected tag(" + tag.name + ")", tag);
            continue;
          }
        }
        return text + (tailing && "\n" || "");
      } else if ((ref3 = tag.name) === "ul" || ref3 === "ol") {
        text = "";
        previousText = false;
        tailing = true;
        ref4 = tag.children;
        for (k = 0, len1 = ref4.length; k < len1; k++) {
          child = ref4[k];
          if (child.isText()) {
            if (t = child.text.trim()) {
              previousText = true;
              text += t;
            } else {
              continue;
            }
          } else if (child.name === ["ul", "ol"]) {
            text += this.flatter.getChildrenTextStream(child);
          } else if (child.name === "li") {
            tailing = false;
            if (previousText) {
              previousText = false;
              text += "\n";
            }
            text += this.flatten(child, indent);
          }
        }
        return text + (tailing && "\n" || "");
      } else if (tag.isText()) {
        return tag.text;
      }
    };

    UlFlatter.prototype.singleline = function(text) {
      return text.replace(/\s*\n\s*/g, " ");
    };

    return UlFlatter;

  })();

  TableRuneParser = (function() {
    function TableRuneParser(flatter1, tag1) {
      var ref, ref1;
      this.flatter = flatter1;
      this.tag = tag1;
      this.rune = null;
      if (((ref = this.tag.children[0]) != null ? ref.name : void 0) === "tbody") {
        this.parseTableContent(this.tag.children[0]);
      } else if (((ref1 = this.tag.children[0]) != null ? ref1.name : void 0) === "tr") {
        this.parseTableContent(this.tag);
      } else {
        return this;
      }
    }

    TableRuneParser.prototype.normalize = function(tag) {
      var c, child, children, i, j, k, len, len1, len2, len3, m, ref, ref1, ref2, results;
      if ((ref = tag.name) === "th" || ref === "td") {
        return tag;
      }
      if (tag.name === "tbody" || tag.name === "table") {
        children = tag.children.slice();
        results = [];
        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          if ((ref1 = child.name) !== "tr") {
            continue;
          }
          if (c = this.normalize(child)) {
            results.push(c);
          }
        }
        tag.children.length = 0;
        for (j = 0, len1 = results.length; j < len1; j++) {
          child = results[j];
          tag.addChild(child);
        }
        return tag;
      }
      if (tag.name === "tr") {
        children = tag.children.slice();
        results = [];
        for (k = 0, len2 = children.length; k < len2; k++) {
          child = children[k];
          if ((ref2 = child.name) !== "td" && ref2 !== "th") {
            continue;
          }
          if (c = this.normalize(child)) {
            results.push(c);
          }
        }
        tag.children.length = 0;
        for (m = 0, len3 = results.length; m < len3; m++) {
          child = results[m];
          tag.addChild(child);
        }
        return tag;
      }
      return null;
    };

    TableRuneParser.prototype.parseTableContent = function(tag) {
      var cells, child, colCount, i, j, k, len, len1, len2, ref, ref1, ref2, ref3, ref4, row, rowCount;
      tag = this.normalize(tag);
      ref = tag.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        if (child.name !== "tr") {
          return null;
        }
      }
      colCount = tag.children.length;
      rowCount = (ref1 = tag.children[0]) != null ? (ref2 = ref1.children) != null ? ref2.length : void 0 : void 0;
      if (!colCount || !rowCount) {
        return null;
      }
      cells = [];
      ref3 = tag.children;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        row = ref3[j];
        ref4 = row.children;
        for (k = 0, len2 = ref4.length; k < len2; k++) {
          child = ref4[k];
          cells.push({
            type: "TableCell",
            contentString: this.flatter.getChildrenTextStream(child, "plain")
          });
        }
      }
      return this.rune = {
        type: "Table",
        col: colCount,
        row: rowCount,
        children: cells
      };
    };

    return TableRuneParser;

  })();

  COMConverter.HTMLTagParser = HTMLTagParser;

  COMConverter.HTMLTag2Flatten = HTMLTag2Flatten;

  module.exports = COMConverter;

}).call(this);

}
GlobalContext.setModule("vincent/facility/comConverter.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/commandManager.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Buffer, CommandManager,
    slice = [].slice;

  Buffer = require("./buffer");

  CommandManager = (function() {
    function CommandManager(editor) {
      this.editor = editor;
      this.entries = {};
    }

    CommandManager.prototype.register = function(cmd) {
      if (!cmd) {
        Logger.error("register command request a object like {name,description,handler}");
        return false;
      }
      if (!cmd.name) {
        Logger.error("invalid command name provided");
        return false;
      }
      if (!cmd.handler) {
        Logger.error("invalid command handler provided");
        return false;
      }
      if (this.entries[cmd.name]) {
        Logger.error("duplicate command name " + cmd.name);
        return false;
      }
      this.entries[cmd.name] = {
        name: cmd.name,
        description: cmd.description,
        invoke: cmd.handler,
        option: cmd.option || null,
        global: cmd.global || false
      };
      return true;
    };

    CommandManager.prototype.conduct = function() {
      var args, cmd, name, ref, result, transact;
      name = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      result = false;
      cmd = this.entries[name];
      if (!cmd) {
        return false;
      }
      if (cmd.context && (!this.editor.context || this.editor.context.isReadonly)) {
        return false;
      }
      transact = ((ref = this.editor.context) != null ? ref.transact.bind(this.editor.context) : void 0) || function(handler) {
        return handler();
      };
      transact((function(_this) {
        return function() {
          return result = cmd.invoke.apply(cmd, [_this.editor].concat(slice.call(args))) || false;
        };
      })(this));
      return result;
    };

    CommandManager.prototype.has = function(name) {
      return this.entries[name] && true || false;
    };

    CommandManager.prototype.getCommandDescription = function(name) {
      if (!this.has(name)) {
        return null;
      }
      return this.entries[name].description || ("<CMD " + name + "> has no description");
    };

    return CommandManager;

  })();

  module.exports = CommandManager;

}).call(this);

}
GlobalContext.setModule("vincent/facility/commandManager.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/contextManager.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMContext, ContextManager, EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = (require("../common/events")).EventEmitter;

  COMContext = require("../com/context");

  ContextManager = (function(superClass) {
    extend(ContextManager, superClass);

    function ContextManager(editor) {
      this.editor = editor;
      ContextManager.__super__.constructor.call(this);
      this.contexts = [];
    }

    ContextManager.prototype.setDefaultAttachmentManager = function(defaultAttachmentManager) {
      this.defaultAttachmentManager = defaultAttachmentManager;
    };

    ContextManager.prototype.create = function(option) {
      var context;
      if (option == null) {
        option = {};
      }
      context = new COMContext();
      context.editor = this.editor;
      this.contexts.push(context);
      context.attachments = option.attachments || this.defaultAttachmentManager;
      this.emit("context/create", context);
      return context;
    };

    ContextManager.prototype.destroy = function(context) {
      this.contexts = this.contexts.filter(function(item) {
        return item !== context;
      });
      return this.emit("context/destroy", context);
    };

    return ContextManager;

  })(EventEmitter);

  module.exports = ContextManager;

}).call(this);

}
GlobalContext.setModule("vincent/facility/contextManager.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/debugger.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Debugger;

  Debugger = (function() {
    function Debugger() {
      var i, len, prop, ref;
      this.saves = {};
      this.debugFunctions = ["time", "timeEnd", "debug", "log"];
      ref = this.debugFunctions;
      for (i = 0, len = ref.length; i < len; i++) {
        prop = ref[i];
        this.saves[prop] = console[prop];
      }
    }

    Debugger.prototype.enable = function(prop) {
      var results;
      if (prop && this.saves[prop]) {
        return console[prop] = this.saves[prop];
      } else {
        results = [];
        for (prop in this.saves) {
          results.push(console[prop] = this.saves[prop]);
        }
        return results;
      }
    };

    Debugger.prototype.disable = function(prop) {
      var results;
      if (prop && this.saves[prop]) {
        return console[prop] = function() {};
      } else {
        results = [];
        for (prop in this.debugFunctions) {
          results.push(console[prop] = function() {});
        }
        return results;
      }
    };

    return Debugger;

  })();

  module.exports = Debugger;

}).call(this);

}
GlobalContext.setModule("vincent/facility/debugger.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/documentFocus.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DocumentFocus, EventEmitter, FocusManager,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  EventEmitter = (require("../common/events")).EventEmitter;

  DocumentFocus = (function(superClass) {
    extend(DocumentFocus, superClass);

    function DocumentFocus(name) {
      this.name = name;
      DocumentFocus.__super__.constructor.call(this);
      this.usedBy = [];
    }

    DocumentFocus.prototype.isAvailable = function() {
      return this.usedBy.length === 0;
    };

    DocumentFocus.prototype.obtain = function(who) {
      var length;
      length = this.usedBy.length;
      if (indexOf.call(this.usedBy, who) < 0) {
        this.usedBy.push(who);
      }
      if (length === 0) {
        return this.emit("change");
      }
    };

    DocumentFocus.prototype.release = function(who) {
      var length;
      length = this.usedBy.length;
      this.usedBy = this.usedBy.filter(function(item) {
        return item !== who;
      });
      if (this.usedBy.length === 0 && length !== 0) {
        return this.emit("change");
      }
    };

    return DocumentFocus;

  })(EventEmitter);

  FocusManager = (function(superClass) {
    extend(FocusManager, superClass);

    function FocusManager(editor) {
      var focuses, i, item, len;
      this.editor = editor;
      this.inputFocus = new DocumentFocus("input");
      this.bufferFocus = new DocumentFocus("buffer");
      this.editorFocus = new DocumentFocus("editor");
      focuses = [this.inputFocus, this.bufferFocus, this.editorFocus];
      for (i = 0, len = focuses.length; i < len; i++) {
        item = focuses[i];
        item.listenBy(this, "change", (function(_this) {
          return function() {
            return _this.apply();
          };
        })(this));
      }
    }

    FocusManager.prototype.debug = function() {
      return Logger.debug("focus input:" + (this.inputFocus.isAvailable()) + ",buffer:" + (this.bufferFocus.isAvailable()) + ",editor:" + (this.editorFocus.isAvailable()) + ",");
    };

    FocusManager.prototype.apply = function() {
      if (!this.editorFocus.isAvailable()) {
        return this.disableAll();
      } else if (!this.bufferFocus.isAvailable()) {
        return this.toEditorLevel();
      } else if (!this.inputFocus.isAvailable()) {
        return this.toBufferLevel();
      } else {
        return this.allowAll();
      }
    };

    FocusManager.prototype.allowAll = function() {
      this.editor.inputMethod.obtainDocumentFocus();
      this.editor.inputMethod.activate();
      this.editor.domSelection.enable();
      this.editor.clipboard.enable();
      this.editor.activate();
      this.editor.hotkeys.enableAll();
      return this.level = "all";
    };

    FocusManager.prototype.toBufferLevel = function() {
      this.editor.inputMethod.releaseDocumentFocus();
      this.editor.inputMethod.activate();
      this.editor.domSelection.enable();
      this.editor.clipboard.enable();
      this.editor.activate();
      this.editor.hotkeys.enableAll();
      this.editor.hotkeys.disableInput();
      return this.level = "buffer";
    };

    FocusManager.prototype.toEditorLevel = function() {
      this.editor.inputMethod.releaseDocumentFocus();
      this.editor.inputMethod.activate();
      this.editor.clipboard.disable();
      this.editor.activate();
      this.editor.domSelection.disable();
      this.editor.hotkeys.enableAll();
      this.editor.hotkeys.disableInput();
      this.editor.hotkeys.disableBuffer();
      return this.level = "editor";
    };

    FocusManager.prototype.disableAll = function() {
      this.editor.inputMethod.deactivate();
      this.editor.clipboard.disable();
      this.editor.domSelection.disable();
      this.editor.hotkeys.disableInput();
      this.editor.hotkeys.disableBuffer();
      this.editor.hotkeys.disableEditor();
      return this.level = "none";
    };

    return FocusManager;

  })(EventEmitter);

  DocumentFocus.FocusManager = FocusManager;

  module.exports = DocumentFocus;

}).call(this);

}
GlobalContext.setModule("vincent/facility/documentFocus.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/dragManager.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = require("/component/dragManager");

}).call(this);

}
GlobalContext.setModule("vincent/facility/dragManager.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/dropManager.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DropManager,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DropManager = (function(superClass) {
    extend(DropManager, superClass);

    function DropManager(editor) {
      this.editor = editor;
      DropManager.__super__.constructor.call(this);
      this.initEvent(document.body);
    }

    DropManager.prototype.initEvent = function(target) {
      target.addEventListener("dragstart", (function(_this) {
        return function(e) {
          return e.preventDefault();
        };
      })(this));
      target.addEventListener("dragover", (function(_this) {
        return function(e) {
          var transfer;
          e.preventDefault();
          transfer = e.dataTransfer;
          if (!transfer) {
            return;
          }
          if (transfer.items.length > 0) {
            return _this.emit("files", e, transfer.items.length);
          }
        };
      })(this));
      target.addEventListener("dragleave", (function(_this) {
        return function(e) {
          return _this.emit("leave");
        };
      })(this));
      return target.addEventListener("drop", (function(_this) {
        return function(e) {
          var blob, i, item, len, ref, transfer, type;
          transfer = e.dataTransfer;
          if (!transfer) {
            return;
          }
          if (!e.defaultPrevented) {
            ref = transfer.items || {};
            for (i = 0, len = ref.length; i < len; i++) {
              item = ref[i];
              type = item.type || "";
              if (type.indexOf("image/") === 0) {
                blob = item.getAsFile();
                if (blob instanceof Blob) {
                  _this.emit("image", {
                    blob: blob
                  });
                  Logger.debug("image", blob, "at drop");
                }
              }
            }
          }
          e.preventDefault();
          e.stopImmediatePropagation();
          return _this.emit("leave");
        };
      })(this));
    };

    return DropManager;

  })(Leaf.EventEmitter);

  module.exports = DropManager;

}).call(this);

}
GlobalContext.setModule("vincent/facility/dropManager.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/highlighter.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var COMCursor, DOMBoundary, DOMTraverse, Debounce, Highlight, HighlightRect, HighlightSession, Highlighter, ReflowProcedure,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DOMBoundary = require("../common/boundary");

  Debounce = require("/component/debounce");

  COMCursor = require("../com/cursor");

  DOMTraverse = require("../common/traverse");

  Highlighter = (function() {
    function Highlighter(buffer) {
      this.buffer = buffer;
    }

    Highlighter.prototype.createSession = function() {
      return new HighlightSession(this.buffer);
    };

    return Highlighter;

  })();

  HighlightSession = (function() {
    function HighlightSession(buffer) {
      this.buffer = buffer;
      this.lights = [];
      this.reflowDebouncer = new Debounce({
        time: 10
      }, (function(_this) {
        return function() {
          return _this._reflow();
        };
      })(this));
      this.reflowProcedure = new ReflowProcedure(this);
    }

    HighlightSession.prototype.clear = function() {
      var i, len, light, ref;
      ref = this.lights;
      for (i = 0, len = ref.length; i < len; i++) {
        light = ref[i];
        light.clear();
        light.destroy();
      }
      this.lights.length = 0;
      return this.buffer.stopListenBy(this);
    };

    HighlightSession.prototype.addHighlight = function(start, end, option) {
      var light;
      light = new Highlight(this.buffer, start, end, option);
      this.lights.push(light);
      return light;
    };

    HighlightSession.prototype.applyAll = function(option) {
      var i, len, light, ref;
      if (option == null) {
        option = {};
      }
      if (!this.buffer.isActive) {
        return;
      }
      ref = this.lights;
      for (i = 0, len = ref.length; i < len; i++) {
        light = ref[i];
        light.apply();
      }
      this.buffer.stopListenBy(this);
      this.buffer.listenBy(this, "reflow", this.reflow.bind(this));
      this.buffer.listenBy(this, "resize", this.reflow.bind(this));
      if (this.buffer.isActive) {
        if (option.force) {
          return this.forceReflow();
        } else {
          return this.reflow();
        }
      }
    };

    HighlightSession.prototype.reflow = function() {
      if (!this.buffer.isActive) {
        return;
      }
      return this.reflowDebouncer.trigger();
    };

    HighlightSession.prototype.forceReflow = function() {
      return this._reflow();
    };

    HighlightSession.prototype._reflow = function() {
      if (!this.buffer.isActive) {
        return;
      }
      this.reflowProcedure.reset();
      return this.reflowProcedure.start();
    };

    return HighlightSession;

  })();

  Highlight = (function() {
    function Highlight(buffer, startAnchor, endAnchor, option1) {
      this.buffer = buffer;
      this.startAnchor = startAnchor;
      this.endAnchor = endAnchor;
      this.option = option1 != null ? option1 : {};
      this.rects = [];
      this.startCursor = this.buffer.context.createCursor();
      this.endCursor = this.buffer.context.createCursor();
      this.startCursor.pointAtAnchor(this.startAnchor);
      this.endCursor.pointAtAnchor(this.endAnchor);
      this.startCursor.name = "STName";
      this.endCursor.name = "ECName";
      this.startCursor.listenBy(this, "move", (function(_this) {
        return function() {
          return _this.buffer.nextRender(function() {
            return _this.delayReshow();
          });
        };
      })(this));
      this.endCursor.listenBy(this, "move", (function(_this) {
        return function() {
          return _this.buffer.nextRender(function() {
            return _this.delayReshow();
          });
        };
      })(this));
    }

    Highlight.prototype.delayReshow = function(time) {
      var trigger;
      return;
      trigger = Debounce.debounce({
        time: 0
      }, (function(_this) {
        return function() {
          if (_this.isDestroyed) {
            return;
          }
          if (!_this.isShow) {
            return false;
          }
          _this.apply();
          return _this.show();
        };
      })(this));
      trigger();
      return window.doTrigger = trigger;
    };

    Highlight.prototype.setOption = function(option) {
      var i, len, prop, rect, ref, results;
      if (option == null) {
        option = {};
      }
      for (prop in option) {
        this.option[prop] = option[prop];
      }
      ref = this.rects;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        rect = ref[i];
        results.push(rect.setOption(option));
      }
      return results;
    };

    Highlight.prototype.apply = function() {
      var TextType, area, clientRects, e, end, error, i, item, j, k, len, len1, len2, range, rect, rects, results, start, texts;
      this.clear();
      start = this.startCursor.getBoundary();
      end = this.endCursor.getBoundary();
      try {
        range = DOMBoundary.createRangeBetween(start, end);
      } catch (error) {
        e = error;
        Logger.error("fail to create highlight range", start, end);
        return;
      }
      TextType = 3;
      texts = [];
      this.rects.length = 0;
      DOMTraverse.traverseRange(range, function(node) {
        if (node.nodeType === TextType) {
          texts.push(node);
        }
        return false;
      });
      rects = [];
      for (i = 0, len = texts.length; i < len; i++) {
        item = texts[i];
        if (item === range.startContainer) {
          start = range.startOffset;
        } else {
          start = 0;
        }
        if (item === range.endContainer) {
          end = range.endOffset;
        } else {
          end = item.length;
        }
        if (start >= end) {
          continue;
        }
        area = document.createRange();
        area.setStart(item, start);
        area.setEnd(item, end);
        clientRects = area.getClientRects();
        for (j = 0, len1 = clientRects.length; j < len1; j++) {
          rect = clientRects[j];
          rects.push(rect);
        }
      }
      this.clear();
      this.buffer.viewPort.baseRect = null;
      results = [];
      for (k = 0, len2 = rects.length; k < len2; k++) {
        item = rects[k];
        if (item.left === item.right) {
          continue;
        }
        item = this.buffer.viewPort.resolveRectWithTop(item);
        rect = new HighlightRect(this.buffer, item, this.option);
        results.push(this.rects.push(rect));
      }
      return results;
    };

    Highlight.prototype.show = function() {
      var i, item, len, ref, results;
      this.isShow = true;
      ref = this.rects || [];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(item.show());
      }
      return results;
    };

    Highlight.prototype.hide = function() {
      var i, item, len, ref, results;
      this.isShow = false;
      ref = this.rects || [];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(item.remove());
      }
      return results;
    };

    Highlight.prototype.clear = function() {
      var i, len, rect, ref;
      ref = this.rects;
      for (i = 0, len = ref.length; i < len; i++) {
        rect = ref[i];
        rect.remove();
      }
      return this.rects.length = 0;
    };

    Highlight.prototype.destroy = function() {
      this.isDestroyed = true;
      this.startCursor.destroy();
      return this.endCursor.destroy();
    };

    Highlight.prototype.blink = function() {
      var i, len, rect, ref, results;
      ref = this.rects;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        rect = ref[i];
        results.push(rect.blink());
      }
      return results;
    };

    return Highlight;

  })();

  HighlightRect = (function() {
    function HighlightRect(buffer, rect, option1) {
      this.buffer = buffer;
      this.option = option1 != null ? option1 : {};
      this.el = document.createElement("div");
      this.el.style.zIndex = 10;
      this.rect = rect;
      this.top = rect.top;
      this.bottom = rect.bottom;
    }

    HighlightRect.prototype.setOption = function(option) {
      var prop;
      if (option == null) {
        option = {};
      }
      for (prop in option) {
        this.option[prop] = option[prop];
      }
      return this.render();
    };

    HighlightRect.prototype.blink = function() {
      this.el.classList.add("blink");
      return setTimeout((function(_this) {
        return function() {
          return _this.el.classList.remove("blink");
        };
      })(this), 200);
    };

    HighlightRect.prototype.render = function() {
      var rect;
      rect = this.rect;
      this.el.style.left = rect.left + "px";
      this.el.style.top = rect.top + "px";
      this.el.style.width = rect.width + "px";
      this.el.style.height = rect.height + "px";
      this.el.style.position = "absolute";
      if (this.option.customClass) {
        this.el.classList.add(this.option.customClass);
        return;
      }
      if (this.option.useBorder) {
        this.el.style.borderBottom = "2px solid " + this.option.color;
      } else {
        this.el.style.backgroundColor = this.option.color || "yellow";
      }
      return this.el.classList.add("com-global-highlight");
    };

    HighlightRect.prototype.show = function() {
      if (this.isShow) {
        return;
      }
      this.isShow = true;
      this.buffer.viewPort.el.appendChild(this.el);
      return this.render();
    };

    HighlightRect.prototype.remove = function() {
      if (!this.isShow) {
        return;
      }
      this.isShow = false;
      if (this.el.parentElement) {
        return this.el.parentElement.removeChild(this.el);
      }
    };

    return HighlightRect;

  })();

  ReflowProcedure = (function(superClass) {
    extend(ReflowProcedure, superClass);

    function ReflowProcedure(session) {
      this.session = session;
      ReflowProcedure.__super__.constructor.call(this);
    }

    ReflowProcedure.prototype.start = function() {
      return this.setState("init");
    };

    ReflowProcedure.prototype.atInit = function() {
      var bottom, height, top;
      top = this.session.buffer.UI.viewPort.scrollTop;
      height = this.session.buffer.UI.viewPort.offsetHeight;
      bottom = top + height;
      this.data.top = top;
      this.data.height = height;
      this.data.bottom = bottom;
      return this.setState("traverse");
    };

    ReflowProcedure.prototype.atTraverse = function(stale) {
      var begin, end, i, len, light, ref;
      ref = this.session.lights;
      for (i = 0, len = ref.length; i < len; i++) {
        light = ref[i];
        if (stale()) {
          return;
        }
        light.apply();
        begin = light.rects[0];
        end = light.rects[light.rects.length - 1];
        if (!begin || !end) {
          light.hide();
        } else if (begin.top >= this.data.bottom) {
          light.hide();
        } else if (end.bottom <= this.data.top) {
          light.hide();
        } else {
          light.show();
        }
      }
      return this.setState("done");
    };

    ReflowProcedure.prototype.atDone = function() {};

    return ReflowProcedure;

  })(Leaf.States);

  module.exports = Highlighter;

  Highlighter.HighlightSession = HighlightSession;

  Highlighter.Highlight = Highlight;

}).call(this);

}
GlobalContext.setModule("vincent/facility/highlighter.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/history.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {


}).call(this);

}
GlobalContext.setModule("vincent/facility/history.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/hotkeyManager.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Hotkey, HotkeyManager,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  HotkeyManager = (function() {
    function HotkeyManager(editor1) {
      this.editor = editor1;
      this.candidates = [];
      this.disables = [];
      this.isOSX = this.editor.platform.isMac();
      this.isLinux = this.editor.platform.isLinux();
      this.isWindows = this.editor.platform.isWindows();
      this.traces = null;
      HotkeyManager.isOSX = this.isOSX;
    }

    HotkeyManager.prototype.trace = function(name) {
      if (this.traces == null) {
        this.traces = [];
      }
      return this.traces.push(name);
    };

    HotkeyManager.prototype.debug = function() {
      return this.isDebug = true;
    };

    HotkeyManager.prototype.getHotkeyStatistics = function() {
      var can, i, len, ref, results;
      ref = this.candidates;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        can = ref[i];
        results.push({
          name: can.commandName || "(CODE)",
          keyString: can.keyString
        });
      }
      return results;
    };

    HotkeyManager.prototype.handleKeyEvent = function(event) {
      var i, item, ref, ref1, ref2;
      if (this.isDebug) {
        Logger.debug("Disables", this.disables);
      }
      ref = this.candidates;
      for (i = ref.length - 1; i >= 0; i += -1) {
        item = ref[i];
        if (item.type && (ref1 = item.type, indexOf.call(this.disables, ref1) >= 0)) {
          continue;
        }
        if (this.isDebug) {
          if (item.test(event)) {
            Logger.debug("test pass", item.commandName, item);
          } else {
            Logger.debug("no pass", item.commandName);
          }
        }
        if (this.traces && (ref2 = item.commandName, indexOf.call(this.traces, ref2) >= 0)) {
          Logger.debug("test", item.commandName);
          Logger.debug(event, item.keyString);
        }
        if (item.exec(event, this.editor)) {
          if (this.isDebug) {
            Logger.debug("exec finally", item.commandName, item);
          }
          if (typeof event.capture === "function") {
            event.capture();
          }
          return true;
        }
      }
      return false;
    };

    HotkeyManager.prototype.registerCommandHotkey = function() {
      var args, commandName, hk, keyString, match, prop, value;
      keyString = arguments[0], commandName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof keyString === "object") {
        match = false;
        for (prop in keyString) {
          value = keyString[prop];
          if (prop === "win") {
            if (this.isWindows) {
              match = true;
              this.registerCommandHotkey.apply(this, [value, commandName].concat(slice.call(args)));
            }
          } else if (prop === "osx") {
            if (this.isOSX) {
              match = true;
              this.registerCommandHotkey.apply(this, [value, commandName].concat(slice.call(args)));
            }
          } else if (prop === "linux") {
            if (this.isLinux) {
              match = true;
              this.registerCommandHotkey.apply(this, [value, commandName].concat(slice.call(args)));
            }
          } else if (prop === "default") {
            if (!match) {
              this.registerCommandHotkey.apply(this, [value, commandName].concat(slice.call(args)));
            }
          }
        }
        return;
      }
      hk = new Hotkey(keyString, {
        description: this.editor.commands.getCommandDescription(commandName),
        handler: this.editor.conduct.bind(this.editor, commandName),
        commandName: commandName,
        args: args
      });
      return this.register(hk);
    };

    HotkeyManager.prototype.getCommandHotkey = function(command) {
      var cand, cmd, hks, i, len, ref;
      cmd = command.toLowerCase();
      hks = [];
      ref = this.candidates;
      for (i = 0, len = ref.length; i < len; i++) {
        cand = ref[i];
        if (cand.commandName === cmd) {
          hks.push(cand);
        }
      }
      return hks;
    };

    HotkeyManager.prototype.registerHotkey = function(keyString, handler) {
      return this.register(new Hotkey(keyString, handler));
    };

    HotkeyManager.prototype.register = function(hotkey) {
      if (!hotkey.isValid) {
        Logger.error("will to register a invalid hotkey", hotkey);
      }
      return this.candidates.push(hotkey);
    };

    HotkeyManager.prototype.enableAll = function() {
      return this.disables = [];
    };

    HotkeyManager.prototype.disableInput = function() {
      return this.disables.push("input");
    };

    HotkeyManager.prototype.disableBuffer = function() {
      return this.disables.push("buffer");
    };

    HotkeyManager.prototype.disableEditor = function() {
      return this.disables.push("editor");
    };

    return HotkeyManager;

  })();

  Hotkey = (function() {
    var keyStringReg, modifierReg;

    Hotkey.normalize = function(keyString) {
      return keyString.replace(/\s/g, "").replace(/>/g, "> ");
    };

    keyStringReg = /^(input:|buffer:|editor:)?((<[^<>]+>\s*)*)([a-z0-9A-Z]+)(\s*@down)?(\s*@up)?$/;

    modifierReg = /<([^<]+)>/gi;

    function Hotkey(keyString, handler1) {
      var keyName, matches, modifiers, ref, ref1, ref2, ref3, result;
      if (keyString == null) {
        keyString = "";
      }
      this.handler = handler1;
      matches = keyString.match(keyStringReg);
      this.isValid = true;
      if (!matches) {
        Logger.error("invalid hotkey string " + keyString);
        this.isValid = false;
        return;
      }
      this.commandName = this.handler.commandName;
      this.type = ((ref = matches[1]) != null ? ref.replace(":", "") : void 0) || "buffer";
      if ((ref1 = this.type) !== "buffer" && ref1 !== "editor" && ref1 !== "input") {
        Logger.error("invalid hotkey type", this.type);
        this.isValid = false;
        return false;
      }
      modifiers = matches[2];
      modifierReg.lastIndex = 0;
      while (result = modifierReg.exec(modifiers)) {
        keyName = (ref2 = result[1]) != null ? (ref3 = ref2.trim()) != null ? ref3.toLowerCase() : void 0 : void 0;
        if (keyName === "ctrl") {
          this.ctrlKey = true;
        }
        if (keyName === "alt") {
          this.altKey = true;
        }
        if (keyName === "shift") {
          this.shiftKey = true;
        }
        if (keyName === "meta") {
          this.metaKey = true;
        }
        if (keyName === "mod") {
          this.modKey = true;
        }
        if (keyName === "command") {
          this.commandKey = true;
        }
      }
      this.keyName = matches[4];
      this.keyDown = matches[5] && true || false;
      this.keyUp = matches[6] && true || false;
      if (!this.keyDown && !this.keyUp) {
        this.keyDown = true;
      }
      this.keyString = Hotkey.normalize(keyString);
      this.description = this.handler.description || "unkown hotkey description";
    }

    Hotkey.prototype.testKeyString = function(string) {
      var hk, i, len, name, prop;
      hk = new Hotkey(string, {});
      prop = ["keyName", "ctrlKey", "altKey", "metaKey", "shiftKey", "modKey", "commandKey", "keyUp", "keyDown"];
      for (i = 0, len = prop.length; i < len; i++) {
        name = prop[i];
        if (hk[name] !== this[name]) {
          return false;
        }
      }
      return true;
    };

    Hotkey.prototype.test = function(event) {
      var result;
      if (typeof event === "string") {
        return this.testKeyString(event);
      }
      result = false;
      if (event.isKey(this.keyName) && (event.shiftKey ^ this.shiftKey) === 0 && (event.altKey ^ this.altKey) === 0 && (event.keyUp ^ this.keyUp) === 0 && (event.keyDown ^ this.keyDown) === 0 && event.isModMatch(this.ctrlKey, this.commandKey, this.modKey)) {
        result = true;
      }
      return result;
    };

    Hotkey.prototype.exec = function(event, editor) {
      var ref, result, transact;
      if (!this.test(event)) {
        return false;
      }
      result = null;
      transact = ((ref = editor.context) != null ? ref.transact.bind(editor.context) : void 0) || (function(_this) {
        return function(handler) {
          return handler();
        };
      })(this);
      transact((function(_this) {
        return function() {
          return result = _this.invoke(editor, event);
        };
      })(this));
      return result;
    };

    Hotkey.prototype.invoke = function(editor, event) {
      var args, ref;
      if (typeof this.handler === "function") {
        args = this.args || [];
        return this.handler.apply(this, [editor].concat(slice.call(args)));
      } else if (typeof this.handler.handler === "function") {
        args = this.handler.args || this.args || [];
        return (ref = this.handler).handler.apply(ref, args);
      }
    };

    Hotkey.prototype.prettifyHTML = function() {
      var arr, command, ctrl, key, ks, map, mod, opt, shift, value;
      command = "";
      if (HotkeyManager.isOSX) {
        mod = command;
        opt = "";
        shift = "";
        shift = "Shift";
        ctrl = "Ctrl";
      } else {
        mod = "Ctrl";
        opt = "Alt";
        shift = "Shift";
        ctrl = "Ctrl";
      }
      map = {
        "<mod>": mod,
        "<ctrl>": ctrl,
        "<alt>": opt,
        "<shift>": shift,
        "<command>": command,
        left: "",
        right: "",
        up: "",
        down: "",
        slash: "/",
        equal: "=",
        comma: ",",
        period: ".",
        escape: "esc"
      };
      ks = this.keyString;
      ks = ks.replace(/^.+:/, "");
      for (key in map) {
        value = map[key];
        ks = ks.replace(key, value);
      }
      arr = ks.split(/\s/).filter(function(item) {
        return item;
      });
      arr = arr.map(function(item) {
        return "<key>" + item[0].toUpperCase() + item.slice(1) + "</key>";
      });
      return arr.join("+");
    };

    Hotkey.prototype.prettify = function() {
      var arr, command, ctrl, key, ks, map, mod, opt, shift, value;
      command = "";
      if (HotkeyManager.isOSX) {
        mod = command;
        opt = "";
        shift = "";
        shift = "Shift";
        ctrl = "Ctrl";
      } else {
        mod = "Ctrl";
        opt = "Alt";
        shift = "Shift";
        ctrl = "Ctrl";
      }
      map = {
        "<mod>": mod,
        "<ctrl>": ctrl,
        "<alt>": opt,
        "<shift>": shift,
        "<command>": command,
        left: "",
        right: "",
        up: "",
        down: "",
        slash: "/",
        equal: "=",
        comma: ",",
        period: ".",
        escape: "esc"
      };
      ks = this.keyString;
      ks = ks.replace(/^.+:/, "");
      for (key in map) {
        value = map[key];
        ks = ks.replace(key, value);
      }
      arr = ks.split(/\s/).filter(function(item) {
        return item;
      });
      arr = arr.map(function(item) {
        return item[0].toUpperCase() + item.slice(1);
      });
      return arr.join(" + ");
    };

    Hotkey.prototype.toString = function() {
      return "[Hotkey " + this.keyString + "]";
    };

    return Hotkey;

  })();

  module.exports = HotkeyManager;

  HotkeyManager.Hotkey = Hotkey;

}).call(this);

}
GlobalContext.setModule("vincent/facility/hotkeyManager.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/htmlTag.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var HTMLTag;

  HTMLTag = (function() {
    function HTMLTag(name, children, props) {
      this.name = name;
      this.children = children;
      this.props = props;
      if (typeof this.children === "string") {
        this.name = "TEXT";
        this.text = this.children;
        this.children = null;
        this.props = null;
      } else {
        this.name = this.name.toLowerCase();
      }
    }

    HTMLTag.prototype.isText = function() {
      return this.name === "TEXT";
    };

    HTMLTag.prototype.addChild = function(child) {
      if (this.children instanceof Array) {
        this.children.push(child);
        return child.parent = this;
      } else {
        return Logger.error("Can add child to Text element");
      }
    };

    return HTMLTag;

  })();

  module.exports = HTMLTag;

}).call(this);

}
GlobalContext.setModule("vincent/facility/htmlTag.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/imeHint.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Highlighter, IMEHint;

  Highlighter = require("./highlighter");

  IMEHint = (function() {
    function IMEHint(buffer) {
      this.buffer = buffer;
      this.cursor = this.buffer.cursor;
      this.highlighter = new Highlighter(this.buffer);
      this.lightSession = this.highlighter.createSession();
    }

    IMEHint.prototype.clear = function() {
      return this.lightSession.clear();
    };

    IMEHint.prototype.hint = function(hint) {
      var end, ref, ref1, ref2, start;
      this.clear();
      ref2 = (ref = this.cursor) != null ? (ref1 = ref.anchor) != null ? ref1.getIMEAnchor(hint) : void 0 : void 0, start = ref2.start, end = ref2.end;
      if (start && end) {
        this.lightSession.addHighlight(start, end, {
          customClass: "ime-hint-highlight"
        });
        return this.lightSession.applyAll({
          force: true
        });
      }
    };

    return IMEHint;

  })();

  module.exports = IMEHint;

}).call(this);

}
GlobalContext.setModule("vincent/facility/imeHint.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/inputMethod.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var ActivableTrait, BackupInputMethod, BrowserDefaultKeyBehaviorPreventor, CompositeSession, ContentEditableHacker, Errors, EventEmitter, FocusableTrait, GeneralInputMethod, InputMethodChrome, InputMethodMaster, KeyEvent, KeyEventHandler, States, Trait,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  KeyEvent = require("../common/keyEvent");

  States = require("../common/states");

  Errors = require("../common/errors");

  EventEmitter = (require("../common/events")).EventEmitter;

  Trait = require("../com/helper/trait");

  InputMethodMaster = (function(superClass) {
    extend(InputMethodMaster, superClass);

    function InputMethodMaster(editor) {
      this.editor = editor;
      InputMethodMaster.__super__.constructor.call(this);
    }

    InputMethodMaster.prototype.init = function() {
      this.coreInputMethod = new GeneralInputMethod(this.editor, this);
      this.backupInputMethod = new BackupInputMethod(this.editor, this);
      this.inputMethods = [this.coreInputMethod, this.backupInputMethod];
      new BrowserDefaultKeyBehaviorPreventor();
      this.coreInputMethod.on("workingStateChange", (function(_this) {
        return function() {
          return _this.emit("workingStateChange");
        };
      })(this));
      this.backupInputMethod.on("interactive", (function(_this) {
        return function() {
          return _this.ensureInputStateWithoutVirtualKeyboard();
        };
      })(this));
      this.currentInputMethod = this.coreInputMethod;
      this.hasFocus = true;
      this.editor.bufferManager.listenBy(this, "focus", (function(_this) {
        return function(buffer) {
          return _this.attachTo(buffer);
        };
      })(this));
      return this.editor.caret.listenBy(this, "move", (function(_this) {
        return function() {
          return _this.updatePosition();
        };
      })(this));
    };

    InputMethodMaster.prototype.isMobileKeyboardShow = function() {
      var _, h, keyboardMinSize, sh, sw, w;
      if (!this.editor.platform.isMobile()) {
        return false;
      }
      h = document.body.clientHeight;
      w = document.body.clientWidth;
      sw = window.screen.width;
      sh = window.screen.height;
      keyboardMinSize = sh / 4;
      if ((h - w) * (sh - sw) < 0) {
        _ = sw;
        sw = sh;
        sh = _;
      }
      return sh - h > keyboardMinSize;
    };

    InputMethodMaster.prototype.attachTo = function(buffer) {
      var i, len, method, ref, ref1, ref2, ref3, ref4;
      if (!buffer.interactive) {
        return false;
      }
      if (buffer === this.buffer) {
        return;
      }
      if ((ref = this.buffer) != null) {
        ref.stopListenBy(this);
      }
      if ((ref1 = this.buffer) != null) {
        if ((ref2 = ref1.viewPort) != null) {
          ref2.stopListenBy(this);
        }
      }
      if ((ref3 = this.cursor) != null) {
        ref3.stopListenBy(this);
      }
      this.buffer = buffer;
      this.cursor = this.buffer.cursor;
      ref4 = this.inputMethods;
      for (i = 0, len = ref4.length; i < len; i++) {
        method = ref4[i];
        method.attachTo(buffer);
      }
      this.cursor.listenBy(this, "move", (function(_this) {
        return function() {
          return _this.editor.inputMethod.flush();
        };
      })(this));
      if (this.viewPort) {
        this.viewPort.stopListenBy(this);
      }
      this.viewPort = buffer.viewPort;
      this.viewPort.listenBy(this, "hasInteraction", (function(_this) {
        return function() {
          return _this.ensureInputStateWithoutVirtualKeyboard();
        };
      })(this));
      this.ensureInputStateWithoutVirtualKeyboard();
      this.attachRootElement(this.buffer.viewPort.rootElement);
      return this.buffer.viewPort.listenBy(this, "rootElement", (function(_this) {
        return function() {
          return _this.attachRootElement(_this.buffer.viewPort.rootElement);
        };
      })(this));
    };

    InputMethodMaster.prototype.attachRootElement = function(rootEl) {};

    InputMethodMaster.prototype.updatePosition = function() {
      var bl, fix, ref;
      bl = this.editor.caret.node.getBoundingClientRect();
      fix = document.body.getBoundingClientRect();
      return (ref = this.currentInputMethod) != null ? ref.updatePosition((bl.right + bl.left - fix.left * 2) / 2, bl.bottom - fix.top + 2, fix.bottom, fix.right) : void 0;
    };

    InputMethodMaster.prototype.releaseDocumentFocus = function() {
      if (!this.hasDocumentFocus) {
        return;
      }
      this.hasDocumentFocus = false;
      this.ensureInputStateWithoutVirtualKeyboard();
      return this.emit("workingStateChange");
    };

    InputMethodMaster.prototype.obtainDocumentFocus = function() {
      if (this.hasDocumentFocus) {
        return;
      }
      this.hasDocumentFocus = true;
      this.ensureInputStateWithoutVirtualKeyboard();
      return this.emit("workingStateChange");
    };

    InputMethodMaster.prototype.activate = function() {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      this.ensureInputStateWithoutVirtualKeyboard();
      return this.emit("workingStateChange");
    };

    InputMethodMaster.prototype.deactivate = function() {
      if (!this.isActive) {
        return;
      }
      this.isActive = false;
      this.ensureInputStateWithoutVirtualKeyboard();
      return this.emit("workingStateChange");
    };

    InputMethodMaster.prototype.flush = function() {
      var ref;
      return (ref = this.currentInputMethod) != null ? typeof ref.flush === "function" ? ref.flush() : void 0 : void 0;
    };

    InputMethodMaster.prototype.blur = function() {
      var ref;
      return (ref = this.currentInputMethod) != null ? typeof ref.blur === "function" ? ref.blur() : void 0 : void 0;
    };

    InputMethodMaster.prototype.focus = function() {
      var ref;
      return (ref = this.currentInputMethod) != null ? typeof ref.focus === "function" ? ref.focus() : void 0 : void 0;
    };

    InputMethodMaster.prototype.showVirtualKeyboard = function() {
      if (!this.editor.platform.isVirtualKeyboard()) {
        return;
      }
      this.activate();
      return this.applyState();
    };

    InputMethodMaster.prototype.hideVirtualKeyboard = function() {
      if (!this.editor.platform.isVirtualKeyboard()) {
        return;
      }
      this.deactivate();
      return this.applyState();
    };

    InputMethodMaster.prototype.ensureInputStateWithoutVirtualKeyboard = function() {
      if (this.editor.platform.isVirtualKeyboard()) {
        return;
      }
      this.updatePosition();
      return this.applyState();
    };

    InputMethodMaster.prototype.applyState = function() {
      var i, im, j, len, len1, ref, ref1, results;
      if (this.isActive) {
        if (this.hasDocumentFocus) {
          this.currentInputMethod = this.coreInputMethod;
        } else {
          this.currentInputMethod = this.backupInputMethod;
        }
        ref = this.inputMethods;
        for (i = 0, len = ref.length; i < len; i++) {
          im = ref[i];
          if (im !== this.currentInputMethod) {
            if (im.isActive) {
              im.deactivate();
            }
            im.ensureFocusState();
          }
        }
        if (!this.currentInputMethod.isActive) {
          this.currentInputMethod.activate();
        }
        this.currentInputMethod.ensureFocusState();
        return this.listenTo(this.currentInputMethod);
      } else {
        ref1 = this.inputMethods;
        results = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          im = ref1[j];
          im.deactivate();
          results.push(im.ensureFocusState());
        }
        return results;
      }
    };

    InputMethodMaster.prototype.listenTo = function(item) {
      if (this.lastListenTarget) {
        this.lastListenTarget.stopListenBy(this);
      }
      item.listenBy(this, "input", (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.emit.apply(_this, ["input"].concat(slice.call(args)));
        };
      })(this));
      item.listenBy(this, "key", (function(_this) {
        return function(key) {
          return _this.emit("key", key);
        };
      })(this));
      item.listenBy(this, "image", (function(_this) {
        return function(image) {
          return _this.emit("image", image);
        };
      })(this));
      return this.lastListenTarget = item;
    };

    return InputMethodMaster;

  })(EventEmitter);

  BackupInputMethod = (function(superClass) {
    extend(BackupInputMethod, superClass);

    function BackupInputMethod(context, master) {
      this.context = context;
      this.master = master;
      BackupInputMethod.__super__.constructor.call(this);
      this.canWrite = true;
      window.addEventListener("keydown", (function(_this) {
        return function(e) {
          var ke;
          _this.emit("interactive");
          if (!_this.isActive) {
            return;
          }
          if (!_this.hasFocus) {
            return;
          }
          ke = new KeyEvent(e);
          return _this.emit("key", ke);
        };
      })(this), true);
      window.addEventListener("keyup", (function(_this) {
        return function(e) {
          var ke;
          if (!_this.isActive) {
            return;
          }
          if (!_this.hasFocus) {
            return;
          }
          ke = new KeyEvent(e);
          return _this.emit("key", ke);
        };
      })(this), true);
      this.hasFocus = true;
    }

    BackupInputMethod.prototype.ensureFocusState = function() {
      return this.hasFocus = this.isActive;
    };

    BackupInputMethod.prototype.updatePosition = function(x, y) {
      return true;
    };

    BackupInputMethod.prototype.activate = function() {
      this.isActive = true;
      return this.hasFocus = true;
    };

    BackupInputMethod.prototype.deactivate = function() {
      this.isActive = false;
      return this.hasFocus = false;
    };

    BackupInputMethod.prototype.attachTo = function() {};

    return BackupInputMethod;

  })(Leaf.EventEmitter);

  InputMethodChrome = (function(superClass) {
    extend(InputMethodChrome, superClass);

    InputMethodChrome.prototype.attachTo = function(buffer) {
      var ref;
      this.buffer = buffer;
      if ((ref = this.cursor) != null) {
        ref.stopListenBy(this);
      }
      this.cursor = this.buffer.cursor;
      return this.cursor.listenBy(this, "move", (function(_this) {
        return function() {
          return _this.flush();
        };
      })(this));
    };

    function InputMethodChrome(editor, master) {
      this.editor = editor;
      this.master = master;
      InputMethodChrome.__super__.constructor.call(this);
      this.input = document.createElement("textarea");
      this.input$ = $(this.input);
      this.input.classList.add("input-method");
      this.input.addEventListener("keydown", this.onkeydown.bind(this), true);
      this.input.addEventListener("keyup", this.onkeyup.bind(this), true);
      this.input.addEventListener("compositionstart", this.oncompositionstart.bind(this));
      this.input.addEventListener("compositionupdate", this.oncompositionupdate.bind(this));
      this.input.addEventListener("compositionend", this.oncompositionend.bind(this));
      this.checkResize = this.checkResize.bind(this);
      this.input.addEventListener("focus", (function(_this) {
        return function() {
          _this._canWrite = true;
          return _this.emit("workingStateChange");
        };
      })(this));
      this.input.addEventListener("blur", (function(_this) {
        return function() {
          _this._canWrite = false;
          return _this.emit("workingStateChange");
        };
      })(this));
      this.__defineGetter__("canWrite", (function(_this) {
        return function() {
          return _this._canWrite && document.activeElement === _this.input;
        };
      })(this));
      this.input.raws = 1;
      this.__defineGetter__("shouldUseRealHolder", (function(_this) {
        return function() {
          if (_this.editor.platform.isMobile()) {
            return true;
          }
          return false;
        };
      })(this));
      document.body.appendChild(this.input);
      this.data.keys = {};
    }

    InputMethodChrome.prototype.delayCheck = function() {
      clearTimeout(this.checkTimer);
      return this.checkTimer = setTimeout((function(_this) {
        return function() {
          return _this.check();
        };
      })(this), 0);
    };

    InputMethodChrome.prototype.updatePosition = function(x, y, maxBottom, maxRight) {
      var args, change, css, i, index, item, len;
      args = [x, y, maxBottom, maxRight];
      change = false;
      if (this.positionCache) {
        for (index = i = 0, len = args.length; i < len; index = ++i) {
          item = args[index];
          if (item === this.positionCache[index]) {
            continue;
          } else {
            change = true;
            break;
          }
        }
        if (!change) {
          return false;
        }
      }
      this.positionCache = args;
      if (x < 0) {
        x = 0;
      }
      if (y < 0) {
        y = 0;
      }
      css = {};
      if (maxBottom && maxBottom < y) {
        css.bottom = 0;
      } else {
        css.top = y;
      }
      if (maxRight && maxRight < x) {
        css.right = 0;
      } else {
        css.left = x;
      }
      if (this.editor.platform.isMobile() && !this.data.isComposing) {
        css.left = 0;
        css.right = "auto";
        css.bottom = 10;
      }
      if (this.editor.platform.isMobile() && false) {
        css.left = "auto";
        css.right = "-30px";
        css.bottom = "0";
        css.top = "auto";
        css.width = "100%";
        return this.input$.css(css);
      } else {
        css.position = "absolute";
        return this.input$.css(css);
      }
    };

    InputMethodChrome.prototype.reset = function() {
      InputMethodChrome.__super__.reset.call(this);
      this.lastHolder = " ";
      this.input.value = this.lastHolder;
      return this.data.keys = {};
    };

    InputMethodChrome.prototype.activate = function() {
      if (this.isActive) {
        return;
      }
      this.focus();
      this.reset();
      this.setState("wait");
      return this.isActive = true;
    };

    InputMethodChrome.prototype.deactivate = function() {
      if (!this.isActive) {
        return;
      }
      this.blur();
      if (this.editor.platform.isMobile()) {
        window.removeEventListener("resize", this.checkResize);
      }
      return this.isActive = false;
    };

    InputMethodChrome.prototype.ensureFocusState = function(option) {
      if (option == null) {
        option = {};
      }
      this.data.keys = {};
      if (this.isActive && document.activeElement !== this.input && (option.forceFocus || !this.editor.platform.isMobile())) {
        return this.focus();
      } else if (!this.isActive && document.activeElement === this.input) {
        return this.blur();
      }
    };

    InputMethodChrome.prototype.focus = function() {
      if (this.editor.platform.isMobile()) {
        this.input.blur();
      }
      return this.input.focus();
    };

    InputMethodChrome.prototype.blur = function() {
      return this.input.blur();
    };

    InputMethodChrome.prototype.flush = function() {
      var contents, cursor, period, period2, period3, period4, value;
      value = this.input.value;
      if (this.holder == null) {
        this.holder = " ";
      }
      if (this.shouldUseRealHolder && this.cursor) {
        cursor = this.cursor;
        if (cursor && cursor.version !== this.cursorVersion) {
          contents = cursor != null ? typeof cursor.getSurroundingText === "function" ? cursor.getSurroundingText(15) : void 0 : void 0;
          period = contents.before.lastIndexOf(".");
          period2 = contents.before.lastIndexOf("?");
          period3 = contents.before.lastIndexOf("!");
          period4 = contents.before.lastIndexOf("\n");
          period = Math.max(period, period2, period3, period4);
          if (period >= 0) {
            contents.before = contents.before.slice(period + 1);
          }
          contents.before = contents.before.replace(/\n/g, " ");
          if (contents.before.length === 0) {
            contents.before = " ";
          }
          this.holder = contents.before;
          this.cursorVersion = cursor.version;
        }
      } else {
        this.holder = " ";
      }
      if (value !== this.holder) {
        this.input.value = this.holder;
      }
      if (value !== this.lastHolder && (value === this.lastHolder.slice(0, -1) || (value.length === 0))) {
        this.emit("key", new KeyEvent({
          which: 8
        }));
      } else if (value !== this.lastHolder) {
        value = value.slice(this.lastHolder.length);
        if (value && value.length > 0) {
          this.emit("input", value);
        }
      }
      return this.lastHolder = this.holder;
    };

    InputMethodChrome.prototype.check = function() {
      var Key, event, keys, prop, results;
      if (!this.isActive) {
        return;
      }
      Key = Leaf.Key;
      if (this.state !== "composition" && (this.input.value.length > 0 || this.editor.platform.isMobile())) {
        this.data.canFlush = true;
      }
      if (this.data.canFlush) {
        this.data.canFlush = false;
        this.flush();
      }
      keys = this.data.keys;
      results = [];
      for (prop in keys || {}) {
        event = keys != null ? keys[prop] : void 0;
        if (event && !event.defaultPrevented) {
          if (keys != null) {
            delete keys[prop];
          }
          results.push(this.emit("key", new KeyEvent(event)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    InputMethodChrome.prototype.onkeydown = function(e) {
      this.delayCheck();
      if (this.isWaitingFor("input")) {
        return this.give("input", {
          type: "keyboard",
          event: e
        });
      }
    };

    InputMethodChrome.prototype.onkeyup = function(e) {
      this.delayCheck();
      if (this.isWaitingFor("input")) {
        return this.give("input", {
          type: "keyboard",
          event: e
        });
      }
    };

    InputMethodChrome.prototype.oncompositionstart = function(e) {
      if (this.isWaitingFor("input")) {
        return this.give("input", {
          type: "ime",
          event: e,
          action: "start"
        });
      }
    };

    InputMethodChrome.prototype.oncompositionupdate = function(e) {
      this.delayCheck();
      if (this.isWaitingFor("input")) {
        return this.give("input", {
          type: "ime",
          event: e,
          action: "update"
        });
      }
    };

    InputMethodChrome.prototype.oncompositionend = function(e) {
      this.delayCheck();
      if (this.isWaitingFor("input")) {
        return this.give("input", {
          type: "ime",
          event: e,
          action: "end"
        });
      }
    };

    InputMethodChrome.prototype.onpaste = function(e) {
      var blob, cdata, i, item, len, ref, results, type;
      cdata = e.clipboardData;
      ref = e.clipboardData.items || {};
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        type = item.type || "";
        if (type.indexOf("image/") === 0) {
          blob = item.getAsFile();
          if (blob instanceof Blob) {
            this.emit("image", {
              blob: blob
            });
            e.preventDefault();
            results.push(e.stopImmediatePropagation());
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    InputMethodChrome.prototype.handleKeyboard = function(e) {
      if (e.type === "keyup") {
        this.data.canFlush = true;
      } else if (e.type === "keydown") {
        this.data.canFlush = true;
      }
      this.data.keys[e.which] = e;
      return this.check();
    };

    InputMethodChrome.prototype.atWait = function(sole) {
      return this.waitFor("input", (function(_this) {
        return function(input) {
          if (input.type === "keyboard") {
            _this.handleKeyboard(input.event);
            if (_this.stale(sole)) {
              return;
            }
            _this.setState("wait");
            return;
          }
          if (input.type === "ime" && input.action === "start") {
            _this.setState("composition");
            return;
          }
          _this.error(new Errors.UnexpectedInput("unexpected input at wait", {
            input: info
          }));
        };
      })(this));
    };

    InputMethodChrome.prototype.atPanic = function() {
      return Logger.error(this.panicState, this.panicError);
    };

    InputMethodChrome.prototype.atComposition = function() {
      this.input.classList.add("compose");
      this.data.isComposing = true;
      this.data.canFlush = false;
      return this.waitFor("input", (function(_this) {
        return function(input) {
          if (input.type !== "ime") {
            _this.setState("composition");
            return;
          }
          if (input.action === "update") {
            _this.setState("composition");
            return;
          }
          if (input.action === "end") {
            _this.data.canFlush = true;
            _this.data.isComposing = false;
            _this.input.classList.remove("compose");
            _this.setState("wait");
            return;
          }
          return _this.setState("composition");
        };
      })(this));
    };

    return InputMethodChrome;

  })(States);

  CompositeSession = (function() {
    function CompositeSession(fullText, compositePart) {
      this.fullText = fullText;
      this.compositePart = compositePart;
    }

    CompositeSession.prototype.isValid = function() {
      var ref;
      return ((ref = this.fullText) != null ? typeof ref.slice === "function" ? ref.slice(-this.compositePart.length) : void 0 : void 0) === this.compositePart;
    };

    return CompositeSession;

  })();

  GeneralInputMethod = (function(superClass) {
    extend(GeneralInputMethod, superClass);

    function GeneralInputMethod(editor, master) {
      var Key;
      this.editor = editor;
      this.master = master;
      GeneralInputMethod.__super__.constructor.call(this);
      new FocusableTrait(this);
      new ActivableTrait(this);
      new KeyEventHandler(this);
      this.input = document.createElement("textarea");
      this.input$ = $(this.input);
      this.input.classList.add("general-input-method");
      this.input.addEventListener("keydown", this.onkeydown.bind(this), true);
      this.input.addEventListener("keyup", this.onkeyup.bind(this), true);
      this.input.addEventListener("input", this.oninput.bind(this));
      this.input.addEventListener("compositionstart", this.oncompositionstart.bind(this));
      this.input.addEventListener("compositionupdate", this.oncompositionupdate.bind(this));
      if (this.editor.platform.isMobile()) {
        this.requestIMEComplete = true;
      }
      this.inputHolder = "  ";
      this.input.addEventListener("compositionend", this.oncompositionend.bind(this));
      this.sessionId = 0;
      document.body.appendChild(this.input);
      this.checkResize = this.checkResize.bind(this);
      window.addEventListener("resize", this.checkResize);
      this.input.addEventListener("blur", (function(_this) {
        return function() {
          return _this.reform();
        };
      })(this));
      Key = Leaf.Key;
      this.charKeys = {
        " ": {
          which: Key.space,
          shiftKey: true
        },
        "!": {
          which: Key["1"],
          shiftKey: true
        },
        "@": {
          which: Key["2"],
          shiftKey: true
        },
        "#": {
          which: Key["3"],
          shiftKey: true
        },
        "$": {
          which: Key["4"],
          shiftKey: true
        },
        "%": {
          which: Key["5"],
          shiftKey: true
        },
        "^": {
          which: Key["6"],
          shiftKey: true
        },
        "&": {
          which: Key["7"],
          shiftKey: true
        },
        "*": {
          which: Key["8"],
          shiftKey: true
        },
        "(": {
          which: Key["9"],
          shiftKey: true
        },
        ")": {
          which: Key["0"],
          shiftKey: true
        },
        "_": {
          which: Key.dash,
          shiftKey: true
        },
        "+": {
          which: Key.equal,
          shiftKey: true
        },
        "~": {
          which: Key.graveAccent,
          shiftKey: true
        },
        "`": {
          which: Key.graveAccent
        }
      };
      this.forceDisplay = false;
    }

    GeneralInputMethod.prototype.checkResize = function() {
      clearTimeout(this.resizeTimer);
      this.resizeTimer = setTimeout((function(_this) {
        return function() {
          var height, keyboardHeightMin;
          height = $(window).height();
          keyboardHeightMin = height / 4;
          if (Math.abs(height - _this.editor.initHeight) < keyboardHeightMin) {
            return window.document.activeElement.blur();
          }
        };
      })(this), 500);
      return setTimeout((function(_this) {
        return function() {
          var height, keyboardHeightMin;
          height = $(window).height();
          keyboardHeightMin = 150;
          if (!Math.abs(height - _this.editorn.initHeight) < keyboardHeightMin) {
            return _this.editor.caret.scrollViewPortToComfortable();
          }
        };
      })(this), 10);
    };

    GeneralInputMethod.prototype.atPanic = function() {
      return Logger.error(this.panicError, this.panicState);
    };

    GeneralInputMethod.prototype.sync = function(input) {
      var charKey, content, e, error, error1, holderLength, ke, prevContent, ref, ref1, ref2, ref3, ref4, ref5, suggestedContent, withEnter;
      if (this.input.value === this.data.base.slice(0, -1)) {
        try {
          this.emit("key", new KeyEvent({
            which: 8
          }));
          this.reform();
        } catch (error) {
          e = error;
          Logger.error(e);
        }
        return false;
      } else if (this.input.value === this.data.base.slice(0, this.input.value.length) && this.data.base.length - this.inputHolder.length >= ((ref = this.input.value) != null ? ref.length : void 0)) {
        try {
          this.editor.conduct("delete-word");
          this.reform();
        } catch (error1) {
          e = error1;
          Logger.error(e);
        }
        return false;
      }
      holderLength = this.inputHolder.length;
      withEnter = false;
      charKey = null;
      prevContent = this.data.previousContent || this.data.base.slice(this.inputHolder.length);
      if (((ref1 = this.input.value) != null ? ref1.slice(-1) : void 0) === "\n") {
        ke = new KeyEvent({
          which: 13
        });
        this.emit("key", ke);
        if (ke.defaultPrevented) {
          content = this.input.value.slice(holderLength, -1);
          this.input.value = this.input.value.slice(0, holderLength);
          withEnter = true;
        } else {
          content = this.input.value.slice(holderLength);
        }
      } else if (charKey = this.charKeys[(ref2 = this.input.value) != null ? ref2.slice(-1) : void 0]) {
        ke = new KeyEvent(charKey);
        this.emit("key", ke);
        if (ke.defaultPrevented) {
          content = this.input.value.slice(holderLength, -1);
          this.input.value = this.input.value.slice(0, holderLength);
        } else {
          content = this.input.value.slice(holderLength);
        }
      } else {
        content = this.input.value.slice(holderLength);
      }
      if (prevContent === content) {
        return true;
      }
      this.isReplacingIME = true;
      if (!this.editor.buffer.selection.isCollapsed() && this.editor.buffer.selection.isActive) {
        this.editor.buffer.context.transact((function(_this) {
          return function() {
            _this.editor.buffer.selection.removeSelectedNodes();
            _this.editor.buffer.selection.collapseToBegin();
            return _this.editor.buffer.selection.deactivate();
          };
        })(this));
      }
      this.editor.userIsWriting = true;
      this.cursor.IMEReplace(prevContent, content);
      this.editor.userIsWriting = false;
      this.data.previousContent = content;
      this.isReplacingIME = false;
      this.data.previousContent = content;
      if (((ref3 = this.input.value) != null ? ref3.indexOf("\n") : void 0) > 0 || withEnter) {
        this.reform();
        return false;
      }
      if (this.data.suggestedContent) {
        suggestedContent = this.data.suggestedContent;
        if ((ref4 = this.buffer) != null) {
          ref4.nextRender((function(_this) {
            return function() {
              var ref5;
              if (suggestedContent === _this.data.suggestedContent) {
                return (ref5 = _this.buffer) != null ? ref5.imeHint.hint(_this.data.suggestedContent) : void 0;
              }
            };
          })(this));
        }
      } else {
        if ((ref5 = this.buffer) != null) {
          ref5.imeHint.clear();
        }
      }
      return true;
    };

    GeneralInputMethod.prototype.attachTo = function(buffer) {
      var ref, ref1, ref2, ref3;
      if (buffer === this.buffer) {
        return;
      }
      if ((ref = this.buffer) != null) {
        ref.stopListenBy(this);
      }
      if ((ref1 = this.buffer) != null) {
        if ((ref2 = ref1.imeHint) != null) {
          ref2.clear();
        }
      }
      this.buffer = buffer;
      if ((ref3 = this.cursor) != null) {
        ref3.stopListenBy(this);
      }
      this.cursor = this.buffer.cursor;
      this.cursor.listenBy(this, "move", (function(_this) {
        return function() {
          clearTimeout(_this._reformTimer);
          if (!_this.isReplacingIME) {
            return _this._reformTimer = setTimeout(function() {
              if (!_this.isReplacingIME && !_this.master.isMobileKeyboardShow()) {
                return _this.reform();
              }
            }, 5);
          }
        };
      })(this));
      return this.reform();
    };

    GeneralInputMethod.prototype.reform = function() {
      var ref, ref1;
      this.reset();
      if ((ref = this.buffer) != null) {
        if ((ref1 = ref.context) != null) {
          ref1.history.enableCheckPoint();
        }
      }
      return this.setState("init");
    };

    GeneralInputMethod.prototype.getComposingText = function() {
      return GeneralInputMethod.__super__.getComposingText.call(this);
    };

    GeneralInputMethod.prototype.updatePosition = function(x, y, maxBottom, maxRight) {
      var args, change, css, i, index, item, len, minLeft, xFix, yFix;
      minLeft = 0;
      if (this.editor.platform.isMobile() && !this.forceDisplay) {
        x = -500;
        minLeft = -999999;
      }
      args = [x, y, maxBottom, maxRight];
      change = false;
      xFix = 0;
      yFix = 0;
      if (this.editor.platform.isMobile()) {
        yFix = -25;
      }
      if (this.positionCache) {
        for (index = i = 0, len = args.length; i < len; index = ++i) {
          item = args[index];
          if (item === this.positionCache[index]) {
            continue;
          } else {
            change = true;
            break;
          }
        }
        if (!change) {
          return false;
        }
      }
      this.positionCache = args;
      css = {
        top: y + yFix,
        left: x + xFix
      };
      if (maxBottom && maxBottom < y) {
        delete css.top;
        css.bottom = 0;
      } else {
        css.top = y;
      }
      css.position = "absolute";
      return this.input$.css(css);
    };

    GeneralInputMethod.prototype.reset = function() {
      return GeneralInputMethod.__super__.reset.call(this);
    };

    GeneralInputMethod.prototype.onkeydown = function(e) {
      return this.feed("input", {
        type: "keyboard",
        event: e
      });
    };

    GeneralInputMethod.prototype.onkeyup = function(e) {
      return this.feed("input", {
        type: "keyboard",
        event: e
      });
    };

    GeneralInputMethod.prototype.oninput = function(e) {
      return this.feed("input", {
        type: "input",
        event: e
      });
    };

    GeneralInputMethod.prototype.oncompositionstart = function(e) {
      return this.feed("input", {
        type: "ime",
        event: e,
        action: "start"
      });
    };

    GeneralInputMethod.prototype.oncompositionupdate = function(e) {
      return this.feed("input", {
        type: "ime",
        event: e,
        action: "update"
      });
    };

    GeneralInputMethod.prototype.oncompositionend = function(e) {
      return this.feed("input", {
        type: "ime",
        event: e,
        action: "end"
      });
    };

    GeneralInputMethod.prototype.onpaste = function(e) {
      var blob, cdata, i, item, len, ref, results, type;
      this.reform();
      cdata = e.clipboardData;
      ref = e.clipboardData.items || {};
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        type = item.type || "";
        if (type.indexOf("image/") === 0) {
          blob = item.getAsFile();
          if (blob instanceof Blob) {
            this.emit("image", {
              blob: blob
            });
            e.preventDefault();
            results.push(e.stopImmediatePropagation());
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    GeneralInputMethod.prototype.atPanic = function() {
      return Logger.error(this.panicState, this.panicError);
    };

    GeneralInputMethod.prototype.atHang = function() {};

    GeneralInputMethod.prototype.atInit = function() {
      var ref, ref1, word;
      if (!this.cursor) {
        this.setState("hang");
        return;
      }
      if (this.requestIMEComplete) {
        word = ((ref = this.cursor) != null ? (ref1 = ref.getSurroundingWord(2)) != null ? ref1.before : void 0 : void 0) || "";
        this.data.base = this.inputHolder + word;
      } else {
        this.data.base = this.inputHolder;
      }
      if (this.input.value !== this.data.base) {
        this.input.value = this.data.base;
      }
      return this.setState("waitCompositeUpdate");
    };

    GeneralInputMethod.prototype.atWaitCompositeUpdate = function() {
      return this.consumeWhenAvailable("input", (function(_this) {
        return function(input) {
          var ref, ref1, ref2, ref3, result;
          if (input.type === "keyboard") {
            if (_this.ignoreKeyEvent || input.event.which === 229) {
              _this.setState("waitCompositeUpdate");
              return;
            }
            result = _this.handleKeyboard(input.event);
            if (result.defaultPrevented) {
              _this.reform();
              return;
            } else {
              _this.setState("waitCompositeUpdate");
              return;
            }
          }
          if (input.type === "input") {
            if (!_this.sync()) {
              return;
            }
            _this.setState("waitCompositeUpdate");
            return;
          }
          if (input.type !== "ime") {
            _this.reform();
            return;
          }
          if (input.action === "update") {
            _this.data.suggestedContent = input.event.data;
            _this.setState("waitCompositeUpdate");
            return;
          }
          if (input.action === "start") {
            if ((ref = _this.buffer.context) != null) {
              ref.history.disableCheckPoint();
            }
            _this.data.suggestedContent = "";
            _this.setState("waitCompositeUpdate");
            return;
          }
          if (input.action === "end") {
            if ((ref1 = _this.buffer.context) != null) {
              ref1.history.enableCheckPoint();
            }
            if ((ref2 = _this.buffer.context) != null) {
              ref2.history.addCheckPoint();
            }
            _this.data.onceEnd = true;
            _this.data.suggestedContent = "";
            if ((ref3 = _this.buffer.imeHint) != null) {
              ref3.clear();
            }
            _this.setState("waitCompositeUpdate");
            return;
          }
          return _this.reform();
        };
      })(this));
    };

    return GeneralInputMethod;

  })(Leaf.States);

  KeyEventHandler = (function(superClass) {
    extend(KeyEventHandler, superClass);

    function KeyEventHandler() {
      return KeyEventHandler.__super__.constructor.apply(this, arguments);
    }

    KeyEventHandler.prototype.handleKeyboard = function(event) {
      var e, error, ke;
      try {
        this.emit("key", ke = new KeyEvent(event));
      } catch (error) {
        e = error;
        Logger.error(e);
      }
      return ke;
    };

    return KeyEventHandler;

  })(Trait);

  FocusableTrait = (function(superClass) {
    extend(FocusableTrait, superClass);

    function FocusableTrait() {
      return FocusableTrait.__super__.constructor.apply(this, arguments);
    }

    FocusableTrait.prototype.ensureFocusState = function(option) {
      if (option == null) {
        option = {};
      }
      if (this.isActive) {
        this.isFocusing = true;
      }
      return this._applyFocusToElement();
    };

    FocusableTrait.prototype.focus = function() {
      this.isFocusing = true;
      return this._applyFocusToElement();
    };

    FocusableTrait.prototype.blur = function() {
      this.isFocusing = false;
      return this._applyFocusToElement();
    };

    FocusableTrait.prototype._applyFocusToElement = function() {
      if (this.editor.platform.isMobile() && this.isFocusing) {
        this.input.blur();
        this.input.focus();
        this.reform();
        return;
      }
      if (this.input !== window.document.activeElement && this.isFocusing) {
        this.input.focus();
        return this.reform();
      } else if (this.input === window.document.activeElement && !this.isFocusing) {
        this.input.blur();
        return this.reform();
      }
    };

    return FocusableTrait;

  })(Trait);

  ActivableTrait = (function(superClass) {
    extend(ActivableTrait, superClass);

    function ActivableTrait() {
      return ActivableTrait.__super__.constructor.apply(this, arguments);
    }

    ActivableTrait.prototype.isActive = false;

    ActivableTrait.prototype.activate = function(option) {
      if (option == null) {
        option = {};
      }
      if (this.isActive) {
        return;
      }
      if (option.forceFocus || !this.editor.platform.isMobile()) {
        this.focus();
      }
      if (this.editor.platform.isMobile()) {
        window.addEventListener("resize", this.checkResize);
      }
      this.reset();
      this.setState("init");
      this.isActive = true;
      return this.reform();
    };

    ActivableTrait.prototype.deactivate = function() {
      if (!this.isActive) {
        return;
      }
      this.blur();
      if (this.editor.platform.isMobile()) {
        window.removeEventListener("resize", this.checkResize);
      }
      this.isActive = false;
      return this.reform();
    };

    return ActivableTrait;

  })(Trait);

  ContentEditableHacker = (function() {
    function ContentEditableHacker(inputMethod) {
      this.inputMethod = inputMethod;
    }

    ContentEditableHacker.prototype.setElement = function(el) {
      this.detach(this.el);
      this.attach(el);
      return this.el = el;
    };

    ContentEditableHacker.prototype.detach = function(el) {
      if (!el) {
        return;
      }
      el.removeEventListener("keydown");
      return el.removeEventListener("input");
    };

    ContentEditableHacker.prototype.attach = function(el) {
      el.addEventListener("keydown", function(e) {
        e.preventDefault();
        return e.stopImmediatePropagation();
      });
      el.addEventListener("compositionstart", function(e) {
        e.preventDefault();
        return e.stopImmediatePropagation();
      });
      return el.addEventListener("input", function(e) {
        e.preventDefault();
        return e.stopImmediatePropagation();
      });
    };

    return ContentEditableHacker;

  })();

  BrowserDefaultKeyBehaviorPreventor = (function() {
    BrowserDefaultKeyBehaviorPreventor.preventing = false;

    function BrowserDefaultKeyBehaviorPreventor() {
      if (BrowserDefaultKeyBehaviorPreventor.preventing) {
        return;
      }
      window.addEventListener("keydown", function(e) {
        if (e.altKey && !e.ctrlKey && e.which !== Leaf.Key.d) {
          return e.preventDefault();
        } else if (e.which === Leaf.Key.tab) {
          return e.preventDefault();
        }
      });
      BrowserDefaultKeyBehaviorPreventor.preventing = true;
    }

    return BrowserDefaultKeyBehaviorPreventor;

  })();

  module.exports = InputMethodMaster;

}).call(this);

}
GlobalContext.setModule("vincent/facility/inputMethod.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/platform.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Device, Platform,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Platform = (function(superClass) {
    extend(Platform, superClass);

    Platform.create = function() {
      if (this.instance == null) {
        this.instance = new Platform();
      }
      return this.instance;
    };

    function Platform() {
      var ref, ref1, ref2, ref3, ref4, ref5;
      Platform.__super__.constructor.call(this);
      this.init();
      if (this.isLinux()) {
        if ((ref = document.body) != null) {
          ref.classList.add("linux");
        }
      }
      if (this.isMac()) {
        if ((ref1 = document.body) != null) {
          ref1.classList.add("mac");
        }
      }
      if (this.isIOS()) {
        if ((ref2 = document.body) != null) {
          ref2.classList.add("ios");
        }
      }
      if (this.isWindows()) {
        if ((ref3 = document.body) != null) {
          ref3.classList.add("windows");
        }
      }
      if (!this.isMobile()) {
        window.addEventListener("mousedown", (function(_this) {
          return function(e) {
            _this.isMouseDown = true;
            _this.lastMousePoint = e;
            _this.lastMouseDownDate = new Date;
          };
        })(this), true);
        window.addEventListener("mouseup", (function(_this) {
          return function() {
            _this.isMouseDown = false;
          };
        })(this), true);
        window.addEventListener("keydown", (function(_this) {
          return function(e) {
            if (e.which === 16) {
              _this.isShiftDown = true;
            }
          };
        })(this), true);
        window.addEventListener("keyup", (function(_this) {
          return function(e) {
            if (e.which === 16) {
              _this.isShiftDown = false;
            }
          };
        })(this), true);
      }
      this.device = new Device();
      this.deviceDetail = this.device.init();
      Logger.debug("Platform", (ref4 = this.deviceDetail.os) != null ? ref4.name : void 0, (ref5 = this.deviceDetail.browser) != null ? ref5.name : void 0);
    }

    Platform.prototype.isWindows = function() {
      return navigator.platform.indexOf('Win') > -1;
    };

    Platform.prototype.isSmall = function() {
      if (this.isSmallCheck) {
        return this._isSmall;
      }
      this.isSmallCheck = true;
      if (window.screen.width < 500) {
        this._isSmall = true;
        return true;
      }
      this._isSmall = false;
      return false;
    };

    Platform.prototype.isMeduim = function() {
      if (this.isMediumCheck) {
        return this._isMedium;
      }
      this.isMediumCheck = true;
      if (window.screen.width >= 500 && window.screen.width < 1025) {
        this._isMedium = true;
        return true;
      }
      this._isMedium = false;
      return false;
    };

    Platform.prototype.isMeduim = function() {
      return !this.isMeduim() && !this.isSmall();
    };

    Platform.prototype.isVirtualKeyboard = function() {
      return this.isMobile();
    };

    Platform.prototype.hasKeyboard = function() {
      return !this.isTouch();
    };

    Platform.prototype.isTouch = function() {
      return this.isMobile();
    };

    Platform.prototype.isMobile = function() {
      var check, ua;
      if (this.isMobileCheck) {
        return this._isMobile;
      }
      check = false;
      ua = navigator.userAgent || navigator.vendor || window.opera;
      (function(_this) {
        return (function(ua) {
          if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(ua) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(ua.substr(0, 4)) || _this.isIOS()) {
            return check = true;
          }
        });
      })(this)(ua);
      this.isMobileCheck = true;
      this._isMobile = check;
      return check;
    };

    Platform.prototype.isNative = function() {
      return false;
    };

    Platform.prototype.isLinux = function() {
      var ref, ref1;
      return ((ref = window.navigator.platform) != null ? (ref1 = ref.toLowerCase()) != null ? ref1.indexOf("linux") : void 0 : void 0) >= 0;
    };

    Platform.prototype.isMac = function() {
      var ref, ref1;
      return ((ref = window.navigator.platform) != null ? (ref1 = ref.toLowerCase()) != null ? ref1.indexOf("mac") : void 0 : void 0) >= 0;
    };

    Platform.prototype.isIOS = function() {
      var ref, ref1;
      return (ref = window.navigator) != null ? (ref1 = ref.userAgent) != null ? ref1.match(/iPhone|iPad|iPod/i) : void 0 : void 0;
    };

    Platform.prototype.isSafari = function() {
      var is_chrome, is_explorer, is_firefox, is_opera, is_safari;
      is_chrome = navigator.userAgent.indexOf('Chrome') > -1;
      is_explorer = navigator.userAgent.indexOf('MSIE') > -1;
      is_firefox = navigator.userAgent.indexOf('Firefox') > -1;
      is_safari = navigator.userAgent.indexOf("Safari") > -1;
      is_opera = navigator.userAgent.toLowerCase().indexOf("op") > -1;
      if (!is_chrome && is_safari || this.isIOS()) {
        return true;
      }
      return false;
    };

    Platform.prototype.isAndroid = function() {
      var ref, ref1;
      return (ref = window.navigator) != null ? (ref1 = ref.userAgent) != null ? ref1.match(/Android/i) : void 0 : void 0;
    };

    Platform.prototype.isVisible = function() {
      var hidden, visibilityChange;
      if (typeof document.hidden !== "undefined") {
        hidden = "hidden";
        visibilityChange = "visibilitychange";
      } else if (typeof document.mozHidden !== "undefined") {
        hidden = "mozHidden";
        visibilityChange = "mozvisibilitychange";
      } else if (typeof document.msHidden !== "undefined") {
        hidden = "msHidden";
        visibilityChange = "msvisibilitychange";
      } else if (typeof document.webkitHidden !== "undefined") {
        hidden = "webkitHidden";
        visibilityChange = "webkitvisibilitychange";
      }
      return !document[hidden];
    };

    Platform.prototype.isEmbeded = function() {
      return window.top !== window;
    };

    Platform.prototype.emitEmbedEvent = function() {
      var args, message, name;
      name = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!this.isEmbeded()) {
        return false;
      }
      message = {
        type: "event",
        name: name,
        args: args,
        source: "embed"
      };
      return window.top.postMessage(JSON.stringify(message), "*");
    };

    Platform.prototype.init = function() {
      return window.addEventListener("message", (function(_this) {
        return function(e) {
          var data, err, error;
          try {
            Logger.debug(e.data);
            data = JSON.parse(e.data.toString());
            if (data.type === "event") {
              if (data.args == null) {
                data.args = [];
              }
              if (data.source === "embed") {
                return _this.emit.apply(_this, ["embed/" + data.name].concat(slice.call(data.args)));
              } else if (data.source === "parent") {
                return _this.emit.apply(_this, ["parent/" + data.name].concat(slice.call(data.args)));
              }
            }
          } catch (error) {
            err = error;
            Logger.error("msg error", err, e);
          }
        };
      })(this));
    };

    Platform.prototype.getDeviceDescription = function() {
      return this.deviceDetail.os.name + " " + this.deviceDetail.browser.name;
    };

    return Platform;

  })(Leaf.EventEmitter);

  module.exports = Platform;

  Device = (function() {
    function Device() {}

    Device.prototype.options = [];

    Device.prototype.header = [navigator.platform, navigator.userAgent, navigator.appVersion, navigator.vendor, window.opera];

    Device.prototype.dataos = [
      {
        name: 'Windows Phone',
        value: 'Windows Phone',
        version: 'OS'
      }, {
        name: 'Windows',
        value: 'Win',
        version: 'NT'
      }, {
        name: 'iPhone',
        value: 'iPhone',
        version: 'OS'
      }, {
        name: 'iPad',
        value: 'iPad',
        version: 'OS'
      }, {
        name: 'Kindle',
        value: 'Silk',
        version: 'Silk'
      }, {
        name: 'Android',
        value: 'Android',
        version: 'Android'
      }, {
        name: 'PlayBook',
        value: 'PlayBook',
        version: 'OS'
      }, {
        name: 'BlackBerry',
        value: 'BlackBerry',
        version: '/'
      }, {
        name: 'Macintosh',
        value: 'Mac',
        version: 'OS X'
      }, {
        name: 'Linux',
        value: 'Linux',
        version: 'rv'
      }, {
        name: 'Palm',
        value: 'Palm',
        version: 'PalmOS'
      }
    ];

    Device.prototype.databrowser = [
      {
        name: 'Chrome',
        value: 'Chrome',
        version: 'Chrome'
      }, {
        name: 'Firefox',
        value: 'Firefox',
        version: 'Firefox'
      }, {
        name: 'Safari',
        value: 'Safari',
        version: 'Version'
      }, {
        name: 'Internet Explorer',
        value: 'MSIE',
        version: 'MSIE'
      }, {
        name: 'Opera',
        value: 'Opera',
        version: 'Opera'
      }, {
        name: 'BlackBerry',
        value: 'CLDC',
        version: 'CLDC'
      }, {
        name: 'Mozilla',
        value: 'Mozilla',
        version: 'Mozilla'
      }
    ];

    Device.prototype.init = function() {
      var agent, browser, os;
      agent = this.header.join(' ');
      os = this.matchItem(agent, this.dataos);
      browser = this.matchItem(agent, this.databrowser);
      return {
        os: os,
        browser: browser
      };
    };

    Device.prototype.matchItem = function(string, data) {
      var html, i, j, k, l, match, matches, ref, ref1, regex, regexv, version;
      i = 0;
      j = 0;
      html = "";
      for (i = k = 0, ref = data.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        regex = new RegExp(data[i].value, 'i');
        match = regex.test(string);
        if (match) {
          regexv = new RegExp(data[i].version + '[- /:;]([\\d._]+)', 'i');
          matches = string.match(regexv);
          version = '';
          if (matches && matches[1]) {
            matches = matches[1];
          }
          if (matches) {
            matches = matches.split(/[._]+/);
            for (j = l = 0, ref1 = matches.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
              if (j === 0) {
                version += matches[j] + '.';
              } else {
                version += matches[j];
              }
            }
          } else {
            version = '0';
          }
          return {
            name: data[i].name,
            version: parseFloat(version)
          };
        }
      }
      return {
        name: 'unknown',
        version: 0
      };
    };

    return Device;

  })();

}).call(this);

}
GlobalContext.setModule("vincent/facility/platform.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/pluginManager.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Dependencies, Dependency, PluginManager,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  PluginManager = (function() {
    function PluginManager(editor) {
      this.editor = editor;
      this.plugins = {};
      this.pluginCtors = {};
      this.dependencies = new Dependencies();
    }

    PluginManager.prototype.register = function(Plugin) {
      if (!Plugin.prototype.name && !Plugin.name) {
        Logger.error("Invalid Plugin", Plugin);
        throw new Error("invalid plugin without name");
      }
      this.editor.addPackageStatic(Plugin);
      this.pluginCtors[Plugin.prototype.name || Plugin.name] = Plugin;
      return this.dependencies.add({
        name: Plugin.prototype.name || Plugin.name,
        requires: Plugin.prototype.requires || Plugin.requires || []
      });
    };

    PluginManager.prototype.init = function() {
      var Ctor, prop, ref, results;
      ref = this.pluginCtors;
      results = [];
      for (prop in ref) {
        Ctor = ref[prop];
        results.push(this.initPlugin(prop));
      }
      return results;
    };

    PluginManager.prototype.initPlugin = function(name) {
      var Ctor, base, dep, deps, i, len;
      if (this.plugins[name]) {
        return true;
      }
      deps = this.dependencies.get(name).flatten();
      Ctor = this.pluginCtors[name];
      if (typeof Ctor === "function") {
        this.plugins[name] = new Ctor();
      } else {
        this.plugins[name] = Ctor;
      }
      for (i = 0, len = deps.length; i < len; i++) {
        dep = deps[i];
        this.initPlugin(dep);
      }
      return typeof (base = this.plugins[name]).init === "function" ? base.init(this.editor, this.plugins) : void 0;
    };

    return PluginManager;

  })();

  Dependency = (function() {
    function Dependency(name1) {
      this.name = name1;
      this.dependencies = [];
    }

    Dependency.prototype.addDirectDependency = function(item) {
      var name, parent;
      parent = this;
      name = item.name;
      while (parent) {
        if (parent.name === item.name) {
          Logger.error("recursive dependencies " + this.name + " require " + name);
          Logger.error("but " + this.name + " require is required by " + name);
          throw new Error("recursive dependencies");
        }
        parent = parent.parent;
      }
      item.parent = this;
      return this.dependencies.push(item);
    };

    Dependency.prototype.flatten = function(queue) {
      var child, i, len, ref, ref1;
      if (queue == null) {
        queue = [];
      }
      ref = this.dependencies;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        child.flatten(queue);
        if (ref1 = child.name, indexOf.call(queue, ref1) < 0) {
          queue.push(child.name);
        }
      }
      return queue;
    };

    return Dependency;

  })();

  Dependencies = (function() {
    function Dependencies() {
      this.items = {};
      this._state = 0;
    }

    Dependencies.prototype.add = function(dep) {
      this._state++;
      return this.items[dep.name] = dep;
    };

    Dependencies.prototype.get = function(name) {
      var target;
      target = this.items[name];
      if (!target) {
        return null;
      }
      return this.getDependency(target);
    };

    Dependencies.prototype.getDependency = function(item, stack) {
      var child, i, len, ref, ref1;
      if (stack == null) {
        stack = [];
      }
      item.dependency = new Dependency(item.name);
      if (ref = item.name, indexOf.call(stack, ref) >= 0) {
        throw new Error("recursive requires for " + item.name);
      } else {
        stack.push(item.name);
      }
      ref1 = item.requires || [];
      for (i = 0, len = ref1.length; i < len; i++) {
        child = ref1[i];
        if (!this.items[child]) {
          throw new Error("dependency " + child + " not found");
        }
        item.dependency.addDirectDependency(this.getDependency(this.items[child], stack.slice(0)));
      }
      return item.dependency;
    };

    return Dependencies;

  })();

  module.exports = PluginManager;

}).call(this);

}
GlobalContext.setModule("vincent/facility/pluginManager.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/searchSession.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Rune, SearchSession, Walker;

  Walker = COM.COMWalker;

  Rune = COM.COMRune;

  SearchSession = (function() {
    function SearchSession(buffer1) {
      this.buffer = buffer1;
      this.editor = this.buffer.editor;
      this.modifier = "gi";
      this.lightColor = "yellow";
      this.focusColor = "orange";
    }

    SearchSession.prototype.setKeyword = function(keyword) {
      this.end();
      return this.keyword = keyword;
    };

    SearchSession.prototype.applyCurrent = function(option) {
      var item, selection;
      if (option == null) {
        option = {};
      }
      item = this.currentFocus;
      selection = this.buffer.selection;
      if (!item) {
        selection.deactivate();
      } else if (option.begin) {
        selection.baseCursor.pointAtAnchor(item.startAnchor);
        selection.extentCursor.pointAtAnchor(item.startAnchor);
        return selection.deactivate();
      } else if (option.select) {
        selection.activate();
        selection.baseCursor.pointAtAnchor(item.startAnchor);
        return selection.extentCursor.pointAtAnchor(item.endAnchor);
      } else {
        selection.baseCursor.pointAtAnchor(item.endAnchor);
        selection.extentCursor.pointAtAnchor(item.endAnchor);
        return selection.deactivate();
      }
    };

    SearchSession.prototype.buildReg = function() {
      var mod, word;
      if (this.keyword.indexOf("reg:") === 0) {
        word = this.keyword.slice(4).replace(/\\n/g, "\n");
        mod = "g";
      } else {
        word = this.keyword.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, function(match) {
          return "\\" + match;
        });
        mod = this.modifier;
      }
      return new RegExp(word, mod);
    };

    SearchSession.prototype.search = function() {
      var buffer, context, cs, currentNode, currentNodePass, cursor, end, endAnchor, match, nextHit, node, previousHit, previousHitTarget, ref, ref1, reg, result, results, start, startAnchor, walker;
      buffer = this.buffer;
      context = this.buffer.context;
      walker = new Walker.WalkerRootFirst(context);
      walker.setNode(context.root);
      results = [];
      currentNode = false;
      nextHit = null;
      previousHit = null;
      reg = this.buildReg();
      previousHitTarget = null;
      cursor = this.cursorBackup;
      while (walker.next((function(item) {
          return item.sortOf("RichText");
        }))) {
        reg.lastIndex = 0;
        node = walker.node;
        cs = Rune.purifyContentString(node.contentString, {
          useHolder: true
        });
        if (walker.node === cursor.target) {
          currentNodePass = true;
        }
        while (match = reg.exec(cs)) {
          if (match[0].length === 0) {
            break;
          }
          startAnchor = walker.node.anchor.clone();
          endAnchor = walker.node.anchor.clone();
          start = match.index;
          end = match.index + match[0].length;
          startAnchor.index = start;
          endAnchor.index = end;
          result = {
            target: walker.node,
            content: match[0],
            length: match.length,
            start: start,
            end: end,
            startAnchor: startAnchor,
            endAnchor: endAnchor
          };
          if (currentNodePass && !nextHit && !this.isReverse) {
            if (result.target === cursor.target && result.start >= cursor.anchor.index) {
              nextHit = true;
              result.current = true;
            } else if (result.target !== cursor.target) {
              nextHit = true;
              result.current = true;
            }
          }
          if (this.isReverse && !currentNodePass) {
            previousHit = true;
            previousHitTarget = result;
          } else if (this.isReverse && currentNodePass && result.target === cursor.target && result.end <= cursor.anchor.index) {
            previousHit = true;
            previousHitTarget = result;
          } else if (this.isReverse && !previousHit) {
            previousHit = true;
            previousHitTarget = result;
          }
          results.push(result);
        }
      }
      if (previousHitTarget) {
        previousHitTarget.current = true;
      }
      if (!nextHit && !this.isReverse) {
        if ((ref = results[0]) != null) {
          ref.current = true;
        }
      }
      if (!previousHitTarget && this.isReverse) {
        if ((ref1 = results[results.length - 1]) != null) {
          ref1.current = true;
        }
      }
      return results;
    };

    SearchSession.prototype.start = function() {
      var current, i, item, len, light, ref;
      if (this.isStart) {
        return;
      }
      this.isStart = true;
      this.cursorBackup = this.buffer.cursor.clone();
      this.lightSession = this.buffer.highlighter.createSession();
      this.hits = this.search();
      this.lights = [];
      this.lightSession.clear();
      ref = this.hits;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        light = this.lightSession.addHighlight(item.startAnchor, item.endAnchor, {
          color: this.lightColor
        });
        item.light = light;
        if (item.current) {
          current = item;
        }
      }
      this.lightSession.applyAll();
      if (current) {
        return this.setCurrent(current);
      }
    };

    SearchSession.prototype.end = function(option) {
      var ref;
      if (option == null) {
        option = {};
      }
      if (!this.isStart) {
        return;
      }
      this.isStart = false;
      if (option.apply && this.keyword) {
        this.applyCurrent(option);
      } else if ((ref = this.cursorBackup) != null ? ref.anchor : void 0) {
        this.buffer.selection.deactivate();
        this.buffer.cursor.pointAtAnchor(this.cursorBackup.anchor);
        this.buffer.selection.collapseToCursor();
      }
      if (this.lightSession) {
        this.lightSession.clear();
        return this.lightSession = null;
      }
    };

    SearchSession.prototype.replaceAll = function(content) {
      this.buffer.context.transact((function(_this) {
        return function() {
          var hit, i, len, ref, text;
          ref = _this.hits;
          for (i = 0, len = ref.length; i < len; i++) {
            hit = ref[i];
            if (!hit) {
              continue;
            }
            text = hit.light.startCursor.target;
            hit.light.startCursor.anchor.deleteBetween(hit.light.endCursor.anchor);
            text.insertText(hit.light.startCursor.anchor.index, content);
          }
          return _this.hits = [];
        };
      })(this));
      return true;
    };

    SearchSession.prototype.replaceCurrentContentAndNext = function(content) {
      if (!this.currentFocus) {
        return false;
      }
      return this.buffer.context.transact((function(_this) {
        return function() {
          var matchIndex, text;
          text = _this.currentFocus.light.startCursor.target;
          _this.currentFocus.light.startCursor.anchor.deleteBetween(_this.currentFocus.light.endCursor.anchor);
          text.insertText(_this.currentFocus.light.startCursor.anchor.index, content);
          matchIndex = -1;
          _this.currentFocus.light.clear();
          _this.hits = _this.hits.filter(function(item, index) {
            if (item !== _this.currentFocus) {
              return true;
            }
            matchIndex = index;
            return false;
          });
          if (_this.hits[matchIndex]) {
            return _this.setCurrent(_this.hits[matchIndex]);
          } else if (_this.hits[0]) {
            return _this.setCurrent(_this.hits[0]);
          } else {
            return _this.currentFocus = null;
          }
        };
      })(this));
    };

    SearchSession.prototype.setCurrent = function(item) {
      var rect, ref;
      if (!item) {
        return false;
      }
      if (this.currentFocus) {
        this.currentFocus.light.setOption({
          color: this.lightColor
        });
      }
      item.light.setOption({
        color: this.focusColor
      });
      this.currentFocus = item;
      this.buffer.cursor.pointAtAnchor(item.light.startCursor.anchor);
      item.light.blink();
      rect = (ref = item.light.rects[0]) != null ? ref.rect : void 0;
      if (!rect) {
        return;
      }
      this.editor.buffer.viewPort.scrollToRectComfortableZone(rect, {
        forceCenter: true
      });
      return true;
    };

    SearchSession.prototype.next = function() {
      var i, index, item, len, next, ref;
      if (!this.hits) {
        return false;
      }
      if (!this.currentFocus) {
        return this.setCurrent(this.hits[0]);
      }
      ref = this.hits;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        next = this.hits[index + 1];
        if (item === this.currentFocus) {
          if (next) {
            this.setCurrent(next);
            return true;
          } else {
            return this.setCurrent(this.hits[0]);
          }
        }
      }
      return false;
    };

    SearchSession.prototype.previous = function() {
      var i, index, item, len, previous, ref;
      if (!this.hits) {
        return false;
      }
      if (!this.currentFocus) {
        return this.setCurrent(this.hits[0]);
      }
      ref = this.hits;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        previous = this.hits[index - 1];
        if (item === this.currentFocus) {
          if (previous) {
            this.setCurrent(previous);
            return true;
          } else {
            return this.setCurrent(this.hits[this.hits.length - 1]);
          }
        }
      }
      return false;
    };

    return SearchSession;

  })();

  module.exports = SearchSession;

}).call(this);

}
GlobalContext.setModule("vincent/facility/searchSession.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/selectSession.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DOMBoundary, DOMRegion, DOMSelection, SelectSession, States,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  States = require("../common/states");

  DOMRegion = require("../common/region");

  DOMBoundary = require("../common/boundary");

  DOMSelection = require("../facility/selection");

  SelectSession = (function(superClass) {
    extend(SelectSession, superClass);

    function SelectSession(buffer) {
      this.buffer = buffer;
      SelectSession.__super__.constructor.call(this);
      this.selection = this.buffer.selection;
      this.domSelection = this.buffer.editor.domSelection;
      this.onSelectionChange = this.onSelectionChange.bind(this);
      if (this.buffer.editor.platform.hasKeyboard() || true) {
        this.passive = false;
      } else {
        this.passive = true;
      }
      this.mode = "";
    }

    SelectSession.prototype.clear = function() {
      if (!this.passive) {
        this.clearDomSelection();
        this.selection.deactivate();
        return this.selection.collapseToEnd();
      }
    };

    SelectSession.prototype.syncSelection = function() {
      if (this.passive) {
        return;
      }
      return this.syncFromCOM();
    };

    SelectSession.prototype.selectCurrentWord = function() {
      var selection;
      selection = this.selection;
      selection.activate();
      selection.collapseToCursor();
      selection.baseCursor.conduct("backwardWord");
      return selection.extentCursor.conduct("forwardWord");
    };

    SelectSession.prototype.selectCurrentLine = function() {
      var selection;
      if (this.buffer.editor.platform.isMobile()) {
        return false;
      }
      selection = this.selection;
      selection.activate();
      selection.collapseToCursor();
      selection.baseCursor.conduct("startOfLine");
      return selection.extentCursor.conduct("endOfLine");
    };

    SelectSession.prototype.syncToCOM = function() {
      var base, extent, selection;
      selection = window.getSelection();
      if (selection.isCollapsed) {
        return false;
      }
      base = new DOMRegion(selection.baseNode, selection.baseOffset);
      extent = new DOMRegion(selection.extentNode, selection.extentOffset);
      this.selection.activate();
      this.selection.baseCursor.setCursorByDOMRegion(base);
      this.selection.extentCursor.setCursorByDOMRegion(extent);
      return true;
    };

    SelectSession.prototype.onSelectionChange = function() {
      if (this.passive) {
        return this.syncToCOM();
      }
    };

    SelectSession.prototype.deactivate = function() {
      this.clearDomSelection();
      if (!this.isActive) {
        return;
      }
      this.isActive = false;
      return document.removeEventListener("selectionchange", this.onSelectionChange);
    };

    SelectSession.prototype.activate = function() {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      return document.addEventListener("selectionchange", this.onSelectionChange);
    };

    SelectSession.prototype.syncFromCOM = function() {
      if (!this.isActive) {
        this.clearDomSelection();
        return false;
      }
      if (!this.selection.isActive) {
        this.clearDomSelection();
        return false;
      }
      if (this.passive) {
        return false;
      }
      if (this.selection.isCollapsed()) {
        this.clearDomSelection();
      } else {
        this.selectionFromCOM();
      }
      return true;
    };

    SelectSession.prototype.clearDomSelection = function() {
      return this.domSelection.clear(this);
    };

    SelectSession.prototype.updateExtentCursor = function(action) {
      if (action.source === "mouse") {
        return this.updateExtentCursorByMouse(action.e);
      } else {
        return this.updateExtentCursorByTouch(action.e);
      }
    };

    SelectSession.prototype.updateExtentCursorByTouch = function(e) {
      var ref, touches, x, y;
      if ((e != null ? (ref = e.touches) != null ? ref.length : void 0 : void 0) < 2) {
        return;
      }
      touches = e.touches;
      e.preventDefault();
      x = (touches[0].clientX + touches[1].clientX) / 2;
      y = (touches[0].clientY + touches[1].clientY) / 2;
      this.buffer.viewPort.setCursorByClientPoint(x, y);
      return this.selection.collapseToCursor();
    };

    SelectSession.prototype.updateExtentCursorByMouse = function(e) {
      return this.buffer.viewPort.setCursorByClientPoint(e.clientX, e.clientY);
    };

    SelectSession.prototype.selectionFromCOM = function() {
      var backup, base, extent, range, selection;
      selection = this.buffer.selection;
      if (!(base = selection.baseAnchor)) {
        return false;
      }
      if (!(extent = selection.extentAnchor)) {
        return false;
      }
      base = base.getCorrespondingBoundary();
      extent = extent.getCorrespondingBoundary();
      range = DOMBoundary.createRangeBetween(base, extent);
      backup = document.createRange();
      backup = range.cloneRange();
      backup.endOffset = 20;
      this.clearDomSelection();
      this.domSelection.use(this, range);
    };

    return SelectSession;

  })(States);

  module.exports = SelectSession;

}).call(this);

}
GlobalContext.setModule("vincent/facility/selectSession.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/selection.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DOMSelection,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DOMSelection = (function(superClass) {
    extend(DOMSelection, superClass);

    function DOMSelection(editor) {
      this.editor = editor;
      DOMSelection.__super__.constructor.call(this);
      this.ranges = [];
    }

    DOMSelection.prototype.detect = function() {
      var selection;
      selection = window.getSelection();
      if (selection.isCollapsed) {
        return false;
      } else {
        return true;
      }
    };

    DOMSelection.prototype.use = function(who, range) {
      if (!range) {
        throw new Error("DOMSelection.use should provide a valid range");
      }
      return this.ranges.push({
        who: who,
        range: {
          startContainer: range.startContainer,
          startOffset: range.startOffset,
          endContainer: range.endContainer,
          endOffset: range.endOffset
        }
      });
    };

    DOMSelection.prototype.clear = function(who) {
      var length;
      length = this.ranges.length;
      if (length === 0) {
        return false;
      }
      this.ranges = this.ranges.filter(function(item) {
        return item.who !== who;
      });
      if (this.ranges.length === length) {
        return false;
      }
      if (!who) {
        return this.ranges = [];
      }
    };

    DOMSelection.prototype.disable = function() {
      return this.disabled = true;
    };

    DOMSelection.prototype.enable = function() {
      return this.disabled = false;
    };

    DOMSelection.prototype.render = function() {
      var i, item, len, range, ref, results, selection;
      if (this.disabled) {
        return;
      }
      if (this.ranges.length === 0 || (this.ranges.length === 1 && this.ranges[0].range.isCollapsed)) {
        if (this.hasFocus) {
          this.hasFocus = false;
          this.editor.focus.inputFocus.release(this);
        }
        return;
      }
      this.hasFocus = true;
      this.editor.focus.inputFocus.obtain(this);
      selection = window.getSelection();
      selection.removeAllRanges();
      return;
      ref = this.ranges;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        range = document.createRange();
        range.setStart(item.range.startContainer, item.range.startOffset);
        range.setEnd(item.range.endContainer, item.range.endOffset);
        results.push(selection.addRange(range));
      }
      return results;
    };

    return DOMSelection;

  })(Leaf.EventEmitter);

  module.exports = DOMSelection;

}).call(this);

}
GlobalContext.setModule("vincent/facility/selection.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/selectionHighlight.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var Caret, Rect, SelectionHighlight,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Caret = require("./caret");

  SelectionHighlight = (function(superClass) {
    extend(SelectionHighlight, superClass);

    function SelectionHighlight(buffer) {
      this.buffer = buffer;
      this.editor = this.buffer.editor;
      this.buffer.listenBy(this, "resize", (function(_this) {
        return function() {
          return _this.render();
        };
      })(this));
      this.caretBase = new Caret(this.editor, {
        name: "base"
      });
      this.caretExtent = new Caret(this.editor, {
        name: "extent"
      });
      this.caretBase.init();
      this.caretExtent.init();
      this.head = new Rect();
      this.body = new Rect();
      this.foot = new Rect();
      this.buffer.viewPort.el.appendChild(this.head.node);
      this.buffer.viewPort.el.appendChild(this.body.node);
      this.buffer.viewPort.el.appendChild(this.foot.node);
    }

    SelectionHighlight.prototype.destroy = function() {
      this.caretBase.destroy();
      this.caretExtent.destroy();
      return this.buffer.stopListenBy(this);
    };

    SelectionHighlight.prototype.setRange = function(range) {
      this.range = range;
      return this.render();
    };

    SelectionHighlight.prototype.render = function() {
      if (this.buffer.selection.isCollapsed() || !this.buffer.selection.isActive) {
        this.caretBase.hide();
        this.caretExtent.hide();
        this.head.setDimension();
        this.body.setDimension();
        this.foot.setDimension();
        return;
      }
      if (!this.caretBase.isShow) {
        this.caretBase.show();
        this.caretExtent.show();
        if (this.caretBase.currentBuffer !== this.buffer) {
          this.caretBase.attachTo(this.buffer, this.buffer.selection.baseCursor);
          this.caretExtent.attachTo(this.buffer, this.buffer.selection.extentCursor);
        }
      }
      this.caretBase.update();
      this.caretExtent.update();
      return this.updateRects();
    };

    SelectionHighlight.prototype.updateRects = function() {
      var bottomRect, rootRect, topRect;
      rootRect = this.buffer.viewPort.el.getBoundingClientRect();
      topRect = this.caretBase.lastRenderDetail;
      bottomRect = this.caretExtent.lastRenderDetail;
      if (!topRect || !bottomRect) {
        return;
      }
      if (topRect.bottom < bottomRect.top) {
        return this.updateMultiLine(rootRect, topRect, bottomRect);
      } else if (bottomRect.bottom < topRect.top) {
        return this.updateMultiLine(rootRect, bottomRect, topRect);
      } else {
        if (topRect.left < bottomRect.left) {
          this.updateSingleLine(rootRect, topRect, bottomRect);
        } else {
          this.updateSingleLine(rootRect, bottomRect, topRect);
        }
      }
    };

    SelectionHighlight.prototype.updateSingleLine = function(rootRect, leftRect, rightRect) {
      var bottom, height, left, top, width;
      this.head.setDimension();
      this.foot.setDimension();
      top = Math.min(leftRect.top, rightRect.top);
      bottom = Math.max(leftRect.bottom, rightRect.bottom);
      height = bottom - top;
      left = leftRect.left;
      width = rightRect.right - leftRect.left;
      return this.body.setDimension({
        top: top,
        left: left,
        height: height,
        width: width
      });
    };

    SelectionHighlight.prototype.updateMultiLine = function(rootRect, topRect, bottomRect) {
      var bodyRect, footRect, headRect, scrollWidthFix;
      scrollWidthFix = 6;
      headRect = {
        left: topRect.left,
        top: topRect.top,
        width: rootRect.right - topRect.left - rootRect.left - scrollWidthFix,
        height: topRect.height
      };
      bodyRect = {
        left: 0,
        top: topRect.bottom,
        width: rootRect.width - scrollWidthFix,
        height: bottomRect.top - topRect.top - topRect.height
      };
      footRect = {
        left: 0,
        top: bottomRect.top,
        width: bottomRect.right,
        height: bottomRect.height
      };
      this.head.setDimension(headRect);
      this.body.setDimension(bodyRect);
      return this.foot.setDimension(footRect);
    };

    return SelectionHighlight;

  })(Leaf.EventEmitter);

  Rect = (function(superClass) {
    extend(Rect, superClass);

    function Rect() {
      Rect.__super__.constructor.call(this);
      this.node.classList.add("selection-rect");
    }

    Rect.prototype.setDimension = function(rect) {
      var ref, ref1;
      if (!rect || rect.height <= 6) {
        this.node.style.display = "none";
        return;
      } else {
        this.node.style.display = "block";
      }
      if (((ref = this.lastRect) != null ? ref.left : void 0) === rect.left && ((ref1 = this.lastRect) != null ? ref1.top : void 0) === rect.top && this.lastRect.width === rect.width && this.lastRect.height === rect.height) {
        return;
      }
      this.lastRect = rect;
      this.node$.css(rect);
      return this.node$.css({
        position: "absolute"
      });
    };

    return Rect;

  })(Leaf.Widget);

  module.exports = SelectionHighlight;

}).call(this);

}
GlobalContext.setModule("vincent/facility/selectionHighlight.js",module,exec);
})();
(function(){
var require = GlobalContext.requireModule.bind(GlobalContext,"vincent/facility/viewPort.js");
var module = {};
module.exports = {};
var exports = module.exports;
function exec(){
    // Generated by CoffeeScript 1.10.0
(function() {
  var DOMRegion, KeyEvent, PathTracer, PointerEvent, States, ThumbControlSession, TimeFeed, TriggerStack, Vibration, ViewPort, ViewPortPointerController, ViewPortTouchController,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DOMRegion = require("../common/region");

  States = require("../common/states");

  KeyEvent = require("../common/keyEvent");

  Vibration = require("/component/vibration");

  ViewPort = (function(superClass) {
    extend(ViewPort, superClass);

    function ViewPort(buffer, el1) {
      this.buffer = buffer;
      this.el = el1;
      ViewPort.__super__.constructor.call(this);
      this.editor = this.buffer.editor;
      this.selectSession = this.buffer.selectSession;
      this.el.viewPort = this;
      this.el.buffer = this.buffer;
      this.comfortableMargin = $("body").height() / 8 || 30;
      this.__defineGetter__("isActive", (function(_this) {
        return function() {
          return _this.buffer.isActive;
        };
      })(this));
      this.__defineGetter__("height", (function(_this) {
        return function() {
          var ref;
          return ((ref = _this.el) != null ? ref.offsetHeight : void 0) || 0;
        };
      })(this));
      this.el.addEventListener("scroll", (function(_this) {
        return function() {
          return _this.emit("scroll");
        };
      })(this));
    }

    ViewPort.prototype.setRoot = function(rootElement) {
      var ref, ref1, ref2;
      if (this.rootElement === rootElement) {
        return;
      }
      if (((ref = this.rootElement) != null ? ref.parentElement : void 0) === this.el) {
        if ((ref1 = this.rootElement) != null) {
          if ((ref2 = ref1.parentElement) != null) {
            ref2.removeChild(this.rootElement);
          }
        }
      }
      if (rootElement.parentElement !== this.el) {
        this.el.appendChild(rootElement);
      }
      this.rootElement = rootElement;
      this.rootElement.classList.add("no-select");
      return this.emit("rootElement", this.rootElement);
    };

    ViewPort.prototype.init = function() {
      this.scrollable = this.el;
      if (!this.editor.platform.isMobile()) {
        return this.controller = new ViewPortPointerController(this.buffer, this);
      } else {
        return this.controller = new ViewPortTouchController(this.buffer, this);
      }
    };

    ViewPort.prototype.scrollToRectComfortableZone = function(rect, option) {
      var bottom, center, setScroll, top;
      if (option == null) {
        option = {};
      }
      if (!rect) {
        return false;
      }
      top = this.scrollable.scrollTop;
      bottom = top + this.height;
      center = (rect.top + rect.bottom) / 2;
      setScroll = (function(_this) {
        return function(v) {
          if (_this.scrollable.scrollTop !== v) {
            return _this.scrollable.scrollTop = v;
          }
        };
      })(this);
      if (option.forceCenter) {
        this.scrollable.scrollTop = center - this.height / 2;
        return true;
      }
      if (rect.top - this.comfortableMargin < top && top > 0) {
        if (option.center) {
          setScroll(center - this.height / 2);
        } else {
          setScroll(rect.top - this.comfortableMargin);
        }
      }
      if (rect.bottom + this.comfortableMargin > bottom) {
        if (option.center) {
          setScroll(center - this.height / 2);
        } else {
          setScroll(rect.bottom + this.comfortableMargin - this.height);
        }
      }
      return true;
    };

    ViewPort.prototype.nextPage = function() {
      this.scrollable.scrollTop += this.height * 3 / 4;
      return true;
    };

    ViewPort.prototype.previousPage = function() {
      this.scrollable.scrollTop -= this.height * 3 / 4;
      return true;
    };

    ViewPort.prototype.goTop = function() {
      return this.scrollable.scrollTop = 0;
    };

    ViewPort.prototype.goBottom = function() {
      return this.scrollable.scrollTop = this.scrollable.scrollHeight;
    };

    ViewPort.prototype.DOMRegionFromPoint = function(x, y) {
      var clientX, clientY, r;
      clientX = x;
      clientY = y;
      if (this.editor.platform.isSafari()) {
        this.rootElement.classList.add("has-select");
        r = DOMRegion.fromClientPoint(x, y);
        this.rootElement.classList.remove("has-select");
      } else {
        r = DOMRegion.fromClientPoint(x, y);
      }
      return r;
    };

    ViewPort.prototype.setCursorByClientPoint = function(x, y, cursor) {
      var el, ref, region;
      if (this.selectSession == null) {
        this.selectSession = this.buffer.selectSession;
      }
      if (this.selectSession.passive && ((ref = this.selectSession.selection) != null ? typeof ref.detect === "function" ? ref.detect() : void 0 : void 0) && !cursor) {
        return;
      }
      region = this.DOMRegionFromPoint(x, y);
      if (!region) {
        return false;
      }
      el = region.getContainerElement();
      while (el && el !== this.el) {
        if (el.getAttribute("comless")) {
          return false;
        }
        el = el.parentElement;
      }
      if (cursor == null) {
        cursor = this.buffer.cursor;
      }
      cursor.setCursorByDOMRegion(region);
      return true;
    };

    ViewPort.prototype.resolveRectWithTop = function(rect) {
      var scrollTop;
      scrollTop = this.el.scrollTop;
      if (!this.baseRect) {
        this.baseRect = this.el.getBoundingClientRect();
      }
      rect = {
        top: rect.top,
        left: rect.left,
        bottom: rect.bottom,
        right: rect.right,
        height: rect.height,
        width: rect.width
      };
      rect.top += scrollTop;
      rect.bottom += scrollTop;
      rect.top -= this.baseRect.top;
      rect.bottom -= this.baseRect.top;
      rect.left -= this.baseRect.left;
      rect.right -= this.baseRect.left;
      return rect;
    };

    ViewPort.prototype.resolveRect = function(rect) {
      var scrollTop;
      scrollTop = this.el.scrollTop;
      if (!this.baseRect) {
        this.baseRect = this.el.getBoundingClientRect();
      }
      rect = {
        top: rect.top,
        left: rect.left,
        bottom: rect.bottom,
        right: rect.right,
        height: rect.height,
        width: rect.width
      };
      rect.top -= this.baseRect.top;
      rect.bottom -= this.baseRect.top;
      rect.left -= this.baseRect.left;
      rect.right -= this.baseRect.left;
      return rect;
    };

    return ViewPort;

  })(Leaf.EventEmitter);

  PointerEvent = (function() {
    function PointerEvent(e, delta1) {
      var dD, dX, dY, i, j, len, len1, name, ref, ref1, ref2, ref3, ref4, ref5, touch, value, x, y;
      this.delta = delta1;
      if (PointerEvent.winHeight == null) {
        PointerEvent.winHeight = $(window).height();
      }
      if (PointerEvent.winWidth == null) {
        PointerEvent.winWidth = $(window).width();
      }
      PointerEvent.maxDimension = Math.max(PointerEvent.winHeight, PointerEvent.winWidth);
      this.raw = e;
      this.type = e.type;
      this.src = e.target || e.srcElement;
      this.fingerCloseDistance = 140;
      this.twoHandDistance = Math.min(PointerEvent.maxDimension / 2, 440);
      this.date = new Date();
      this.shiftKey = e.shiftKey;
      if (typeof e.clientX === "number") {
        this.x = e.clientX;
        this.y = e.clientY;
        this.distance = 0;
        this.sampling = 1;
        if (e.type === "mouseup") {
          this.done = true;
        }
      } else if (typeof e.touches !== "undefined") {
        this.touches = e.touches;
        x = 0;
        y = 0;
        ref = this.touches;
        for (i = 0, len = ref.length; i < len; i++) {
          touch = ref[i];
          x += touch.clientX;
          y += touch.clientY;
        }
        this.x = x / this.touches.length;
        this.y = y / this.touches.length;
        this.indexX = (ref1 = this.touches[0]) != null ? ref1.clientX : void 0;
        this.indexY = (ref2 = this.touches[0]) != null ? ref2.clientY : void 0;
        this.indexId = ((ref3 = this.touches[0]) != null ? ref3.identifier : void 0) || -1;
        dD = 0;
        ref4 = this.touches;
        for (j = 0, len1 = ref4.length; j < len1; j++) {
          touch = ref4[j];
          dX = touch.clientX - this.x;
          dY = touch.clientY - this.y;
          dD += Math.sqrt(dX * dX + dY * dY);
        }
        this.distance = (dD / this.touches.length) * 2;
        this.sampling = this.touches.length;
        if (this.sampling === 2) {
          this.computePointAt();
        }
        if (this.type === "touchend" && this.touches.length === 0) {
          this.done = true;
        }
        if (this.type === "touchstart" && this.touches.length === 1) {
          this.increase = false;
        } else if (this.type === "touchstart") {
          this.increase = true;
        }
      } else if (e.type === "hold" && e.via) {
        ref5 = e.via;
        for (name in ref5) {
          value = ref5[name];
          if (typeof value !== "function" && (name !== "delta" && name !== "type")) {
            this[name] = value;
          }
        }
        return;
      }
    }

    PointerEvent.prototype.noTrigger = function() {
      var el;
      el = this.src;
      while (el) {
        if (el.classList.contains("com-no-trigger")) {
          return true;
        }
        el = el.parentElement;
      }
      return false;
    };

    PointerEvent.prototype.canDrag = function() {
      var el;
      el = this.src;
      while (el) {
        if (el.dragSupport === "support" || el.getAttribute("drag-support") === "support") {
          return true;
        }
        el = el.parentElement;
      }
      return false;
    };

    PointerEvent.prototype.computePointAt = function() {
      var deg, f1, f2, forwardLength, length, p1, p2, ref, unit, v, vector;
      f1 = this.touches[0];
      f2 = this.touches[1];
      p1 = {
        x: f1.clientX,
        y: f1.clientY
      };
      p2 = {
        x: f2.clientX,
        y: f2.clientY
      };
      if (p2.x < p1.x) {
        ref = [p2, p1], p1 = ref[0], p2 = ref[1];
      }
      vector = {
        x: p1.x - p2.x,
        y: p1.y - p2.y
      };
      deg = Math.PI / 2;
      v = {
        x: vector.x * Math.cos(deg) - vector.y * Math.sin(deg),
        y: vector.y * Math.cos(deg) + vector.x * Math.sin(deg)
      };
      length = Math.sqrt(v.x * v.x + v.y * v.y);
      unit = {
        x: v.x / length,
        y: v.y / length
      };
      forwardLength = this.fingerCloseDistance / 2;
      this.pointAtX = unit.x * forwardLength + this.x;
      return this.pointAtY = unit.y * forwardLength + this.y;
    };

    PointerEvent.prototype.isFingerClose = function() {
      var isClose;
      isClose = this.distance < this.fingerCloseDistance;
      return isClose;
    };

    PointerEvent.prototype.isTwoHand = function() {
      var isTwoHand;
      isTwoHand = this.distance > this.twoHandDistance;
      return isTwoHand;
    };

    PointerEvent.prototype.debugString = function() {
      return "x:" + this.x + ",y:" + this.y + ",sample:" + this.sampling + ",done:" + this.done + ",increase:" + this.increase;
    };

    PointerEvent.prototype.deltaTo = function(p) {
      return {
        x: this.x - p.x,
        y: this.y - p.y
      };
    };

    PointerEvent.prototype.distanceTo = function(p, option) {
      var dX, dY;
      if (option == null) {
        option = {};
      }
      if (option.index) {
        dX = p.indexY - this.indexY;
        dY = p.indexY - this.indexY;
      } else {
        dX = p.x - this.x;
        dY = p.y - this.y;
      }
      return Math.sqrt(dX * dX + dY * dY);
    };

    PointerEvent.prototype.capture = function() {
      var base, base1;
      if (typeof (base = this.raw).preventDefault === "function") {
        base.preventDefault();
      }
      return typeof (base1 = this.raw).stopImmediatePropagation === "function" ? base1.stopImmediatePropagation() : void 0;
    };

    return PointerEvent;

  })();

  TriggerStack = (function() {
    function TriggerStack() {
      this.actions = [];
      this.continuousFloor = 300;
    }

    TriggerStack.prototype.clear = function(left) {
      if (left > 0) {
        return this.actions = this.actions.slice(-left);
      } else {
        return this.actions.length = 0;
      }
    };

    TriggerStack.prototype.feed = function(p) {
      var date;
      date = new Date;
      date.p = p;
      if (this.actions.length > 0 && !this.near(p, this.actions[this.actions.length - 1].p)) {
        this.clear();
      }
      return this.actions.push(date);
    };

    TriggerStack.prototype.near = function(p1, p2) {
      return p1.distanceTo(p2) < 20;
    };

    TriggerStack.prototype.consume = function() {
      var current, old, previous;
      if (this.actions.length > 3) {
        this.actions = this.actions.slice(-3);
      }
      while (this.actions.length < 3) {
        this.actions.unshift(0);
      }
      current = this.actions[2];
      previous = this.actions[1];
      old = this.actions[0];
      if (current - previous > this.continuousFloor) {
        return 1;
      } else if (previous - old > this.continuousFloor) {
        return 2;
      } else {
        return 3;
      }
    };

    return TriggerStack;

  })();

  ViewPortPointerController = (function(superClass) {
    extend(ViewPortPointerController, superClass);

    function ViewPortPointerController(buffer, viewPort) {
      var lastPointDate, pt;
      this.buffer = buffer;
      this.viewPort = viewPort;
      ViewPortPointerController.__super__.constructor.call(this);
      this.triggerStack = new TriggerStack();
      this.selectSession = this.buffer.selectSession;
      this.editor = this.buffer.editor;
      lastPointDate = null;
      pt = (function(_this) {
        return function(e) {
          var delta;
          if (e.which !== 1) {
            return;
          }
          if (_this.buffer.lockUserInput) {
            return;
          }
          if (!_this.buffer.interactive) {
            return;
          }
          if (lastPointDate == null) {
            lastPointDate = new Date();
          }
          delta = new Date() - lastPointDate;
          lastPointDate = new Date();
          e = new PointerEvent(e, delta);
          _this.data.currentX = e.x;
          _this.data.currentY = e.y;
          _this.viewPort.emit("hasInteraction", e);
          return _this.give("pointer", e);
        };
      })(this);
      this.viewPort.scrollable.addEventListener("mousedown", pt);
      this.viewPort.scrollable.addEventListener("mouseup", pt);
      this.viewPort.scrollable.addEventListener("mousemove", pt);
      this.setState("idle");
    }

    ViewPortPointerController.prototype.reset = function() {
      ViewPortPointerController.__super__.reset.call(this);
      return this.resetSelection();
    };

    ViewPortPointerController.prototype.resetSelection = function() {
      return this.selectSession.clear();
    };

    ViewPortPointerController.prototype.reform = function() {
      this.reset();
      return this.setState("idle");
    };

    ViewPortPointerController.prototype.atPanic = function() {
      Logger.error(this.panicError, this.panicState);
      this.reset();
      return this.setState("idle");
    };

    ViewPortPointerController.prototype.atIdle = function() {
      var base;
      if ((base = this.data).rev == null) {
        base.rev = 0;
      }
      this.data.dragging = false;
      return this.waitFor("pointer", function(p) {
        this.data.p = p;
        if (p.type === "mousedown") {
          this.data.rev += 1;
          return this.setState("initMousedown");
        } else if (p.type === "mousemove") {
          if (this.editor.platform.isMouseDown) {
            this.selectSession.selection.deactivate();
            return this.setState("initMousemove");
          } else {
            return this.setState("idle");
          }
        } else {
          this.resetSelection();
          return this.setState("idle");
        }
      });
    };

    ViewPortPointerController.prototype.atInitMousedown = function() {
      var el, p, ref, trigger;
      p = this.data.p;
      el = p.src;
      if (p.noTrigger()) {
        this.setState("idle");
        return;
      }
      if (p.canDrag()) {
        this.data.dragging = true;
      }
      if (!this.data.dragging) {
        while (el) {
          if (((ref = el.com) != null ? ref.trigger : void 0) && el.com.transactTrigger({
            via: "mouse"
          })) {
            p.capture();
            this.resetSelection();
            this.selectSession.clearDomSelection();
            this.viewPort.setCursorByClientPoint(p.x, p.y);
            this.selectSession.selection.collapseToCursor();
            this.selectSession.selection.activate();
            this.setState("idle");
            return;
          }
          el = el.parentElement;
        }
      }
      this.triggerStack.feed(p);
      trigger = this.triggerStack.consume();
      p.capture();
      if (trigger === 2) {
        this.setState("handleDoubleDown");
        return;
      } else if (trigger === 3) {
        this.setState("handleTrippleDown");
        return;
      }
      if (!p.shiftKey) {
        this.selectSession.clearDomSelection();
      } else {
        this.selectSession.selection.activate();
      }
      this.viewPort.setCursorByClientPoint(p.x, p.y);
      if (!p.shiftKey) {
        this.selectSession.selection.collapseToCursor();
      }
      this.selectSession.selection.activate();
      return this.setState("waitInitMouseup");
    };

    ViewPortPointerController.prototype.atWaitInitMouseup = function() {
      return this.waitFor("pointer", (function(_this) {
        return function(p) {
          _this.data.p = p;
          if (p.type === "mousemove") {
            return _this.setState("initMousemove");
          } else if (p.type === "mouseup") {
            return _this.setState("initMouseup");
          } else {
            _this.resetSelection();
            return _this.setState("idle");
          }
        };
      })(this));
    };

    ViewPortPointerController.prototype.atInitMousemove = function() {
      var p;
      p = this.data.p;
      this.viewPort.setCursorByClientPoint(p.x, p.y);
      if (this.data.dragging) {
        this.selectSession.selection.collapseToCursor();
        this.selectSession.selection.deactivate();
        this.selectSession.clearDomSelection();
      }
      return this.setState("waitInitMouseup");
    };

    ViewPortPointerController.prototype.atInitMouseup = function() {
      var p;
      p = this.data.p;
      if (p.noTrigger()) {
        this.setState("idle");
      }
      if (!this.buffer.isFocusing) {
        this.buffer.editor.bufferManager.focusAt(this.buffer);
      }
      if (this.data.dragging) {
        this.selectSession.selection.collapseToCursor();
      }
      if (this.selectSession.selection.isCollapsed()) {
        this.selectSession.selection.deactivate();
      }
      p.capture();
      return this.setState("idle");
    };

    ViewPortPointerController.prototype.atHandleDoubleDown = function() {
      if (this.selectSession.selection.isCollapsed() || !this.selectSession.isActive) {
        this.viewPort.setCursorByClientPoint(this.data.p.x, this.data.p.y);
        this.selectSession.selectCurrentWord();
        this.setState("consumeVoidMouseup");
      } else {
        this.setState("consumeVoidMouseup");
      }
      return this.previousDoubleRev = this.data.rev;
    };

    ViewPortPointerController.prototype.atHandleTrippleDown = function() {
      var pt;
      pt = this.data.previousTrippleRev;
      this.data.previousTrippleRev = this.data.rev;
      if (this.data.rev - 1 === pt && !this.data.multiTripple) {
        this.viewPort.setCursorByClientPoint(this.data.p.x, this.data.p.y);
        this.selectSession.selectCurrentWord();
        this.data.multiTripple = true;
      } else {
        this.viewPort.setCursorByClientPoint(this.data.p.x, this.data.p.y);
        this.selectSession.selectCurrentLine();
        this.data.multiTripple = false;
      }
      return this.setState("consumeVoidMouseup");
    };

    ViewPortPointerController.prototype.atConsumeVoidMouseup = function() {
      return this.waitFor("pointer", (function(_this) {
        return function(p) {
          if (p.type === "mouseup") {
            return _this.setState("idle");
          } else if (p.type === "mousemove") {
            return _this.setState("consumeVoidMouseup");
          } else {
            _this.resetSelection();
            return _this.setState("idle");
          }
        };
      })(this));
    };

    return ViewPortPointerController;

  })(Leaf.States);

  TimeFeed = (function() {
    function TimeFeed(controller) {
      this.controller = controller;
      this.feedInterval = 100;
    }

    TimeFeed.prototype.start = function(template) {
      if (this.isStart) {
        return;
      }
      this.template = template;
      this.isStart = true;
      this.lastDate = new Date();
      if (this.rev == null) {
        this.rev = 0;
      }
      return this.timer = setInterval((function(_this) {
        return function() {
          var delta, hp;
          if (!_this.isStart) {
            _this.stop();
            return;
          }
          delta = new Date() - _this.lastDate;
          hp = new PointerEvent({
            type: "hold",
            via: _this.template
          }, delta);
          hp.rev = _this.rev;
          _this.controller.give("pointer", hp);
          _this.lastDate = new Date();
          return _this.rev += 1;
        };
      })(this), this.feedInterval);
    };

    TimeFeed.prototype.stop = function() {
      this.isStart = false;
      return clearTimeout(this.timer);
    };

    return TimeFeed;

  })();

  PathTracer = (function() {
    function PathTracer() {
      this.path = [];
      this.__defineGetter__("length", (function(_this) {
        return function() {
          return _this.path.length;
        };
      })(this));
      this.__defineGetter__("duration", (function(_this) {
        return function() {
          return _this.last.date.getTime() - _this.first.date.getTime();
        };
      })(this));
      this.__defineGetter__("maxFinger", (function(_this) {
        return function() {
          var i, item, len, ref, sampling;
          sampling = 0;
          ref = _this.path;
          for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            if (item.sampling > sampling) {
              sampling = item.sampling;
            }
          }
          return sampling;
        };
      })(this));
      this.__defineGetter__("finalVector", (function(_this) {
        return function() {
          var x, y;
          x = _this.last.indexX - _this.first.indexX;
          y = _this.last.indexY - _this.first.indexY;
          return {
            x: x,
            y: y
          };
        };
      })(this));
      this.__defineGetter__("monotonicX", (function(_this) {
        return function() {
          var _diff, diff, i, index, item, len, prev, ref;
          diff = 0;
          ref = _this.path;
          for (index = i = 0, len = ref.length; i < len; index = ++i) {
            item = ref[index];
            prev = _this.path[index - 1];
            if (!prev) {
              continue;
            }
            _diff = item.indexX - diff.indexX;
            if (diff === 0) {
              diff = _diff;
            } else if (diff * _diff < 0) {
              return false;
            }
          }
          return true;
        };
      })(this));
      this.__defineGetter__("monotonicY", (function(_this) {
        return function() {
          var _diff, diff, i, index, item, len, prev, ref;
          diff = 0;
          ref = _this.path;
          for (index = i = 0, len = ref.length; i < len; index = ++i) {
            item = ref[index];
            prev = _this.path[index - 1];
            if (!prev) {
              continue;
            }
            _diff = item.indexY - diff.indexY;
            if (diff === 0) {
              diff = _diff;
            } else if (diff * _diff < 0) {
              return false;
            }
          }
          return true;
        };
      })(this));
      this.__defineGetter__("monotonic", (function(_this) {
        return function() {
          return _this.monoticX && _this.monoticY;
        };
      })(this));
      this.__defineGetter__("first", (function(_this) {
        return function() {
          return _this.path[0];
        };
      })(this));
      this.__defineGetter__("last", (function(_this) {
        return function() {
          return _this.path[_this.path.length - 1];
        };
      })(this));
    }

    PathTracer.prototype.push = function(p) {
      return this.path.push(p);
    };

    PathTracer.prototype.clear = function() {
      return this.path.length = 0;
    };

    return PathTracer;

  })();

  ViewPortTouchController = (function(superClass) {
    extend(ViewPortTouchController, superClass);

    function ViewPortTouchController(buffer, viewPort) {
      var lastPointDate, pt;
      this.buffer = buffer;
      this.viewPort = viewPort;
      ViewPortTouchController.__super__.constructor.call(this);
      this.editor = this.buffer.editor;
      this.pathTracer = new PathTracer();
      this.triggerStack = new TriggerStack();
      this.selectSession = this.buffer.selectSession;
      this.timeFeed = new TimeFeed(this);
      this.antiShakeDistance = 5;
      this.holdLimit = 800;
      this.maxSwipeDuration = 500;
      lastPointDate = null;
      pt = (function(_this) {
        return function(e) {
          var delta;
          if (_this.buffer.lockUserInput) {
            return;
          }
          if (!_this.buffer.interactive) {
            return;
          }
          if (lastPointDate == null) {
            lastPointDate = new Date();
          }
          delta = new Date() - lastPointDate;
          lastPointDate = new Date();
          e = new PointerEvent(e, delta);
          _this.data.currentX = e.x;
          _this.data.currentY = e.y;
          if (_this.data.touchSession) {
            if (_this.data.touchSession.maxSampling < e.sampling || !_this.data.touchSession.maxSampling) {
              _this.data.touchSession.maxSampling = e.sampling;
            }
            _this.data.touchSession.currentSampling = e.sampling;
          }
          _this.viewPort.emit("hasInteraction", e);
          return _this.give("pointer", e);
        };
      })(this);
      this.thumbControlSession = new ThumbControlSession(this.viewPort);
      this.viewPort.scrollable.addEventListener("touchstart", pt);
      this.viewPort.scrollable.addEventListener("touchend", pt);
      this.viewPort.scrollable.addEventListener("touchmove", pt);
      this.viewPort.scrollable.addEventListener("touchcancel", pt);
      this.setState("idle");
    }

    ViewPortTouchController.prototype.reform = function() {
      this.reset();
      return this.setState("idle");
    };

    ViewPortTouchController.prototype.atPanic = function() {
      this.reset();
      this.setState("idle");
      return Logger.error("ERROR " + this.panicState + " " + (this.panicError.toString()));
    };

    ViewPortTouchController.prototype.reset = function() {
      ViewPortTouchController.__super__.reset.call(this);
      this.thumbControlSession.reset();
      return this.resetSelection();
    };

    ViewPortTouchController.prototype.resetSelection = function() {
      return this.selectSession.clear();
    };

    ViewPortTouchController.prototype.handleTouchmove = function() {
      var antiShakeX, antiShakeY, deltaLimitLeft, deltaLimitTop, p, ref, sp;
      p = this.data.movePoint;
      sp = ((ref = p.touches) != null ? ref.length : void 0) || 0;
      if (this.data.touchSession.maxSampling > 1) {
        p.capture();
      }
      if (this.data.touchSession.maxSampling > 2) {
        return;
      }
      if (!sp || sp < 2) {
        return;
      }
      if (sp === 2 || true) {
        p.capture();
        deltaLimitTop = 1500;
        deltaLimitLeft = 220;
        antiShakeX = 20;
        antiShakeY = 40;
        if (p.isFingerClose()) {
          this.data.baseTwoHandPoint = null;
          this.viewPort.setCursorByClientPoint(p.pointAtX, p.pointAtY);
        } else if (p.isTwoHand() || true) {
          this.thumbControlSession.feed("point", p);
          return;
        } else {
          this.data.baseTwoHandPoint = null;
          this.viewPort.setCursorByClientPoint(p.x, p.y);
        }
        this.thumbControlSession.reset();
      } else if (sp === 3) {

      }
    };

    ViewPortTouchController.prototype.log = function(name, message, time) {
      if (time == null) {
        time = 3000;
      }
      if (typeof message === "undefined") {
        message = name;
        name = "Default";
      }
      if (typeof message === "undefined") {
        return;
      }
      return require("/app").site.editor.plugin("HintManager").hint(name, message, {
        persist: false,
        type: "warning",
        time: time
      });
    };

    ViewPortTouchController.prototype.atIdle = function() {
      var base;
      this.timeFeed.stop();
      if ((base = this.data).rev == null) {
        base.rev = 0;
      }
      this.pathTracer.clear();
      this.thumbControlSession.reset();
      return this.waitFor("pointer", (function(_this) {
        return function(p) {
          _this.data.p = p;
          _this.data.baseTwoHandPoint = null;
          if (p.type === "touchstart" && _this.handleSideTap(p)) {
            _this.setState("idle");
            return;
          }
          if (p.type === "touchstart") {
            _this.data.rev += 1;
            _this.data.holdTime = 0;
            _this.data.touchSession = {};
            return _this.setState("initTouchstart");
          } else {
            p.capture();
            return _this.setState("idle");
          }
        };
      })(this));
    };

    ViewPortTouchController.prototype.atInitTouchstart = function() {
      this.timeFeed.stop();
      this.timeFeed.start(this.data.p);
      return this.waitFor("pointer", (function(_this) {
        return function(p) {
          if (p.type === "hold") {
            _this.data.holdTime += p.delta;
            if (_this.data.holdTime > _this.holdLimit) {
              _this.data.holdTime = 0;
              return _this.setState("longPress");
            } else {
              return _this.setState("initTouchstart");
            }
          } else if (p.type === "touchmove") {
            if ((p.distanceTo(_this.data.p)) < _this.antiShakeDistance) {
              return _this.setState("initTouchstart");
            } else {
              _this.data.movePoint = p;
              _this.data.startPoint = _this.data.p;
              _this.pathTracer.clear();
              return _this.setState("initTouchmove");
            }
          } else if (p.type === "touchend") {
            if (p.done) {
              _this.data.startPoint = _this.data.p;
              _this.data.endPoint = p;
              return _this.setState("tap");
            } else {
              return _this.setState("initTouchstart");
            }
          } else if (p.type === "touchcancel") {
            if (p.done) {
              return _this.setState("idle");
            } else {
              return _this.setState("initTouchstart");
            }
          } else if (p.type === "touchstart") {
            if (!p.increase) {
              _this.data.p = p;
              return _this.setState("initTouchstart");
            } else {
              _this.data.startPoint = _this.data.p;
              _this.data.movePoint = p;
              return _this.setState("initTouchmove");
            }
          } else {
            return _this.setState("idle");
          }
        };
      })(this));
    };

    ViewPortTouchController.prototype.atInitTouchmove = function() {
      if (this.data.movePoint) {
        this.pathTracer.push(this.data.movePoint);
      }
      this.timeFeed.stop();
      if (this.data.movePoint) {
        this.timeFeed.start(this.data.movePoint);
      }
      this.handleTouchmove();
      return this.waitFor("pointer", (function(_this) {
        return function(p) {
          if (p.type === "touchmove" || (p.type === "touchstart" && p.increase)) {
            if (_this.data.touchSession.maxSampling > 1) {
              p.capture();
            }
            _this.data.movePoint = p;
            return _this.setState("initTouchmove");
          } else if (p.type === "touchcancel") {
            if (p.done) {
              return _this.setState("idle");
            } else {
              return _this.setState("idle");
            }
          } else if (p.type === "touchend") {
            if (p.done && _this.data.movePoint.distanceTo(_this.data.startPoint, {
              index: true
            }) < _this.antiShakeDistance) {
              _this.data.endPoint = p;
              return _this.setState("tap");
            } else if (p.done && _this.pathTracer.maxFinger === 1 && _this.pathTracer.length > 2 && _this.pathTracer.duration < _this.maxSwipeDuration) {
              _this.data.endPoint = p;
              return _this.setState("swipe");
            } else if (p.done) {
              return _this.setState("idle");
            } else {
              _this.data.movePoint = p;
              return _this.setState("initTouchmove");
            }
          } else if (p.type === "hold") {
            _this.data.movePoint = p;
            return _this.setState("initTouchmove");
          } else if (p.type === "touchstart") {
            _this.data.p = p;
            return _this.setState("initTouchstart");
          } else {
            return _this.setState("idle");
          }
        };
      })(this));
    };

    ViewPortTouchController.prototype.atTap = function() {
      var e, el, error, ref, ref1, ref2, ref3, trigger;
      el = this.data.startPoint.src;
      if (((ref = this.data.touchSession.maxSampling) !== 1 && ref !== 3) && this.data.touchSession.maxSampling) {
        this.setState("idle");
        return;
      }
      if ((ref1 = this.data.endPoint) != null) {
        ref1.capture();
      }
      if (this.data.touchSession.maxSampling === 3) {
        this.resetSelection();
        this.setState("idle");
        return;
      }
      this.triggerStack.feed(this.data.startPoint);
      trigger = this.triggerStack.consume();
      if (trigger === 1 && this.handleSideTap(this.data.startPoint)) {
        this.triggerStack.clear(0);
        this.setState("idle");
        return;
      }
      if (trigger === 1) {
        this.selectSession.selection.deactivate();
        this.viewPort.setCursorByClientPoint(this.data.startPoint.x, this.data.startPoint.y);
        return this.setState("idle");
      } else if (trigger === 2) {
        try {
          if (!this.data.startPoint.noTrigger()) {
            while (el && !(this.data.touchSession.maxSampling > 1)) {
              if ((ref2 = el.com) != null ? ref2.trigger : void 0) {
                Vibration.feedback();
                if (el.com.transactTrigger({
                  via: "tap"
                })) {
                  if ((ref3 = this.data.endPoint) != null) {
                    ref3.capture();
                  }
                  this.resetSelection();
                  this.setState("idle");
                  return;
                }
              }
              el = el.parentElement;
            }
          }
        } catch (error) {
          e = error;
          this.log("ERROR " + (e.toString()));
        }
        return this.setState("idle");
      } else if (trigger === 3) {
        this.triggerStack.clear(0);
        return this.setState("idle");
      }
    };

    ViewPortTouchController.prototype.atSwipe = function() {
      var e, error;
      this.minSwipeX = 100;
      this.minSwipeY = 100;
      try {
        if (this.pathTracer.finalVector.x > this.minSwipeX) {
          this.editor.inputMethod.emit("key", new KeyEvent({
            simulateName: "swipeRight"
          }));
        } else if (this.pathTracer.finalVector.x < -this.minSwipeX) {
          this.editor.inputMethod.emit("key", new KeyEvent({
            simulateName: "swipeLeft"
          }));
        }
        if (this.pathTracer.finalVector.y > this.minSwipeY) {
          this.editor.inputMethod.emit("key", new KeyEvent({
            simulateName: "swipeDown"
          }));
        } else if (this.pathTracer.finalVector.y < -this.minSwipeY) {
          this.editor.inputMethod.emit("key", new KeyEvent({
            simulateName: "swipeUp"
          }));
        }
      } catch (error) {
        e = error;
        this.log(Math.random(), "error " + (JSON.stringify(e.message)), 1000);
      }
      this.pathTracer.clear();
      return this.setState("idle");
    };

    ViewPortTouchController.prototype.atLongPress = function() {
      if (!this.selectSession.selection.isActive) {
        this.viewPort.setCursorByClientPoint(this.data.p.x, this.data.p.y);
        this.selectSession.selectCurrentWord();
      } else {
        this.selectSession.selection.deactivate();
      }
      Vibration.feedback();
      return this.setState("idle");
    };

    ViewPortTouchController.prototype.handleSideTap = function(p) {
      var e, error;
      if (this.clientWidth == null) {
        this.clientWidth = $(window).width();
      }
      if (this.sideTapLimit == null) {
        this.sideTapLimit = 30;
      }
      try {
        if (p.x < this.sideTapLimit) {
          this.editor.conduct("backward-char");
          return true;
        }
        if (p.x > this.clientWidth - this.sideTapLimit) {
          this.editor.conduct("forward-char");
          return true;
        }
      } catch (error) {
        e = error;
        Logger.error("error " + e.message + " " + e.name);
      }
      return false;
    };

    return ViewPortTouchController;

  })(Leaf.States);

  ThumbControlSession = (function(superClass) {
    extend(ThumbControlSession, superClass);

    function ThumbControlSession(viewPort) {
      this.viewPort = viewPort;
      ThumbControlSession.__super__.constructor.call(this);
      this.editor = this.viewPort.editor;
      this.stepX = 5;
      this.stepY = 10;
      this.xFloor = 4;
      this.yFloor = 12;
      this.offsetXScale = 1.7;
      this.offsetYScale = 2.2;
      this.offsetXAtiShake = 0;
      this.offsetYAtiShake = 0;
    }

    ThumbControlSession.prototype.reset = function() {
      ThumbControlSession.__super__.reset.call(this);
      return this.setState("waitFirstPoint");
    };

    ThumbControlSession.prototype.atWaitFirstPoint = function() {
      return this.consumeWhenAvailable("point", (function(_this) {
        return function(p) {
          _this.data.startPoint = p;
          _this.viewPort.setCursorByClientPoint(p.x, p.y);
          _this.lastPointDate = new Date();
          return _this.setState("waitMovePoint");
        };
      })(this));
    };

    ThumbControlSession.prototype.atWaitMovePoint = function() {
      return this.consumeWhenAvailable("point", (function(_this) {
        return function(p) {
          _this.distributeCommandByPoint(p);
          return _this.setState("waitMovePoint");
        };
      })(this));
    };

    ThumbControlSession.prototype.distributeCommandByPoint = function(p) {
      var dx, dy, fdx, fdy, fx, fy, px, py;
      dx = p.x - this.data.startPoint.x;
      dy = p.y - this.data.startPoint.y;
      if (dx >= 0) {
        fx = 1;
      } else {
        fx = -1;
      }
      if (dy >= 0) {
        fy = 1;
      } else {
        fy = -1;
      }
      fdx = (dx - this.offsetXAtiShake * fx) * this.offsetXScale;
      fdy = (dy - this.offsetYAtiShake * fy) * this.offsetYScale;
      if (fdx * fx > 0) {
        px = fdx + this.data.startPoint.x;
      } else {
        px = this.data.startPoint.x;
      }
      if (fdy * fy > 0) {
        py = fdy + this.data.startPoint.y;
      } else {
        py = this.data.startPoint.y;
      }
      if (px !== this.data.startPoint.x || py !== this.data.startPoint.y) {
        return this.viewPort.setCursorByClientPoint(px, py);
      }
    };

    ThumbControlSession.prototype.distributeCommandByPointVelocity = function(p) {
      var dT, dvx, dvy, dx, dy;
      if (!this.data.lastPoint) {
        this.data.lastPoint = this.data.startPoint;
        this.data.lastDate = this.data.lastPoint.date;
      }
      if (p.type === "hold") {
        p = this.data.lastPoint;
      }
      dT = Date.now() - this.data.lastDate.getTime();
      if (dT === 0) {
        return;
      }
      dx = (p.x + this.data.lastPoint.x) / 2 - this.data.startPoint.x;
      dy = (p.y + this.data.lastPoint.y) / 2 - this.data.startPoint.y;
      dvx = dx * dT / 1000;
      dvy = dy * dT / 1000;
      this.accumulateX(dvx);
      this.accumulateY(dvy);
      this.data.lastPoint = p;
      return this.data.lastDate = new Date;
    };

    ThumbControlSession.prototype.distributeCommandByPointAboluste = function() {
      var countX, countY, dx, dy;
      dx = p.x - this.data.startPoint.x;
      dy = p.y - this.data.startPoint.y;
      countX = Math.round(dx / this.stepX);
      countY = Math.round(dy / this.stepY);
      this.applyVerticle(countY);
      return this.applyHorizental(countX);
    };

    ThumbControlSession.prototype.accumulateX = function(value) {
      var base, results;
      if ((base = this.data).xValue == null) {
        base.xValue = 0;
      }
      this.data.xValue += value;
      while (this.data.xValue > this.xFloor) {
        this.data.xValue -= this.xFloor;
        this.right();
      }
      results = [];
      while (this.data.xValue < -this.xFloor) {
        this.data.xValue += this.xFloor;
        results.push(this.left());
      }
      return results;
    };

    ThumbControlSession.prototype.accumulateY = function(value) {
      var base, results;
      if ((base = this.data).yValue == null) {
        base.yValue = 0;
      }
      this.data.yValue += value;
      while (this.data.yValue > this.yFloor) {
        this.data.yValue -= this.yFloor;
        this.down();
      }
      results = [];
      while (this.data.yValue < -this.yFloor) {
        this.data.yValue += this.yFloor;
        results.push(this.up());
      }
      return results;
    };

    ThumbControlSession.prototype.applyVerticle = function(count) {
      var base, down, results;
      if ((base = this.data).currentVertical == null) {
        base.currentVertical = 0;
      }
      down = count - this.data.currentVertical;
      while (down > this.data.currentVertical) {
        this.down();
        this.data.currentVertical += 1;
      }
      results = [];
      while (down < this.data.currentVertical) {
        this.up();
        results.push(this.data.currentVertical -= 1);
      }
      return results;
    };

    ThumbControlSession.prototype.applyHorizental = function(count) {
      var base, results, right;
      if ((base = this.data).currentHorizental == null) {
        base.currentHorizental = 0;
      }
      right = count - this.data.currentHorizental;
      while (right > this.data.currentHorizental) {
        this.right();
        this.data.currentHorizental += 1;
      }
      results = [];
      while (right < this.data.currentHorizental) {
        this.left();
        results.push(this.data.currentHorizental -= 1);
      }
      return results;
    };

    ThumbControlSession.prototype.down = function() {
      return this.editor.conduct("downward-char");
    };

    ThumbControlSession.prototype.up = function() {
      return this.editor.conduct("upward-char");
    };

    ThumbControlSession.prototype.right = function() {
      return this.editor.conduct("forward-char");
    };

    ThumbControlSession.prototype.left = function() {
      return this.editor.conduct("backward-char");
    };

    return ThumbControlSession;

  })(Leaf.States);

  module.exports = ViewPort;

}).call(this);

}
GlobalContext.setModule("vincent/facility/viewPort.js",module,exec);
})();
})();
(function(){GlobalContext.require("index")})();
